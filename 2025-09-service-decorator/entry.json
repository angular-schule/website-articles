{"slug":"2025-09-service-decorator","html":"<p>With Angular 20, the service suffix has been removed from the new style guide.\nWhile this leads to shorter filenames, it also makes the role of classes less obvious.\nThis article presents a <strong>thought experiment</strong> that introduces a custom <code>@Service</code> decorator to solve this issue elegantly.</p>\n<h2 id=\"angular-20-the-service-suffix-is-gone\">Angular 20: The service suffix is gone</h2>\n<p>The new major version of Angular brings some significant changes.\nThe new <a href=\"https://angular.dev/style-guide\">Angular coding style guide</a> for v20 has been greatly revised and condensed.\nIt is <em>no longer</em> recommended to suffix components, services, and directives.</p>\n<p>The command <code>ng generate service book-store</code> no longer creates a class named <code>BookStoreService</code>, but instead just <code>BookStore</code>.\nAccordingly, <code>book-store.service.ts</code> is now simply <code>book-store.ts</code>.</p>\n<p>That&#39;s generally a great idea.\nWe get shorter filenames and more emphasis on deliberate naming.\nBut there is one small downside:\nWe no longer immediately recognize that a class is intended to be used as a service.</p>\n<p><strong>until Angular 19:</strong></p>\n<pre><code class=\"language-ts\">// book-store.service.ts\n\n<span class=\"hljs-variable\">@Injectable</span>({\n  providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span>\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStoreService</span> </span>{ }\n</code></pre>\n<p><strong>starting from Angular 20:</strong></p>\n<pre><code class=\"language-ts\">// book-store.ts\n\n<span class=\"hljs-variable\">@Injectable</span>({\n  providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span>\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{ }\n</code></pre>\n<p>Anyone who has used Angular for a while knows that the <code>@Injectable</code> decorator almost always indicates a service.\nNevertheless, in my opinion, the intended use of this decorator could be communicated even more clearly.</p>\n<p>In the well-known Java framework Spring Boot, <code>@Service</code> is a common annotation that indicates that a class contains service logic:</p>\n<pre><code class=\"language-java\">import org.springframework.stereotype.Service;\n\n<span class=\"hljs-variable\">@Service</span>\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStoreService</span> </span>{\n    // ...\n}\n</code></pre>\n<p>Additionally, there are other annotations like <code>@Repository</code>.\nIn Spring, <code>@Repository</code> has exactly the same functionality as <code>@Service</code>.\nThe only difference is that <code>@Repository</code> also signals that this class implements the repository pattern.\nPersonally, I find it very elegant when the purpose of a class is as clearly identifiable as possible.</p>\n<h2 id=\"the-motivation--my-service-decorator-for-angular\">The motivation ‚Äì My <code>@Service()</code> decorator for Angular</h2>\n<p>So what do we do if we want to drop the familiar <code>Service</code> suffix but still make it obvious that a class is a service?</p>\n<p>My idea: Why don&#39;t we just introduce a custom decorator named <code>@Service()</code>?\nThen the decorator itself would make it clear that the class is a service.\nAnd while we&#39;re at it, let&#39;s also remove the repetitive <code>providedIn: &#39;root&#39;</code>.</p>\n<p>If I could wish for a change in the Angular framework, it might look like this:</p>\n<pre><code class=\"language-ts\">// book-store.ts\n\n<span class=\"hljs-variable\">@Service</span>()\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{ }\n</code></pre>\n<p>Here&#39;s what I specifically envision as improvements:</p>\n<ol>\n<li>We continue to omit the <code>Service</code> suffix.</li>\n<li>We no longer have to write <code>providedIn: &#39;root&#39;</code> for every service. That&#39;s always annoyed me.</li>\n</ol>\n<h2 id=\"the-goal-more-compact-clearer-and-less-boilerplate-code\">The goal: more compact, clearer, and less boilerplate code</h2>\n<p>So, my goal is a more elegant decorator that:</p>\n<ul>\n<li>clearly signals that the class is a service,</li>\n<li>automatically registers it in the root injector (<code>providedIn: &#39;root&#39;</code>),</li>\n<li>is fully compatible with the AOT compiler and Ivy.</li>\n</ul>\n<p>In short: a decorator that has a compact syntax and brings me personal joy. üòá</p>\n<h2 id=\"what-options-do-we-have\">What options do we have?</h2>\n<p>Developing such a custom decorator isn&#39;t completely trivial, especially since Angular tightly controls how DI works internally.\nLet&#39;s look at a few possible approaches:</p>\n<h3 id=\"idea-1-inheriting-from-injectable\">Idea 1: Inheriting from <code>@Injectable</code></h3>\n<p>A logical idea would be to annotate a base class with <code>@Injectable()</code> and extend it:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable</span>({ \n  providedIn: &#x27;root&#x27; \n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseService</span> </span>{}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseService</span> </span>{}\n</code></pre>\n<p>Unfortunately, this doesn&#39;t work because Angular stores metadata at compile time directly on the target class.\nThis metadata is not inherited.\nThe framework simply doesn&#39;t find the service, and we get the following error at runtime:</p>\n<blockquote>\n<p><strong>‚ùå Error:</strong> NullInjectorError: No provider for BookStore!</p>\n</blockquote>\n<p>Aside from the technical issue, this also doesn&#39;t meet our goal of creating a real decorator.</p>\n<h2 id=\"idea-2-custom-decorator-that-wraps-injectable\">Idea 2: Custom decorator that wraps <code>@Injectable</code></h2>\n<p>A second idea would be to create a simple wrapper:</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Service</span>(): ClassDecorator {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Injectable({</span> providedIn: <span class=\"hljs-symbol\">&#x27;root</span>&#x27; });\n}\n</code></pre>\n<p>This code also compiles, but as soon as we try to inject the decorated service via DI, we get the following runtime error:</p>\n<blockquote>\n<p><strong>‚ùå Error:</strong> The injectable &#39;BookStore2&#39; needs to be compiled using the JIT compiler, but &#39;@angular/compiler&#39; is not available.\nJIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\nAlternatively, the JIT compiler should be loaded by bootstrapping using &#39;@angular/platform-browser-dynamic&#39; or &#39;@angular/platform-server&#39;,\n  or manually provide the compiler with &#39;import &quot;@angular/compiler&quot;;&#39; before bootstrapping.</p>\n</blockquote>\n<p>To better understand this error message, we need some background knowledge about the terms &#39;AOT&#39; and &#39;JIT&#39;, which can be quickly explained:\nAngular supports two types of compilation: the <strong>JIT mode (Just-in-Time)</strong> and the <strong>AOT mode (Ahead-of-Time)</strong>.\nIn JIT mode, Angular compiles components and decorators at runtime directly in the browser.\nWhile flexible, this approach is relatively slow and therefore not recommended in production.\nIn contrast, AOT mode performs the compilation during the build process.\nThis results in significantly better performance and smaller bundle sizes.\nSince the introduction of the Ivy engine (since Angular 9), AOT is the default mode, and as developers we normally don&#39;t need to worry about this topic anymore.\nTherefore, it&#39;s important that our decorators are fully AOT-compatible, which unfortunately is not the case here.</p>\n<p>Conclusion: This variant only works in JIT mode and is unfortunately not supported by the AOT compiler.</p>\n<h2 id=\"idea-3-using-internal-angular-ivy-apis\">Idea 3: Using internal Angular Ivy APIs</h2>\n<p>The previous approaches didn&#39;t work. Now let&#39;s look at internal Ivy APIs.\nThese are mechanisms Angular itself uses to provide services.\n<strong>Important: We are consciously venturing into experimental territory!</strong>\nWe&#39;re using an internal but undocumented Angular API.\nThis approach is more suitable as an experiment than a recommendation for production.</p>\n<p>The central internal API of interest is <a href=\"https://github.com/angular/angular/blob/a40abf09f1abcabda3752ed915bb90e4eafe078d/packages/core/src/di/interface/defs.ts#L167\"><code>…µ…µdefineInjectable</code></a>.\nThis function creates the necessary metadata so Angular can inject the class automatically.\nThe linked code also includes usage hints: (<strong>This should be assigned to a static <code>…µprov</code> field on a type, which will then be an <code>InjectableType</code>.</strong>)</p>\n<h3 id=\"minimal-version-without-constructor-injection\">Minimal version without constructor injection</h3>\n<p>Let&#39;s start with a minimal approach that&#39;s simple but has a clear limitation:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { …µ…µdefineInjectable } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Service</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title function_\">ClassDecorator</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">target: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n    Object.defineProperty(target, <span class=\"hljs-string\">&#x27;…µprov&#x27;</span>, {\n      <span class=\"hljs-attr\">value</span>: …µ…µdefineInjectable({\n        <span class=\"hljs-attr\">token</span>: target,\n        <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,\n        <span class=\"hljs-attr\">factory</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> target()\n      })\n    });\n  };\n}\n</code></pre>\n<p>What does this code do?</p>\n<ul>\n<li>It uses <code>…µ…µdefineInjectable</code> to create an &quot;injectable definition&quot; and assigns it as a new property to <code>target</code>.</li>\n<li><code>providedIn: &#39;root&#39;</code> ensures the service is globally available without repeating that setting.</li>\n<li>The factory function simply creates a new instance of the class ‚Äì <strong>but without constructor dependencies</strong>.</li>\n</ul>\n<p>The big advantage of this approach is its simplicity.\nHowever, at runtime, we don&#39;t know what dependencies the constructor expects.\nSo we&#39;re forced to call it without arguments.\nThe major downside is that generic constructor injection isn&#39;t possible.</p>\n<p>This example demonstrates this issue.\nWe expect the <code>BookRating</code> service to be injected via the constructor.\nInstead, we just get <code>undefined</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Service</span>()\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{\n\n  constructor(br: BookRating) {\n    console.log(br) // undefined\n  }\n}\n</code></pre>\n<p>So this version is only suitable for services without constructor dependencies.\nHowever, Angular now provides a new function that also helps us in such cases.\nWe will take a closer look at exactly how this works very soon!</p>\n<h3 id=\"gregors-version-constructor-injection-with-explicit-dependencies\">Gregor&#39;s version: Constructor injection with explicit dependencies</h3>\n<p>While researching, I discovered that my fellow GDE Gregor Woiwode explored this topic 5 years ago.\nHe presented <a href=\"https://stackoverflow.com/a/59759381\">his solution</a> on StackOverflow.\nHis decorator is called <code>@InjectableEnhanced</code> and shares the same goal as this article.</p>\n<p>Gregor already demonstrated how to simulate constructor injection.\nHe uses the same API but explicitly defines dependencies in the factory function:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Gregor&#x27;s code, slightly modified:</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">InjectableEnhanced</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> &lt;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title function_\">new</span> (...<span class=\"hljs-attr\">args</span>: <span class=\"hljs-built_in\">any</span>[]) =&gt; <span class=\"hljs-title class_\">InstanceType</span>&lt;T&gt;&gt;<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">target</span>: T</span>) =&gt;</span> {\n    (target <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).…µfac = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;cannot create directly&quot;</span>);\n    };\n\n    (target <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).…µprov = …µ…µ<span class=\"hljs-title function_\">defineInjectable</span>({\n      <span class=\"hljs-attr\">token</span>: target,\n      <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&quot;root&quot;</span>,\n      <span class=\"hljs-title function_\">factory</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-comment\">// …µ…µinject can be used to get dependency being already registered</span>\n        <span class=\"hljs-keyword\">const</span> dependency = …µ…µ<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookRating</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">target</span>(dependency);\n      }\n    });\n    <span class=\"hljs-keyword\">return</span> target;\n  };\n}\n\n<span class=\"hljs-meta\">@InjectableEnhanced</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">br</span>: <span class=\"hljs-title class_\">BookRating</span></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(br) <span class=\"hljs-comment\">// works! ü•≥</span>\n  }\n}\n</code></pre>\n<p>What&#39;s happening here?</p>\n<ul>\n<li>Gregor&#39;s code defines not only <code>…µprov</code> but also explicitly <code>…µfac</code> (the factory), which is usually created automatically by the Angular compiler.\nThe code also prevents direct instantiation of the class with an early exception.\nIf you&#39;re concerned about manual instantiation, keep this check.</li>\n<li>Within the factory, the code injects each dependency explicitly using <code>…µ…µinject</code>.\nIn this case, it&#39;s our <code>BookRating</code> service.\nThis supports direct constructor injection.</li>\n<li>But caution: We have to list each dependency manually in the factory!\nThis is error-prone and tedious if the constructor parameters change.</li>\n</ul>\n<p>The code can also be rewritten to match the previous example.\nInstead of assigning <code>((target as any).…µprov)</code>, I&#39;d rather use <code>Object.defineProperty()</code>.\nThis style is a bit more verbose, but avoids bypassing the type system using a type assertion to <code>any</code>.\nI&#39;ve also left out the error message:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Gregor&#x27;s code, shortened and adapted:</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Service</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">ClassDecorator</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">target</span>: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(target, <span class=\"hljs-string\">&#x27;…µprov&#x27;</span>, {\n      <span class=\"hljs-attr\">value</span>: …µ…µ<span class=\"hljs-title function_\">defineInjectable</span>({\n        <span class=\"hljs-attr\">token</span>: target,\n        <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,\n        <span class=\"hljs-attr\">factory</span>: <span class=\"hljs-function\">() =&gt;</span> {\n          <span class=\"hljs-comment\">// …µ…µinject can be used to get dependency being already registered</span>\n          <span class=\"hljs-keyword\">const</span> dependency = …µ…µ<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookRating</span>);\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">target</span>(dependency);\n        }\n      })\n    });\n  };\n}\n\n<span class=\"hljs-meta\">@Service</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">br</span>: <span class=\"hljs-title class_\">BookRating</span></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(br) <span class=\"hljs-comment\">// still works ü•≥</span>\n  }\n}\n</code></pre>\n<p>This approach is a clever technical solution, but it has one clear limitation:\nIt isn&#39;t generic enough for all cases.\nEach service must list dependencies manually.\nGregor&#39;s old solution still works perfectly for special cases with few or always the same dependencies.</p>\n<h2 id=\"idea-4-automatic-dependency-resolution-with-reflect-metadata\">Idea 4: Automatic dependency resolution with reflect-metadata</h2>\n<p>To enable constructor injection without manually listing dependencies,\nwe could use the library <a href=\"https://www.npmjs.com/package/reflect-metadata\">reflect-metadata</a>.\nThis requires enabling <code>emitDecoratorMetadata: true</code> in <code>tsconfig.json</code> and adding <code>reflect-metadata</code> as a dependency.</p>\n<p>In older Angular versions, <code>reflect-metadata</code> was often required because the JIT compiler evaluated metadata at runtime.\nWith Ivy (since Angular 9) and AOT compilation, Angular generates static metadata at build time,\nso <code>reflect-metadata</code> is usually unnecessary in production.</p>\n<p>Using this library increases bundle size, which modern Angular projects aim to avoid.\nI therefore didn&#39;t pursue this further and don&#39;t want to reintroduce <code>reflect-metadata</code> to my projects.</p>\n<h3 id=\"idea-5-the-final-idea-dependency-injection-with-inject\">Idea 5: The final idea: Dependency injection with <code>inject()</code></h3>\n<p>Can we make it even simpler, without manually listing constructor dependencies?\nThis is where Angular&#39;s new <code>inject()</code> function comes in (which didn&#39;t exist in 2020).</p>\n<p>With <code>inject()</code>, we can obtain dependencies directly within the class definition, no need for constructor injection.\nThat solves all our previous problems:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// same code again, from previous Idea 3 example</span>\n<span class=\"hljs-keyword\">import</span> { …µ…µdefineInjectable } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Service</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title function_\">ClassDecorator</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">target: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> {\n    Object.defineProperty(target, <span class=\"hljs-string\">&#x27;…µprov&#x27;</span>, {\n      <span class=\"hljs-attr\">value</span>: …µ…µdefineInjectable({\n        <span class=\"hljs-attr\">token</span>: target,\n        <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,\n        <span class=\"hljs-attr\">factory</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> target(), <span class=\"hljs-comment\">// keine Parameter n√∂tig!</span>\n      }),\n    });\n  };\n}\n</code></pre>\n<p>Here&#39;s how to use it:</p>\n<pre><code class=\"language-ts\">\n<span class=\"hljs-variable\">@Service</span>()\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookStore</span> </span>{\n\n  <span class=\"hljs-comment\">#service = inject(BookRating); // dependency directly injected</span>\n}\n</code></pre>\n<p>Here&#39;s another example:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpClient</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Service</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./service&#x27;</span>;\n\n<span class=\"hljs-meta\">@Service</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n  #http = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">HttpClient</span>); <span class=\"hljs-comment\">// yay! ü•≥</span>\n\n  <span class=\"hljs-title function_\">getAll</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.#http.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;/api/books&#x27;</span>);\n  }\n}\n</code></pre>\n<p>Sounds elegant, at least for our little experiment!</p>\n<h3 id=\"conclusion-and-final-thoughts\">Conclusion and final thoughts</h3>\n<p>We&#39;ve now explored several versions of a custom <code>@Service()</code> decorator and seen:</p>\n<ol>\n<li><p><strong>Minimal version without constructor injection:</strong>\nSimple, but too limited for most real-world use.</p>\n</li>\n<li><p><strong>Gregor&#39;s 2020 version with explicit constructor injection:</strong>\nTechnically interesting and gives insight into how DI works under Ivy.\nIn practice, suitable only for specific cases due to the need to list dependencies manually.\nLess maintainable.</p>\n</li>\n<li><p><strong>Automatic dependency resolution via <code>reflect-metadata</code>:</strong>\nConvenient and generic, but the extra dependency increases bundle size and doesn&#39;t fit modern Ivy-based Angular.</p>\n</li>\n<li><p><strong>Modern approach: Dependency injection with <code>inject()</code>:</strong>\nLeverages Angular&#39;s new <code>inject()</code> API.\nConstructor injection isn&#39;t used, but also no longer necessary.\nThis final idea with <code>inject()</code> appeals to me personally.</p>\n</li>\n</ol>\n<p>But should we really use this decorator?</p>\n<p>Ultimately, as mentioned in the intro, this decorator is a <strong>thought experiment</strong>.\nExploring Angular&#39;s internal APIs like this is fun and educational, but in production we should be cautious:</p>\n<ul>\n<li><p><strong>Use of internal APIs:</strong>\nThe Ivy APIs (<code>…µ…µdefineInjectable</code>, <code>…µ…µinject</code>) are undocumented and could change in future Angular versions.\nThis poses a risk that the code may break or need major updates.</p>\n</li>\n<li><p><strong>Maintainability and team understanding:</strong>\nA custom decorator may seem elegant, but every new team member must learn why it exists and how it works.</p>\n</li>\n<li><p><strong>Low benefit vs. risk:</strong>\nThe only gain is slightly better readability and a bit less boilerplate.\nBut the risks and maintenance cost may outweigh this.</p>\n</li>\n</ul>\n<p>For these reasons, I&#39;d probably continue using the reliable <code>@Injectable()</code> decorator in production Angular code.\nThe official API gives us stability, maintainability, and future-proofing.</p>\n<p><strong>What do you think?</strong></p>\n<p>How do you like this experimental <code>@Service()</code> decorator?\nWould you try it anyway, or do you prefer to stick with good old <code>@Injectable()</code> like I do? ‚Ä¶or should I switch everything to <code>@Service()</code>? üòÖ</p>\n<p>I&#39;d love to hear <a href=\"https://x.com/JohannesHoppe/status/1974062116966453741\">your feedback on X</a> or <a href=\"https://bsky.app/profile/johanneshoppe.de/post/3m2buzx76fk2a\">on BlueSky</a>! üòä</p>\n<hr>\n\n<p><small>Thanks to Danny Koppenhagen for the review and valuable feedback!</small></p>\n","meta":{"title":"My experimental @Service() decorator for Angular","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-09-30T00:00:00.000Z","lastModified":"2025-09-30T00:00:00.000Z","keywords":["Angular","Angular 20","Component Suffix","Decorator","inject","Ivy","…µ…µdefineInjectable","…µ…µinject"],"language":"en","header":{"url":"service.jpg","width":2473,"height":1411}}}
