{"slug":"2020-01-ngrx-data-views","html":"<p><strong>As soon as a NgRx project gets bigger, we have to ask ourselves how we should ideally arrange the entities in the store. In this article we are going to have a look at inter-connected data and its implications when trying to elevate store output to old fashioned business objects, ready to use in all components. By tackling normalized APIs we will show you some of the most common pitfalls you might encounter along the way.</strong></p>\n<p>Table of contents:</p>\n<ul>\n<li><a href=\"/blog/2020-01-ngrx-data-views#data-clustering-in-enterprise-applications\">Data Clustering in Enterprise Applications</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#clustered-data-for-books\">Clustered data for Books</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#using-parameterized-selectors\">Using parameterized selectors</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#the-problem\">The Problem</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#using-data-views-for-de-normalization\">Using Data-Views for De-Normalization</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#the-new-problem-with-memoization\">The new problem with Memoization</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#tackling-memoization\">Tackling Memoization</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#enriched-data-views\">Enriched Data Views</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#memoized-data-view-methods\">Memoized Data View Methods</a></li>\n<li><a href=\"/blog/2020-01-ngrx-data-views#conclusion\">Conclusion</a></li>\n</ul>\n<hr>\n\n<p>Dealing with data supplied by enterprise systems can be quite tedious.\nMost of the time, data for a single entity has to be retrieved with multiple calls, because it is handled in a normalized way on the server.\nHowever, this is not bad since normalization does a good job minimizing the space used up in any database by preventing duplication and with that also inconsistencies.\nHave a look at the <a href=\"https://en.wikipedia.org/wiki/Database_normalization\">Wikipedia Article on Database Normalization</a> for more information.</p>\n<p>If the API giving us access to the data is just a simple REST API exposing all entities via separate endpoints, we have to accumulate the necessary data in the front-end ourselves.</p>\n<h2 id=\"data-clustering-in-enterprise-applications\">Data Clustering in Enterprise Applications</h2>\n<p>Too abstract? Have a look at the <a href=\"https://developer.wordpress.org/rest-api/reference/\">WordPress API Reference</a> for an example.\nIndividual Posts can be retrieved quite typically via <code>/posts/&lt;id&gt;</code>.\nHowever, the returned data just contains IDs for the author, tags and categories of the post.\nTo display a post properly with all the names and titles of depending entities, this additional data has to be retrieved with subsequent calls to other endpoints.</p>\n<p>If you were to use WordPress as a system for content management, wouldn&#39;t you want to improve the display of a single post by pre-fetching all data related to tags and authors first with list calls, whenever the application is starting up?\nThis data could then be cached and referenced whenever needed.\nIf you have been around the block, you know that <code>@ngrx/entity</code> provides a perfect API for handling multiple entities in Angular applications.\nIf you haven&#39;t heard about it you should <a href=\"https://medium.com/ngrx/introducing-ngrx-entity-598176456e15\">read this blog post by the NgRx team</a> or consult the <a href=\"https://ngrx.io/guide/entity\">official documentation</a>.\nBelieve me, it&#39;s the best thing that can happen to you when working with NgRx.\nThe data can be stored with normalized entity collections exactly the way it is retrieved via the API.</p>\n<p>Maybe even this is too theoretical. Let&#39;s build our own example the other way around.</p>\n<h2 id=\"clustered-data-for-books\">Clustered data for Books</h2>\n<p>Consider the following example:</p>\n<ul>\n<li>We have entities for Authors:</li>\n</ul>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">Author</span> {\n  id: <span class=\"hljs-built_in\">string</span>;\n  firstName: <span class=\"hljs-built_in\">string</span>;\n  lastName: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<ul>\n<li>We have entities for Tags:</li>\n</ul>\n<pre><code class=\"language-ts\">export interface <span class=\"hljs-keyword\">Tag</span> <span class=\"hljs-title\">{\n  id</span>: <span class=\"hljs-keyword\">string</span>;\n  name: <span class=\"hljs-keyword\">string</span>;\n}\n</code></pre>\n<ul>\n<li>We have entities for Books referencing authors and tags only via ID:</li>\n</ul>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">Book</span> {\n  id: <span class=\"hljs-built_in\">string</span>;\n  title: <span class=\"hljs-built_in\">string</span>;\n  authorIds: <span class=\"hljs-built_in\">string</span>[];\n  description: <span class=\"hljs-built_in\">string</span>;\n  tagIds: <span class=\"hljs-built_in\">string</span>[];\n}\n</code></pre>\n<p>With this we can easily set up <code>@ngrx/store</code> with three individual states using <code>@ngrx/entity</code>, each of them keeping track of its specific objects.\nHave a look at the <a href=\"https://ngrx.io/guide/entity\">official documentation</a> on how to do this.</p>\n<h2 id=\"using-parameterized-selectors\">Using parameterized selectors</h2>\n<p>Now fast-forward to the display layer; when implementing the book detail page for your application, you will most likely have multiple selectors for all the data needed to display a single book.\nWhen using <a href=\"https://ngrx.io/guide/store/selectors#using-selectors-with-props\">parameterized selectors</a>, the book selector looks like this:</p>\n<pre><code class=\"language-ts\">export const getBook = createSelector(\n  getBookEntities,\n  (<span class=\"hljs-keyword\">books, </span><span class=\"hljs-keyword\">bookId: </span>string): <span class=\"hljs-keyword\">Book </span>=&gt; <span class=\"hljs-keyword\">books[bookId]\n</span>)\n</code></pre>\n<p>You can see here that we rely on the <code>getBookEntities</code> selector as an input to this selector.\n<code>getBookEntities</code> was created with entity selectors provided by <code>@ngrx/entity</code> and it will give us a dictionary object containing all books.\nOur projector function then uses these entities and an additional parameter to look up the right book from the state.</p>\n<p>The selector can be used in the component like this:</p>\n<pre><code class=\"language-ts\">book$ = <span class=\"hljs-keyword\">this</span>.store.pipe(select(getBook, <span class=\"hljs-keyword\">this</span>.bookId));\n</code></pre>\n<p>(Note: The parameter <code>bookId</code> can come from a route parameter, be injected into the component or be a static reference.\nFor this example it doesn&#39;t really matter.\nHave a look at the later following StackBlitz examples to see how we did it.)</p>\n<p>As the <code>getBook</code> selector only provides access to IDs of authors and tags, we have to compose additional selectors for the display of these entities.\nThe one for the authors would look like this:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> getAuthorsOfBook = createSelector(\n  getBook,\n  getAuthorEntities,\n  (book, authors): Author[] =&gt;\n    book\n      ? book.authorIds.<span class=\"hljs-keyword\">map</span>(authorId =&gt; authors[authorId])\n      : []\n)\n</code></pre>\n<p>Have a look at how we used the previous selector <code>getBook</code> in the new selector.\nWhen using a parameterized selector in another selector, the new one also becomes a parameterized selector.\nFurthermore if you have multiple parameters, they get merged in combination.\nRead up on this awesome feature in the <a href=\"https://ngrx.io/guide/store/selectors#using-selectors-with-props\">official documentation</a>.</p>\n<p>The <code>getAuthorsOfBook</code> selector will be used in the component like this:</p>\n<pre><code class=\"language-ts\">authors$ = <span class=\"hljs-keyword\">this</span>.store.pipe(select(getAuthorsOfBook, <span class=\"hljs-keyword\">this</span>.bookId));\n</code></pre>\n<p>Similarly a selector to retrieve the tags of the current book has to be composed.\nIn the end we will have the following properties in our component file:</p>\n<pre><code class=\"language-ts\">book$ = <span class=\"hljs-keyword\">this</span>.store.pipe(select(getBook, <span class=\"hljs-keyword\">this</span>.bookId));\nauthors$ = <span class=\"hljs-keyword\">this</span>.store.pipe(select(getAuthorsOfBook, <span class=\"hljs-keyword\">this</span>.bookId));\ntags$ = <span class=\"hljs-keyword\">this</span>.store.pipe(select(getTagsOfBook, <span class=\"hljs-keyword\">this</span>.bookId));\n</code></pre>\n<p>And we will use them in the template like this:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book$ | async as book&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let a of (authors$ | async)&quot;</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">a.lastName</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.description</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let t of (tags$ | async)&quot;</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">t.name</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<h2 id=\"the-problem\">The Problem</h2>\n<p>You can probably see what this will lead to in the long run: Code duplication.\nEvery component displaying books will have to select the normalized data from the store and accumulate it in the template.\nNow imagine an API change.\nWith this amount of duplication it could mean that every component&#39;s typescript file as well as all Angular templates would have to be touched.\nBut how can we solve this?</p>\n<p>Abstractly speaking: Currently we retrieve the data normalized via the API (1) and put it normalized into the state (2).\nThen we use selectors (3) to retrieve the data normalized in each component and only then de-normalize it on each and every template (4) that displays it.</p>\n<p><img src=\"https://angular-schule.github.io/website-articles/2020-01-ngrx-data-views./normalization_points.svg\" alt=\"Normalization points\"></p>\n<p>It seems there are three points where we could intervene and do the de-normalization instead:</p>\n<ol>\n<li><p><strong>Retrieve the data ready for display:</strong></p>\n<p>This can only be done by changing from a simple REST based API to an API that provides access to all data with one call.\nGraphQL would be an answer, but most often this API is not provided.</p>\n</li>\n<li><p><strong>Put the data de-normalized into the store:</strong></p>\n<p>For example, if we have an HTTP service that fetches the data normalized, we use this service to build complex objects from fetched data, e.g. nested books and authors.\nThen we put this nested data into the store after fetching it from the API.\nThis obviously leads to data duplication and problems when updating the data since we have the same data at multiple places in our store.\nIt&#39;s simply not what we want.</p>\n</li>\n<li><p><strong>Select the data ready-for-display from the store:</strong></p>\n<p>This way the data is still handled in a normalized way within the store and updates can be done in an efficient way as they mirror the API.\nThis approach however needs crafting of special selectors that simplify selecting all accumulated data. – Let&#39;s build one of those!</p>\n</li>\n</ol>\n<h2 id=\"using-data-views-for-de-normalization\">Using Data-Views for De-Normalization</h2>\n<p>Considering our current example, what we really want to select from the store is the following entity:</p>\n<pre><code class=\"language-ts\">export interface BookView {\n  <span class=\"hljs-attribute\">title</span>: string;\n  <span class=\"hljs-attribute\">description</span>: string;\n  <span class=\"hljs-attribute\">authors</span>: Author[];\n  <span class=\"hljs-attribute\">tags</span>: Tag[];\n}\n</code></pre>\n<p>It contains all data that is available on the book entity as well as de-normalized data for authors and tags which we can easily access and iterate over in the template.</p>\n<p>To achieve this, we can build a new selector that implements this composition by re-using all previous mentioned selectors:</p>\n<pre><code class=\"language-ts\">export const getBookView = createSelector(\n<span class=\"hljs-built_in\">  getBook,</span>\n<span class=\"hljs-built_in\">  getAuthorsOfBook,</span>\n<span class=\"hljs-built_in\">  getTagsOfBook,</span>\n<span class=\"hljs-title\">  (book, authors, tags):</span> BookView =&gt;\n    book &amp;&amp; {\n<span class=\"hljs-title\">      title:</span> book.title,\n<span class=\"hljs-title\">      description:</span> book.description,\n<span class=\"hljs-built_in\">      authors,</span>\n<span class=\"hljs-built_in\">      tags,</span>\n    }\n)\n</code></pre>\n<p>And it will be used in the component and template like this:</p>\n<pre><code class=\"language-ts\">book$ = <span class=\"hljs-keyword\">this</span>.store.pipe(select(getBookView, <span class=\"hljs-keyword\">this</span>.bookId));\n</code></pre>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book$ | async as book&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let a of book.authors&quot;</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">a.lastName</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.description</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let t of book.tags&quot;</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">t.name</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<p>This implementation provides a good balance of advantages and disadvantages.\nWe push the de-normalization further back so that it doesn&#39;t have to be handled in components and templates every time, That way code duplication is prevented.\nAlso, the state still effectively mirrors the API and this simplifies managing and updating entities.\nThis seems to be the perfect spot!\nNormalization in the data layer also makes it quite easy to later compose selectors for specific tasks, like:</p>\n<ul>\n<li>search for books of a specific author</li>\n<li>find books with a specific tag</li>\n</ul>\n<p>The composition of selectors can however affect memoization, because composed selectors fire every time their input changes.\nIf those inputs are not correctly memoized, the resulting selector will also not be properly memoized.\nSince this is not the easiest topic to deal with, we will dig deeper into this in the next section.</p>\n<p>You can see the current behavior in the <a href=\"https://stackblitz.com/github/dhhyi/ngrx-data-views/tree/basic-example?file=src%2Fapp%2Fstore%2Fbook-view%2Findex.ts\">StackBlitz Example</a>.\nWhenever a Tag, Author or Book is updated, all Books will be subject to a view update. Not really something we are looking for...</p>\n<h2 id=\"the-new-problem-with-memoization\">The new problem with Memoization</h2>\n<blockquote>\n<p>In computing, memoization [...] is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\n<a href=\"https://en.wikipedia.org/wiki/Memoization\">[Wikipedia]</a></p>\n</blockquote>\n<p>When using NgRx Store with Angular, selectors provide data with Observable streams.\nIf data is changing in the background, the view also has to be updated.\nAs the state in NgRx is basically kept as one big structured object, every modification in reducers potentially triggers an update.\nThat&#39;s why memoization is used to prevent pushing an update onto the Observable streams, when effectively nothing has changed.\nKeeping data in selectors properly memoized is the bread and butter of optimization.\nAny selector firing unnecessarily initiates a needless and expensive view update.</p>\n<p>The ideas of the implementation are rather simple:\nEvery selector keeps track of its inputs and outputs and decides when the current state is &quot;good enough&quot; to prevent firing.\nIt can however memoize only exactly one data stream.\nSo if you potentially use a selector like <code>getSelectedBook</code> on a detail page of your application, the memoization will track changes and only trigger view updates if the data of the current book changes.\nKeep in mind that parameterized selectors, which we are currently promoting, also can only keep track of one value stream (one set of parameters) at a time.\nIf you are displaying many books on the current page in a listing, you must not reuse the same instance of that selector all over again.\nThis will nullify the effects of memoization.</p>\n<p>Digging into this, let&#39;s have a look in the <a href=\"https://github.com/ngrx/platform/blob/master/modules/store/src/selector.ts\">official sources</a> of NgRx to find out how memoization works in the <code>createSelector()</code> function.\nEvery selector is created with <code>createSelectorFactory()</code> and the argument for memoization, by default using <code>defaultMemoize()</code>, which returns a <code>MemoizedProjection</code> for every selector doing the following:</p>\n<ol>\n<li>It checks if the incoming arguments have changed. If they didn&#39;t change (and this is not the first call), the memoized result is returned.</li>\n<li>If the arguments changed (or it is the first call), the projector function is applied.</li>\n<li>If the result didn&#39;t change, the memoized result is returned. If not, the new result is memoized and returned.</li>\n</ol>\n<p>This all might sound pretty straight forward, but pay attention to the fact, that the check for change is by default an object identity check and not a check for equality.\nWith this, a selector might fire more often than you think:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">export</span> function <span class=\"hljs-title\">isEqualCheck</span><span class=\"hljs-params\">(a: any, b: any)</span>: boolean {</span>\n  <span class=\"hljs-keyword\">return</span> a === b;\n}\n</code></pre>\n<p>When updating a slice of state managed by <code>@ngrx/entity</code> the first check for input identity will always detect a change in selectors using that slice of state.\nSo the projector function is most often applied and only the result identity check can then prevent the selector from firing.</p>\n<p>Let&#39;s check our example selectors and see how we are doing:</p>\n<ul>\n<li><p><code>getBook</code>:</p>\n<p>The projector of this selector references a single value of the entities state of <code>@ngrx/entity</code>.\nUpdates to the state are handled by entity adapters and the object referenced will only change if the book with the same ID selected is updated or deleted.\nOther book updates will modify a different reference, so we are safe here.\nThe third check in <code>defaultMemoize()</code> will detect object identity for updates to other objects and thus the selector is properly memoized.</p>\n</li>\n<li><p><code>getAuthorsOfBook</code>:</p>\n<p>The fatal flaw lies within the projector of this selector:</p>\n<pre><code class=\"language-ts\">book ? book.authorIds.<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">authorId</span> =&gt;</span> authors[authorId])<span class=\"hljs-string\">` : []</span>\n</code></pre>\n<p>This is a function that will always create a new array upon every call.\nSo the third check for output identity will most certainly always fail and the selector will fire every time its input changes.\nIn this case every change to the authors state – be it related to the currently selected book or not – will trigger a change.</p>\n</li>\n<li><p>the same applies to the <code>getTagsOfBook</code> selector: every change to the tags state will trigger view update.</p>\n</li>\n<li><p>Our data view selector <code>getBookView</code> consumes all these changes and it also has a projector function that creates a new object every time it is called.\nThe issue hereby multiplies as all dependant selectors trigger changes.</p>\n</li>\n</ul>\n<p>Another thing we didn&#39;t pay attention to is the fact that our parameterized selectors share a memoization cache if they are statically instantiated.\nIf we use them multiple times on the same page or chain them in other selectors they will eventually always fire because the same selector is invoked with different parameters all the time.\nWe would have to find a way to separate the memoization caches.</p>\n<p>All in all, our resulting data view is not properly memoized and hence quite useless.</p>\n<h2 id=\"tackling-memoization\">Tackling Memoization</h2>\n<p>What we need to do to fix this is to assure that <code>getBookView</code> returns a correctly memoized result.\nWe can do this directly by adding memoization to <code>getBookView</code>, but better yet: we can just assure that the inputs of that selector only trigger a change, when they really change.\nOur goal must be to fix <code>getAuthorsOfBook</code> and <code>getTagsOfBook</code>.\nSo let&#39;s have another look at <code>defaultMemoize()</code> first:</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defaultMemoize</span>(\n  projectionFn: AnyFn,\n  <span class=\"hljs-keyword\">is</span>ArgumentsEqual = isEqualCheck,\n  isResultEqual = isEqualCheck\n): MemoizedProjection\n</code></pre>\n<p>What we can do is setting up the memoization ourselves.\nWe will now use <code>createSelectorFactory()</code> for creating the selector directly and reference <code>defaultMemoize()</code> applied with some overrides.\nAdditionally we do not create a static instance of the selector but instead supply a factory method for our parameterized selectors so each instance has its own memoization cache (recall, we will be using the selector multiple times, so we have to assure that each instance has its own cache):</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { createSelectorFactory, defaultMemoize } from <span class=\"hljs-string\">&#x27;@ngrx/store&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> const getAuthorsOfBook = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span>\n  createSelectorFactory(\n    <span class=\"hljs-function\"><span class=\"hljs-params\">projector</span> =&gt;</span> defaultMemoize(projector, <span class=\"hljs-literal\">undefined</span>, checkEqual)\n  )(\n    getBook,\n    getAuthorEntities,\n    (book, authors): Author[] =&gt;\n      book\n        ? book.authorIds.<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">authorId</span> =&gt;</span> authors[authorId])\n        : []\n)\n</code></pre>\n<p><code>createSelectorFactory()</code> expects a <code>MemoizedProjection</code> as an argument for which we can re-use <code>defaultMemoize()</code>.\nThe first argument to it is the projector function of the selector which we just tunnel through.\nThe second argument is the function for input equality check which we are not interested in changing, so we supply <code>undefined</code> to fall back onto the default value (identity check).\nThe third and last argument is the function checking the equality of the projector result.</p>\n<p>Here we want to butt in and provide a function that can detect equality instead of identity.\nWith the knowledge that only arrays are the input we could implement it ourselves:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkEqual</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> a &amp;&amp; b &amp;&amp; a.<span class=\"hljs-built_in\">length</span> === b.<span class=\"hljs-built_in\">length</span> &amp;&amp; a.every(<span class=\"hljs-function\">(<span class=\"hljs-params\">val, idx</span>) =&gt;</span> val === b[idx]);\n}\n</code></pre>\n<p>Nonetheless we can also fall back to a deep-equality check provided by one of those numerous libraries on the market or use one that is most certainly already available in our project&#39;s <code>node_modules</code>.</p>\n<p>Correspondingly we do the same to the <code>getTagsOfBook</code> selector and in succession we also fixed the <code>getBookView</code> selector.\nAll its inputs are now properly memoized and consequently the projector function creating a new view is only applied when the inputs <em>really</em> have changed.</p>\n<p>Our <code>getBookView</code> now uses the factories of parameterized selectors and looks like this:</p>\n<pre><code class=\"language-ts\">export const getBookView = () =&gt;\n  createSelector(\n    <span class=\"hljs-name\">getBook</span>,\n    getAuthorsOfBook(),\n    getTagsOfBook(),\n    (<span class=\"hljs-name\">book</span>, authors, tags): BookView =&gt;\n      book <span class=\"hljs-symbol\">&amp;&amp;</span> {\n        title: book.title,\n        description: book.description,\n        authors,\n        tags\n      }\n  )<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>And it now works as expected as you can see in the <a href=\"https://stackblitz.com/github/dhhyi/ngrx-data-views/tree/memoized-data-views?file=src%2Fapp%2Fstore%2Fbook-view%2Findex.ts\">StackBlitz Example</a>.</p>\n<blockquote>\n<p><strong>Update 2021</strong>   </p>\n<p>I found out later, that NgRx also supports overriding just the result memoization if you use <a href=\"https://ngrx.io/api/store/resultMemoize\">´resultMemoize()´</a> instead of <code>defaultMemoize()</code>.</p>\n</blockquote>\n<h2 id=\"enriched-data-views\">Enriched Data Views</h2>\n<p>All the time you might have been asking: Why are we even doing this?</p>\n<p>Let&#39;s start with some theory again: NgRx basically forces you to keep your data objects in an <a href=\"https://en.wikipedia.org/wiki/Anemic_domain_model\">Anemic Domain Model</a> which means that only pure data is kept here.\nAll management logic (helpers, modifiers, validators, ...) has to be implemented in different places.\nThe reason for NgRx forcing this is that only serializable objects can be pushed into the store.\nThe new <a href=\"https://ngrx.io/guide/store/configuration/runtime-checks\">runtime checks</a> will remind you of these practices when you enable them.\nIt is not a bad approach per se as it further enforces immutability and this – as we all now – <a href=\"https://img.sauf.ca/pictures/2016-01-22/fd232c4b1ffdc0f0ef66400bf7fa64f8.pdf\">changes everything</a>.</p>\n<p>If you are however used to having business objects around (enterprise developer?!) and you want to have at least some kind of logic on your objects, data views can be a perfect place to implement it.\nAs those objects basically spawn off the selectors, just outside of the store, you can add methods to them or even derive or elevate simple properties to unserializable objects here.</p>\n<p>Let&#39;s consider the following scenario: You want to keep the publishing date on the <code>Book</code> objects and you also want to have some accessor that tells you if the book is new, because it was published this year.\nIn the book model in the NgRx store you would have to keep the published date as a <code>number</code> because instances of the <code>Date</code> class are not serializable.\nConcerning the &quot;new&quot; property, you don&#39;t want to put it into the store at all, as it is derived from the publishing date of the book and keeping it in the store would be redundant and therefore contradicting normalization.\nAlso, you cannot add it as a method to the model because functions are not serializable either.</p>\n<p>With data views, you would just solve all this in the <code>BookView</code> interface and the corresponding selector:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Book</span> {\n  ...\n  <span class=\"hljs-attr\">published</span>: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">BookView</span> {\n  ...\n  <span class=\"hljs-attr\">published</span>: <span class=\"hljs-title class_\">Date</span>;\n  <span class=\"hljs-title function_\">isNew</span>(): <span class=\"hljs-built_in\">boolean</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">calculateNew</span> = (<span class=\"hljs-params\"><span class=\"hljs-attr\">book</span>: <span class=\"hljs-title class_\">Book</span></span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">getFullYear</span>() === <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(book.<span class=\"hljs-property\">published</span>).<span class=\"hljs-title function_\">getFullYear</span>();\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getBookView</span> = (<span class=\"hljs-params\"></span>) =&gt;\n  <span class=\"hljs-title function_\">createSelector</span>(\n    ...\n    (book, authors, tags): <span class=\"hljs-function\"><span class=\"hljs-params\">BookView</span> =&gt;</span>\n      book &amp;&amp; {\n        ...\n        <span class=\"hljs-attr\">published</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(book.<span class=\"hljs-property\">published</span>),\n        <span class=\"hljs-attr\">isNew</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">calculateNew</span>(book),\n      }\n  );\n</code></pre>\n<p>The result can be observed in the next <a href=\"https://stackblitz.com/github/dhhyi/ngrx-data-views/tree/data-views-as-business-objects?file=src%2Fapp%2Fstore%2Fbook-view%2Findex.ts&devtoolsheight=50\">StackBlitz Example</a>.\nAs you can see in the console, solving it this way leads to many calls to the &quot;new&quot; method provided by the data view.\nThe reason lies within the Angular change detection.</p>\n<h2 id=\"memoized-data-view-methods\">Memoized Data View Methods</h2>\n<p>When developing, you are composing all components living in an Angular application into a tree for rendering.\nLikewise Angular keeps a tree of corresponding change detectors for optimizing view updates.\nAll bindings in templates referencing component properties are re-evaluated in every change detector cycle.\nSo when binding a template value to a call expression like <code>book.isNew()</code>, we have to make sure that this evaluation is not too expensive.</p>\n<p>There are multiple ways of tackling this issue:</p>\n<ol>\n<li><p>Cache the results of call expressions:</p>\n<p>In this easy example you could just calculate the result once and keep it as a simple property on the <code>BookView</code> instance instead.\nEverything in the store will stay properly normalized, it is just the data view supplying derived data for easy access:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> interface BookView {\n  ...\n  isNew: <span class=\"hljs-built_in\">boolean</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> const getBookView = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span>\n  createSelector(\n    ...\n    (book, authors, tags): <span class=\"hljs-function\"><span class=\"hljs-params\">BookView</span> =&gt;</span>\n      book &amp;&amp; {\n        ...\n        isNew: calculateNew(book),\n      }\n  );\n</code></pre>\n<p>In other cases the <code>ngOnChanges()</code> in component classes could be used to cache expensive calculations to fields.\nAnd then those fields could be bound to in the templates.</p>\n</li>\n<li><p>Restricting Change Detection:</p>\n<p>By choosing <code>OnPush</code> <a href=\"https://angular.io/api/core/ChangeDetectionStrategy\">change detection</a>, the standard change detection is limited to changes to <code>@Input</code> bindings in the component and event bindings in the template.\nThis is a great way of optimizing Angular applications which use NgRx.</p>\n</li>\n<li><p>Make repeated calls inexpensive:</p>\n<p>If no other of those approaches works (like in our case) we have to follow a different path.\nWe want to memoize the result ourselves and by that assure that the expensive calculation is lazily evaluated and cached for further references.</p>\n</li>\n</ol>\n<p>One way of implementing this is by using the <code>lodash</code> helper method <a href=\"https://lodash.com/docs/#once\"><code>once()</code></a>, wrapping it around the method in the <code>getBookView</code> selector:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { once } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;lodash-es&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> const getBookView = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span>\n  createSelector(\n    ...\n    (book, authors, tags): BookView =&gt;\n      book &amp;&amp; {\n        ...\n        isNew: once(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> calculateNew(book)),\n      }\n  );\n</code></pre>\n<p>Lodash imports should always be made by tree-shakeable libraries like <a href=\"https://www.npmjs.com/package/lodash-es\"><code>lodash-es</code></a> or <a href=\"https://www.npmjs.com/package/lodash.once\"><code>lodash.X</code></a> to reduce the bundle size.\nFor the memoization of methods with parameters the helper <a href=\"https://lodash.com/docs/#memoize\"><code>memoize()</code></a> can be used in a similar fashion.</p>\n<p>The final result can be studied in the last <a href=\"https://stackblitz.com/github/dhhyi/ngrx-data-views/tree/memoized-business-objects?file=src%2Fapp%2Fstore%2Fbook-view%2Findex.ts&devtoolsheight=50\">StackBlitz Example</a>.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>We covered quite a lot here.\nIdentifying the original problem with normalized data in many enterprise scenarios, we proposed an approach of easily handling it in our front-ends with data views and NgRx.\nWe discussed de-normalization and where it actually should happen to make our projects maintainable over a long time.\nWe dug into the theory of memoization after identifying further challenges with the way we implemented de-normalization in NgRx selectors.\nAfter that we topped it all off with additional optimization to elevate our data views to something else, something our colleagues developing the server-side might identify as business objects.</p>\n<p>If you want to see all of this in a real project context, have a look at the <a href=\"https://www.intershop.com/de/progressive-web-app\">Intershop PWA</a> where these ideas were developed.\nIntershop recently <a href=\"https://www.intershop.com/en/press-release/open-source-the-intershop-progressive-web-app-is-free-for-community-development\">open sourced</a> the product at <a href=\"https://github.com/intershop/intershop-pwa\">GitHub</a>.\nFeel free to have a look at the source code and demo applications.\nA big thank you goes to <a href=\"https://twitter.com/fmalcher01\">Ferdinand Malcher</a> from Angular.Schule for guiding us and our project over the last two years, helping us build up our Angular knowledge and keeping us up to date with the latest changes of the Angular framework.</p>\n<p>I hope you had fun reading this and that I found the right approach in displaying this rather complex topic.\nAlways keep an open mind and let me remind you: if it is Open Source you are using, you can typically look behind the curtains and peek into the dirty details.\nIt helps!</p>\n","meta":{"title":"NgRx Data Views: How to de-normalize entities for large enterprise applications","author":"Danilo Hoffmann","mail":"dhhyi@aol.com","bio":"Danilo works as a Software Developer for the e-commerce company Intershop in Thuringia, located in the green heart of Germany. Just as he started working there, the decision was made to launch the development for a new storefront based on Angular. Even though he never worked with Angular before (his background is mainly Java and some C++), it turned into one of the best love stories of the current decade. Nowadays, whenever he is not working on the project, he likes spending time improving his cooking skills or chilling at local pubs while reading about psychology.","published":"2020-01-08T00:00:00.000Z","last-change":"2020-01-08T00:00:00.000Z","keywords":["Angular","RxJS","Reactive Programming","Observables","Redux","NgRx","NgRx Entities","Memoization"],"language":"en","thumbnail":"https://angular-schule.github.io/website-articles/2020-01-ngrx-data-views/data-views-header.jpg"}}
