{"slug":"2022-05-typed-forms","html":"<p>Mit Version 14 von Angular erscheint ein lang erwartetes Feature: <em>stark typisierte Formulare!</em>\nBisher waren die Datenmodelle für Reactive Forms stets lose mit <code>any</code> typisiert – das ändert sich nun.\nIn diesem Blogartikel stellen wir kurz die wichtigsten Eckpunkte vor.</p>\n<h2 id=\"untypisierte-formulare\">Untypisierte Formulare</h2>\n<p>Reactive Forms sind ein mächtiger Ansatz, um Formulare in Angular zu bauen.\nIn der Komponentenklasse bauen wir dazu ein Formularmodell aus den Bausteinen <code>FormControl</code>, <code>FormGroup</code> und <code>FormArray</code> auf.\nDieses Modell wird dann mithilfe von Direktiven mit dem Template verknüpft.</p>\n<p>Ein Formularmodell kann zum Beispiel so definiert werden:</p>\n<pre><code class=\"language-ts\">bookForm = <span class=\"hljs-keyword\">new</span> FormGroup({\n  isbn: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>),\n  title: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>),\n  author: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n});\n</code></pre>\n<p>Über das Property <code>value</code> bzw. die Methode <code>getRawValue()</code> können wir den Wert des Formulars auslesen, um damit weiterzuarbeiten.\nDas Problem: Bis Angular 13 ist dieser Wert mit <code>any</code> typisiert!</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">this</span>.bookForm.value <span class=\"hljs-comment\">// any</span>\n<span class=\"hljs-keyword\">this</span>.bookForm.getRawValue() <span class=\"hljs-comment\">// any</span>\n</code></pre>\n<p>Dadurch kann es schnell passieren, dass Fehler in den erfassten Daten erst zur Laufzeit auffallen.\nDas Angular-Team hat sich dieses Problems nun angenommen: Ab Angular 14 kann das Formularmodell mit konkreten Typen behandelt werden.</p>\n<h2 id=\"typed-forms\">Typed Forms</h2>\n<p>Seit Angular 14 verwenden alle Bausteine von Reactive Forms die korrekten Typinformationen.\nDer Typ wird anhand des Startwerts ermittelt, den wir im Konstruktor von <code>FormControl</code> angeben:</p>\n<pre><code class=\"language-ts\">new <span class=\"hljs-built_in\">FormControl</span>(&#x27;&#x27;) <span class=\"hljs-comment\">// FormControl&lt;string | null&gt;</span>\nnew <span class=\"hljs-built_in\">FormControl</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// FormControl&lt;number | null&gt;</span>\n</code></pre>\n<p>Dabei ist immer auch der Typ <code>null</code> inkludiert.\nDer Hintergrund: Controls können mit der Methode <code>reset()</code> zurückgesetzt werden.\nGibt man dabei keinen neuen Startwert an, wird der Wert standardmäßig auf <code>null</code> gesetzt.\nDamit für dieses bestehende Verhalten kein Breaking Change entsteht, ist <code>null</code> standardmäßig im Typ enthalten.</p>\n<p>In vielen Fällen wird dies nicht mit dem benötigten Datenmodell übereinstimmen. Daher können wir das Standardverhalten ändern: Bei der Initialisierung von <code>FormControl</code> setzen wir dazu die neue Option <code>nonNullable</code> und ändern so das Reset-Verhalten: Beim Zurücksetzen wird nicht <code>null</code> verwendet, sondern der ursprünglich definierte Startwert.\nDamit entfällt der Typ <code>null</code> und das <code>FormControl</code> besitzt nur noch den Typ <code>string</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> }) <span class=\"hljs-comment\">// FormControl&lt;string&gt;</span>\n</code></pre>\n<blockquote>\n<p><strong>⚠️ ACHTUNG:</strong> In der ersten Umsetzung war die Option unter dem Namen <code>initialValueIsDefault</code> verfügbar. Mit dem finalen Release von Angular 14.0.0 wurde der Name in <code>nonNullable</code> umbenannt.</p>\n</blockquote>\n<p>Üblicherweise werden im zweiten Argument von <code>FormControl</code> die Validatoren notiert.\nMöchte man die neue Option <em>und</em> Validatoren setzen, müssen diese mit in das Optionsobjekt aufgenommen werden. Das gilt auch für asynchrone Validatoren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, {\n  validators: [\n    Validators.<span class=\"hljs-keyword\">required</span>,\n    Validators.maxLength(<span class=\"hljs-number\">15</span>)\n  ],\n  asyncValidators: [checkISBNValidator],\n  nonNullable: <span class=\"hljs-keyword\">true</span>\n})\n</code></pre>\n<p>Falls der Typ eines einzelnen FormControls nicht automatisch inferiert werden kann, weil der Startwert auf <code>null</code> gesetzt wird, können wir mithilfe des generischen Typparameters nachhelfen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">new</span> FormControl&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-keyword\">null</span>&gt;(<span class=\"hljs-keyword\">null</span>) // FormControl&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-keyword\">null</span>&gt;\n</code></pre>\n<p>Es ist zu erwarten, dass die Option <code>nonNullable</code> in einer späteren Version von Angular per Default auf <code>true</code> gesetzt wird, sodass für alle Controls standardmäßig der Startwert zum Reset verwendet wird (und nicht <code>null</code>).\nDa es sich dabei allerdings um einen Breaking Change handelt, wird das Angular-Team eine solche Änderung mit großer Vorsicht und einer Übergangsfrist durchführen müssen.</p>\n<p>Entwickeln Sie ein Formular &quot;auf der grünen Wiese&quot;, empfehlen wir Ihnen, die Option <code>nonNullable</code> für jedes Control auf <code>true</code> zu setzen.\nDas vereinfacht die Arbeit mit den erzeugten Daten, weil die Typen den tatsächlichen Eingabewert widerspiegeln. Ein normales Input-Feld erzeugt zum Beispiel stets einen leeren String bzw. einen String mit Werten. Der Wert <code>null</code> beschäftigt uns hier tatsächlich nur beim Zurücksetzen des Formulars.</p>\n<h2 id=\"formgroup-und-formarray\">FormGroup und FormArray</h2>\n<p>Kombinieren wir mehrere Controls in einer <code>FormGroup</code> oder in einem <code>FormArray</code>, wird der zusammengesetzte Typ automatisch inferiert.\nDie Methode <code>getRawValue()</code> liefert also ein Objekt mit dem erwarteten Typ:</p>\n<pre><code class=\"language-ts\">bookForm = <span class=\"hljs-keyword\">new</span> FormGroup({\n  isbn: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, {\n    nonNullable: <span class=\"hljs-literal\">true</span>\n  }),\n  title: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>),\n  author: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n});\n\n<span class=\"hljs-comment\">// Typ von bookForm.getRawValue()</span>\n{\n  isbn: <span class=\"hljs-built_in\">string</span>;\n  title: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-literal\">null</span>;\n  author: <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-literal\">null</span>;\n}\n</code></pre>\n<p>Hier ist eine Einschränkung zu beachten: Das Property <code>value</code> und das Observable <code>valueChanges</code> geben nur die Werte der <em>aktivierten</em> Controls aus. Wurde ein Control über <code>disable()</code> deaktiviert, so wird es komplett ignoriert – sogar die Validatoren werden nicht mehr berücksichtigt.\nDa das Typsystem nicht bestimmen kann, ob ein Control aktiviert ist oder nicht, ist der Typ hier stets mit <code>Partial</code> definiert.\nDas bedeutet, dass alle Felder optional sind, also auch <code>undefined</code> beinhalten können:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Typ von bookForm.value</span>\nPartial&lt;{\n  isbn: <span class=\"hljs-keyword\">string</span>;\n  <span class=\"hljs-built_in\">title</span>: <span class=\"hljs-keyword\">string</span> | <span class=\"hljs-built_in\">null</span>;\n  author: <span class=\"hljs-keyword\">string</span> | <span class=\"hljs-built_in\">null</span>;\n}&gt;\n\n<span class=\"hljs-comment\">// das entspricht:</span>\n{\n  isbn?: <span class=\"hljs-keyword\">string</span>;\n  titl?: <span class=\"hljs-keyword\">string</span> | <span class=\"hljs-built_in\">null</span>;\n  author?: <span class=\"hljs-keyword\">string</span> | <span class=\"hljs-built_in\">null</span>;\n}\n</code></pre>\n<p>Es ist übrigens empfehlenswert, die <code>FormGroup</code> immer direkt bei der Deklaration des Komponenten-Propertys zu initialisieren.\nAnsonsten müssten wir den vollständigen Typ manuell hinter dem Property notieren.</p>\n<h2 id=\"controls-abrufen-mit-get\">Controls abrufen mit <code>.get()</code></h2>\n<p>Mit der Methode <code>get()</code> können wir in eine <code>FormGroup</code> &quot;hinabsteigen&quot; und ein Control abrufen.\nDas funktioniert selbst mit zusammengesetzten Pfaden hervorragend – <em>it&#39;s magic!</em></p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> form = <span class=\"hljs-keyword\">new</span> FormGroup({\n  title: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, { nonNullable: <span class=\"hljs-literal\">true</span> }),\n  authors: <span class=\"hljs-keyword\">new</span> FormArray([\n    <span class=\"hljs-keyword\">new</span> FormGroup({\n      firstname: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>),\n      lastname: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>),\n    })\n  ])\n});\n</code></pre>\n<pre><code class=\"language-ts\">form.get(<span class=\"hljs-string\">&#x27;title&#x27;</span>)\n// AbstractControl&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">string</span>&gt; | <span class=\"hljs-literal\">null</span>\n\nform.get(<span class=\"hljs-string\">&#x27;authors.0.firstname&#x27;</span>)\n// AbstractControl&lt;<span class=\"hljs-built_in\">string</span> | <span class=\"hljs-literal\">null</span>, <span class=\"hljs-built_in\">string</span> | <span class=\"hljs-literal\">null</span>&gt; | <span class=\"hljs-literal\">null</span>\n</code></pre>\n<h2 id=\"nonnullableformbuilder-verwenden\">NonNullableFormBuilder verwenden</h2>\n<p>Wenn wir in einem komplexen Formular jedes Control mit der Option <code>nonNullable</code> versehen, wächst das Formularmodell stark an und wird unübersichtlich.</p>\n<p>Um ohne viel Tipparbeit ein <code>FormControl</code> zu erzeugen, können wir deshalb den <code>FormBuilder</code> nutzen.\nDiese Klasse bietet verschiedene Methoden an, um Formularmodelle schnell und kurz zu erzeugen.\nAb Angular 14 existiert eine zweite Variante: der <code>NonNullableFormBuilder</code>.</p>\n<p>Damit können wir typisierte Controls erzeugen, in denen die Option <code>nonNullable</code> sofort auf <code>true</code> gesetzt ist.\nSelbstverständlich können wir den <code>FormBuilder</code> und die selbst erzeugten Klasseninstanzen in unserem Formularmodell kombinieren:</p>\n<pre><code class=\"language-ts\">import <span class=\"hljs-comment\">{ NonNullableFormBuilder }</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span><span class=\"hljs-punctuation\">;</span>\n\nbookForm = <span class=\"hljs-keyword\">new</span> FormGroup(<span class=\"hljs-comment\">{\n  isbn: this.nnfb.control(&#x27;&#x27;, [\n    Validators.required,\n    Validators.maxLength(15)\n  ]),\n  title: this.nnfb.control(&#x27;&#x27;),\n  author: this.nnfb.control(&#x27;&#x27;)\n}</span>)<span class=\"hljs-punctuation\">;</span>\n\n<span class=\"hljs-keyword\">constructor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">private</span> nnfb: NonNullableFormBuilder)</span> <span class=\"hljs-comment\">{}</span>\n</code></pre>\n<h2 id=\"grenzen-der-typisierung\">Grenzen der Typisierung</h2>\n<p>Grundsätzlich gilt: In TypeScript können nur die Dinge typisiert werden, die zur Kompilierungszeit sicher bekannt sind.\nWenn wir ein dynamisches Formular entwickeln, dessen Struktur zur Laufzeit geändert wird, können wir uns nicht auf die Typisierung verlassen.</p>\n<p>Die <code>FormGroup</code> ist daher in der neuen Variante strikt typisiert.\nWir können zur Laufzeit keine weiteren Controls hinzufügen oder durch andere Controls mit einem anderen Typ ersetzen:</p>\n<pre><code class=\"language-ts\">bookForm = <span class=\"hljs-keyword\">new</span> FormGroup({\n  isbn: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n});\n\nbookForm.addControl(<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>)) <span class=\"hljs-comment\">// ❌ FEHLER!</span>\nbookForm.setControl(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>, <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-number\">5</span>)) <span class=\"hljs-comment\">// ❌ FEHLER!</span>\n</code></pre>\n<p>In diesem Fall müssen wir auf die untypisierte Variante <code>UntypedFormControl</code> (siehe unten) oder auf den neuen <code>FormRecord</code> zurückgreifen.</p>\n<h2 id=\"der-neue-baustein-formrecord\">Der neue Baustein <code>FormRecord</code></h2>\n<p>Um das Laufzeitproblem mit <code>addControl()</code> in einer <code>FormGroup</code> zu lösen, wurde ein neuer Baustein eingeführt: <code>FormRecord</code>.\nPrinzipiell funktioniert dieses Objekt wie eine <code>FormGroup</code>, alle darüber eingebundenen Controls müssen aber denselben Typ besitzen.\nDas ist besonders dann sinnvoll, wenn Controls zur Laufzeit hinzugefügt oder entfernt werden sollen:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> checkboxGroup = <span class=\"hljs-keyword\">new</span> FormRecord({\n  acceptAGB: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-literal\">false</span>),\n  acceptDSGVO: <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-literal\">false</span>)\n});\n\ncheckboxGroup.addControl(<span class=\"hljs-string\">&#x27;subscribeNewsletter&#x27;</span>, <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-literal\">false</span>)); <span class=\"hljs-comment\">// ✅</span>\n</code></pre>\n<p>Bei der Typisierung des Values kommt TypeScript allerdings wieder an seine Grenzen: Die Namen/Keys der Felder können nicht statisch ermittelt werden und sind deshalb generisch mit <code>string</code> definiert:</p>\n<pre><code class=\"language-ts\">{ [key: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">bool</span>ean | <span class=\"hljs-literal\">null</span>; }\n</code></pre>\n<p>Rufen wir also z. B. mit <code>get()</code> ein Control ab, kann der eingegebene Key nicht von TypeScript geprüft werden.</p>\n<h2 id=\"migration\">Migration</h2>\n<p>Der Umstieg mit einem existierenden Formular auf die neue typisierte Variante ist unter Umständen nicht ganz trivial.\nDeshalb werden alle Bausteine von Reactive Forms auch weiterhin mit ihrer alten, untypisierten Schnittstelle angeboten.</p>\n<p>Wenn wir die Anwendung mithilfe von <code>ng update</code> auf Angular 14 migrieren, werden die Klassennamen automatisch ersetzt:</p>\n<ul>\n<li><code>FormControl</code> =&gt; <code>UntypedFormControl</code></li>\n<li><code>FormGroup</code> =&gt; <code>UntypedFormGroup</code></li>\n<li><code>FormArray</code> =&gt; <code>UntypedFormArray</code></li>\n</ul>\n<p>So kann die Migration auf typisierte Formulare schrittweise durchgeführt werden.\nKomplexe Formulare mit dynamischen Strukturen können ggf. sogar gar nicht von der Typisierung profitieren und müssen mit den <code>Untyped</code>-Varianten bestehen bleiben.</p>\n<p>Möchten Sie die einzelne Migration der Controls manuell anstoßen, können Sie den folgenden Befehl nutzen:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">update</span> <span class=\"hljs-variable\">@angular</span><span class=\"hljs-operator\">/</span>core <span class=\"hljs-comment\">--migrate-only=migration-v14-typed-forms</span>\n</code></pre>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Das Angular-Team hat einige lang ersehnte Wünsche der Community berücksichtigt und hat viel Zeit und Energie in neue Features investiert.\nDie neuen typisierten Bausteine für Reactive Forms bringen ein neues Level an Typsicherheit in die Anwendung.\nAufwendige Prüfungen der Formularwerte zur Laufzeit können damit entfallen, und der Komfort bei der Entwicklung steigt.\nWir freuen uns schon auf den baldigen Einsatz von Angular 14, bei dem die stark typisierten Formulare endlich bereitstehen!</p>\n<hr>\n\n\n<p><small><strong>Titelbild:</strong> Photo by <a href=\"https://unsplash.com/@unstable_affliction\">Ivan Bandura</a> on <a href=\"https://unsplash.com/s/photos/rice-field\">Unsplash</a> (edited)\n  </small></p>\n","meta":{"title":"Typisierte Reactive Forms – neu ab Angular 14","author":"Ferdinand Malcher","mail":"mail@fmalcher.de","published":"2022-05-19T00:00:00.000Z","last-change":"2022-05-29T00:00:00.000Z","keywords":["Angular","Angular 14","Reactive Forms","Typed Forms"],"language":"de","header":{"url":"typedforms.jpg","width":2000,"height":1055}}}
