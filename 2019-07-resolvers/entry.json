{"slug":"2019-07-resolvers","html":"<p>We need to talk about Angular route resolvers.\nResolvers are services used by the Angular router to retrieve (asynchronous) data for us during navigation.\nThe resolved data is available synchronously when the component starts.</p>\n<p>If you never heard about resolvers, you are fine!\nHave you ever used them? This is okay, but you should probably avoid this.</p>\n<p>In this post I want to highlight why resolvers are not the perfect means for resolving async data.\nI want to point out how there is always a way around them and how Reactive Programming in Angular can brighten up your day.\nIn fact, this blog post is sort of a speech of praise for Reactive Programming in Angular.</p>\n<h2 id=\"the-anatomy-of-resolvers\">The anatomy of resolvers</h2>\n<p>Before we start, let&#39;s talk about what resolvers are and how we implement them.\nIf you already used them before, you can probably skip this intro.</p>\n<p>Technically speaking, a resolver is an Angular service that encapsulates async operations.\nThe Angular router utilizes this service to resolve those operations during navigation and make the data available for the routed components.\nA resolver always follows a specific structure: it&#39;s a class with a <code>resolve()</code> method.\nThis is the place where we define all necessary operations and return the result – usually as an Observable.</p>\n<p>The <code>resolve()</code> method will be called by the router with some arguments, from which we can get information about the route that will be navigated to.\nThe following example shows a resolver that loads a book by a specific key that comes from a route parameter (in our case a unique &quot;International Standard Book Number&quot; (ISBN)).</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { Injectable } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from <span class=\"hljs-string\">&#x27;@angular/router&#x27;</span>;\n\n<span class=\"hljs-meta\">@Injectable({ providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span> })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookResolverService</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">Resolve</span>&lt;<span class=\"hljs-type\">Book</span>&gt; {\n\n<span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> bs: BookStoreService) { }\n\n  resolve(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable&lt;Book&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.bs.getOne(route.paramMap.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>));\n  }\n}\n</code></pre>\n<p>A service alone is not enough – we also need someone to call it.\nSince the resolver should be invoked by the router, the right place to insert it is our route configurations.\nWe provide an object here with at least one resolver:</p>\n<pre><code class=\"language-ts\">{\n  <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;mypath&#x27;</span>,\n  component: MyComponent,\n  resolve: {\n    book: BookResolverService\n  }\n}\n</code></pre>\n<p>When this route is being requested, the router automatically invokes the <code>resolve()</code> method of the resolver, subscribes to the Observable and makes the resulting data available for the component synchronously.\nWithin the component, we can use the <code>ActivatedRoute</code> service to get access to the data:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> route: ActivatedRoute) { }\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.book = <span class=\"hljs-keyword\">this</span>.route.snapshot.<span class=\"hljs-keyword\">data</span>.book;\n  }\n}\n</code></pre>\n<h2 id=\"the-user-experience-problem-with-resolvers\">The User Experience problem with resolvers</h2>\n<p>Resolvers are very straightforward to use, since they are just services that are automatically being called by the router.\nHowever, we need to keep in mind an important detail:\nThe router calls the resolver when the route is being requested – and then <em>waits</em> for the data to be resolved before the route is actually being activated.</p>\n<p>Now imagine a long running HTTP request.\nAfter clicking a link in our application, the HTTP request starts.\nThe routing will not be finished before the HTTP response comes back.\nThus, if the HTTP takes 5 seconds, it will also take 5 seconds for the routing to complete.\nIf you are like me, you will have hit the button another 3 times within that time. 😉</p>\n<p>This behavior completely breaks the idea of a Single-Page Application:\nAn SPA should always react fast and load the necessary data asynchronously at runtime.\nWith the behavior described – click, wait, continue – we are back to the user experience of a classical server-only rendered page like 15 years ago.\nNot good.\nAnd here we are with the problematic UX resolvers bring us.\nTry this out in the demo!</p>\n<iframe style=\"width:100%; height: 25em\" style=\"Stackblitz-Demo\" src=\"https://stackblitz.com/edit/angular-resolver-long?ctl=1&embed=1&file=src/app/app.component.ts&hideExplorer=1\"></iframe>\n\n<p>To make things clearer let&#39;s also take a look at a time diagram.\nThe red bracket marks the time between navigation start and end.\nYou can clearly see that the HTTP request blocks the navigation:</p>\n<p><img src=\"https://angular-schule.github.io/website-articles/2019-07-resolvers/timeline-resolver.png\" alt=\"Timeline for routing with a resolver that performs a long-running HTTP request\"></p>\n<p>What we rather want to do is to show the requested page <em>immediately</em> after the click, but without the data.\nFinally, when the data is available, we render the complete page.\nResolvers are not the right means for this.\nBut maybe we can think of another approach?</p>\n<h2 id=\"a-life-without-resolvers-observables-everywhere\">A life without resolvers: Observables everywhere</h2>\n<p>The solution I want to point out here is pragmatic, but goes back to the roots: <strong>Don&#39;t use resolvers.</strong>\nInstead, you can go the &quot;normal&quot; way without any real friction.\nThere is nothing wrong with handling Observables within components.\nAngular is a reactive framework and highly encourages you to work with reactive streams wherever suitable.</p>\n<p>Thus, the best way of doing is to make Observables available from your service and subscribe to them in your component:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-attr\">books</span>: <span class=\"hljs-title class_\">Book</span>[];\n  \n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">bs</span>: <span class=\"hljs-title class_\">BookStoreService</span></span>) { }\n\n  <span class=\"hljs-title function_\">ngOnInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getAll</span>()\n      .<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">books</span> =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books</span> = books);\n  }\n}\n</code></pre>\n<p>... or, even better, use the <code>AsyncPipe</code> to resolve the data directly within the template, so you don&#39;t need to care about subscription management in the component at all:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-attr\">books$</span>: <span class=\"hljs-title class_\">Observable</span>&lt;<span class=\"hljs-title class_\">Book</span>[]&gt;;\n  \n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">bs</span>: <span class=\"hljs-title class_\">BookStoreService</span></span>) { }\n\n  <span class=\"hljs-title function_\">ngOnInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">books$</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getAll</span>();\n  }\n}\n</code></pre>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let b of books$ | async&quot;</span>&gt;</span>\n  </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\">\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n</code></pre>\n<h2 id=\"the-power-of-observables\">The power of Observables</h2>\n<p>I want to emphasize the key point once more:\nWhen using resolvers, the route will be loaded <strong>after</strong> the asynchronous data from the resolver has been retrieved, or in other words: The router will wait for the resolver to finish.</p>\n<p>This leads to the more or less lucky situation that we have all the data synchronously available at the runtime of the component.\nAnd as you well know: Working with synchronous data is way easier than fiddling around with async stuff.\nYou don&#39;t need to handle Observables and you can just work with the data as intended.\nIf you feel this way, please always keep one question in mind: <strong>Why do I need this? Is the UX flaw (as described above) really worth the &quot;easier&quot; code?</strong></p>\n<p>At first sight, reactive streams seem to be overly complicated – in fact this was my initial feeling when I first dealt with RxJS a few years back.\nObservables are the &quot;final enemy&quot; for many people starting with Angular.\nAnd indeed: to understand reactive programming you need a little change of thinking: Embrace functional and declarative programming, say goodbye to the commonly known imperative way.\nIt needs a lot of practice and it is perfectly fine if you still struggle with Observables and all the operators.\nBut once you&#39;re there you will see that Angular itself is a highly reactive framework.\nEverything that happens somewhere can be interpreted as a stream of events or data – or even more abstract: a set of values.\nAnd thinking of everything as a stream makes it easier to migrate to some sort of reactive state management later, like the popular NgRx.</p>\n<p>What is more, sometimes it is impossible to avoid Observables in Angular.\nImagine, you want to retrieve a route parameter that changes during the runtime of a component – you need <code>ActivatedRoute.paramMap</code> for that, which is an Observable.\nIf you want to react to changes in form values, you need to use <code>FormGroup.valueChanges</code>.\nAnd there are a lot more! Even the <code>EventEmitter</code> that we use for component outputs is an Observable internally.\nDon&#39;t be scared of Observables!</p>\n<h3 id=\"observables-in-the-wild-an-example\">Observables in the wild: An example</h3>\n<p>To point out how Observables cross our way in the daily dev life, I want to get back to the example from above.\nInstead of retrieving a list of books, we now want to get one specific book whose ISBN comes from a route parameter.</p>\n<p>We use the <code>ActivatedRoute</code> service as usual and get a stream of changing route params.\nInstead of subscribing to that observable (we should avoid that anyway and always use the <code>AsyncPipe</code>), we transform the data stream even further.\nFor every ISBN that changes in the route, we want to retrieve the corresponding book from the API.\nWe can use the <code>switchMap()</code> operator here and transform each ISBN to the retrieved book.\nThus, we get a stream of single books which we can simply display in the template.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  <span class=\"hljs-attr\">book$</span>: <span class=\"hljs-title class_\">Observable</span>&lt;<span class=\"hljs-title class_\">Book</span>&gt;;\n  \n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">bs</span>: <span class=\"hljs-title class_\">BookStoreService</span>, <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">route</span>: <span class=\"hljs-title class_\">ActivatedRoute</span></span>) { }\n\n  <span class=\"hljs-title function_\">ngOnInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">book$</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">route</span>.<span class=\"hljs-title function_\">paramMap</span>(\n      <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">params</span> =&gt;</span> params.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;isbn&#x27;</span>)),\n      <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">isbn</span> =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bs</span>.<span class=\"hljs-title function_\">getOne</span>(isbn))\n    );\n  }\n}\n</code></pre>\n<blockquote>\n<p>Note that we used the <code>switchMap()</code> operator intentionally here: When the route changes, we want to cancel the running request. However, please do not use <code>switchMap()</code> blindly but also consider its siblings <code>concatMap()</code>, <code>mergeMap()</code> and <code>exhaustMap()</code>.</p>\n</blockquote>\n<h2 id=\"child-components-to-the-rescue-container-and-presentational-components\">Child components to the rescue: Container and Presentational Components</h2>\n<p>Observables are great, but even when we deal a lot with Observables in our components, that doesn&#39;t mean we can&#39;t have any data synchronously available  without a callback.\nThis is possible with a closer look at the component tree: When we put a child component into our template and pass data to it via property binding, this data is available synchronously after the first <code>ngOnChanges()</code> of the child component – which means we can directly access it within <code>ngOnInit()</code>.\nComponent communication is the key!\nIf we think this even further, we can separate our components by their role and divide them into <strong>Containers and Presentational Components</strong>.\nLet&#39;s talk about this pattern!</p>\n<p>The most pragmatic of those two component roles is the <strong>Presentational Component</strong>.\nIt is only concerned with displaying data and capturing things from the user through the UI, like events and data.\nPresentationals are completely &quot;dumb&quot; in the sense of that they have no external dependencies.\nWhat is more, they neither care about where the data comes from nor what happens to the events they push to their parent.\nAll communication is done via Inputs and Output and usually there are no services involved.</p>\n<p>A presentational component never comes alone, but will always be orchestrated by another component – either another presentational or a container.\n<strong>Containers</strong> are components as well, but with very little own markup.\nInstead, containers resemble the interface to the rest of the application: They communicate with services, the router or the NgRx store and thus, potentially perform side-effects.\nThey pass data to presentationals (via property binding) and receive events from them (via event binding) which they can forward to the application.\nContainers are sometimes referred to as &quot;smart components&quot; (as opposed to &quot;dumb&quot;), because they have the knowledge of the actual wiring.\nPresentationals are easily reusable, while containers often are very specific for a certain page or application slice.</p>\n<p>This pattern is very generic and not made specifically for Angular – instead, it has evolved in the React community first.\nYou can read more about the ideas in a <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">blog post by Dan Abramov</a>.</p>\n<p>My advice: Take the Container and Presentational pattern as a <em>guideline</em>!\nBasically, it is all about being aware of what a component&#39;s role is: Does it <strong>display data</strong> or does it do  the <strong>data handling</strong>?\nTry not to mix those concerns.</p>\n<p>Some people suggest separating Containers and Presentational Components in separate folders in the file system.\nYou can do this, but in my opinion, it&#39;s already a step forward if you are <em>aware</em> of what a component does.\nA component should always be as &quot;dumb&quot; as possible and as &quot;smart&quot; as necessary.\nThus, you should strive to create a lot of dumb components, as they are easily testable, interchangable and reusable.</p>\n<h2 id=\"why-all-the-theory-child-components-in-action\">Why all the theory? Child components in action</h2>\n<p>After clearing up the idea of component roles, let&#39;s get back to the problem point: Resolvers bring data to the component <em>synchronously</em>, while Observables always need a subscribe callback and are potentially asynchronous, especially with HTTP.</p>\n<p>If we follow the Containers and Presentationals pattern, we always build a tree of nested components.\nThe topmost container will retrieve some data through a service.\nAs soon as the data is available, it will render a child component and pass the data to it via property binding.\nThat means, at runtime of the child component, the data is available <em>synchronously</em> – even if it originally comes from an async data source!\nThe key point is to not render the child before the data has been retrieved.</p>\n<p>With this idea in mind we can update the timeline from above.\nThe red bracket (that looks like a <code>H</code>)shows the time between navigation start and end again.</p>\n<p><img src=\"https://angular-schule.github.io/website-articles/2019-07-resolvers/timeline-normal.png\" alt=\"Timeline for routing without resolvers\"></p>\n<p>You can clearly see that the time between click and routing is literally zero now – the routing start and end happen directly after each other, without any delay.\nWe still need to wait for the HTTP request to complete, but the routed component is already visible and we can show some meaningful content to the user – instead of letting them wait without any feedback.\n<a href=\"https://blog.angularindepth.com/https-medium-com-thomasburleson-animated-ghosts-bfc045a51fba\">Ghost elements</a> can help here to indicate that something is in progress.</p>\n<p>Though it sounds a bit complicated at first glance, the idea described is relatively easy to implement, as it just makes use of standard Angular concepts.\nFirst, we use the fabulous <code>AsyncPipe</code> to resolve the Observable in our container component.\nWe then pass it to a presentational component which we don&#39;t render before the Observable emitted some data – using <code>ngIf</code>!\nAt runtime of the child component, the data will be synchronously available in its <code>ngOnInit()</code>. That&#39;s cool!</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;book$ | async as book&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-book-details</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;book&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span>\n</code></pre>\n<p>The component <code>&lt;my-book-details&gt;</code> is a simple presentational component that just displays one book.\nHowever, we can extend this idea to whatever complexity we need.</p>\n<h2 id=\"resolving-multiple-streams\">Resolving multiple streams</h2>\n<p>In the previous example we resolved exactly one Observable using the <code>AsyncPipe</code>.\nBut what happens when it comes to multiple data sources?\nIf we used multiple resolvers, the router would wait for all of them to finish so that multiple data sets would be available for the component.</p>\n<p>A solution without resolvers is a bit more complex but not impossible.\nWe can use the exact same syntax, but put together multiple template expressions in an object:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;</span></span></span><span class=\"hljs-template-variable\">{\n  book: book$ | async,\n  user: user$ | async\n}</span><span class=\"language-xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\"> as data&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-book-details</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;data.book&quot;</span> [<span class=\"hljs-attr\">user</span>]=<span class=\"hljs-string\">&quot;data.user&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span></span>\n</code></pre>\n<p>However, this solution is not complete... Do you spot the problematic point?\n<code>ngIf</code> always evaluates an object as truthy, so the child component will always be displayed.\nWe could avoid this with an additional <code>ngIf</code> on the child component element like this:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;</span></span></span><span class=\"hljs-template-variable\">{\n  book: book$ | async,\n  user: user$ | async\n}</span><span class=\"language-xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\"> as data&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-book-details</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;data.book &amp;&amp; data.user&quot;</span> [<span class=\"hljs-attr\">book</span>]=<span class=\"hljs-string\">&quot;data.book&quot;</span> [<span class=\"hljs-attr\">user</span>]=<span class=\"hljs-string\">&quot;data.user&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span></span>\n</code></pre>\n<p>This is quite verbose, though, and puts too much logic into the template.\nA better approach therefore would be to combine the different Observable streams to one single stream <em>in the component class</em> using <code>combineLatest</code>.\nWe then can use the <code>ngIf</code> way as usual and subscribe to <em>one</em> Observable only.</p>\n<pre><code class=\"language-ts\">this.viewModel$ = combineLatest([book$, user$]).pipe(\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">[book, user]</span>) =&gt;</span> ({ book, user }))\n);\n</code></pre>\n<pre><code class=\"language-html\">&lt;ng-container *ngIf<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;viewModel$ | async as data&quot;</span>&gt;\n  &lt;my-book-details [book]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;data.book&quot;</span> [user]<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&quot;data.user&quot;</span>&gt;\n&lt;/ng-container&gt;\n</code></pre>\n<p>This whole topic of how we can resolve multiple Observables in a component is already worth a whole blog post.\nThere has been a <a href=\"https://twitter.com/Michael_Hladky/status/1154022958802919425\">discussion on Twitter</a> recently about how to do this properly and how a suitable syntax should be formed.</p>\n<h2 id=\"so-far-so-good-but-why-resolvers\">So far so good... But why resolvers?</h2>\n<p>This blog post took a little turn!\nYou can see that there is always a way to avoid resolvers.\nLeveraging reactive programming in Angular opens the door to a handful of patterns for Observable handling.</p>\n<p>But what about resolvers then?\nYou are right if you wonder what they are actually be good for.\nIt&#39;s not easy to find a valid use case that beats the reactive approach.\nHowever, after some discussions we came up with a potentially valid one – <strong>for academic purpose only!</strong> 😇 </p>\n<p><strong>Using a resolver is fine when the data is available instantly.</strong>\nSo think about data we need at many places in our application, that should be available once the component starts and that doesn&#39;t take much time to load: Configuration objects!\nI want to outline this specific idea with an example.\nFirst, we need a service that retrieves config data from a server via HTTP:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span> })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConfigService</span> {\n\n  getConfig(): Observable&lt;AppConfig&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.http.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-comment\">/* ... */</span>);\n  }\n}\n</code></pre>\n<p>Of course, this HTTP request takes some time!\nWe don&#39;t want to perform the request on every route change, but only once, when the application starts.\nTo do so, we can use a caching mechanism by RxJS: the <code>shareReplay()</code> operator.\nIt subscribes to the source (the HTTP request) only once and multicasts the response to all subscribers.\nIt also buffers the response and replays is to future subscribers.</p>\n<p>That means, whenever we subscribe to the resulting Observable, we either perform a HTTP request and get a fresh config object from the server – or we get the cached one.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span> })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConfigService</span> {\n\n  config$ = <span class=\"hljs-keyword\">this</span>.getConfig().pipe(\n    shareReplay(<span class=\"hljs-number\">1</span>)\n  );\n\n  <span class=\"hljs-keyword\">private</span> getConfig(): Observable&lt;AppConfig&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.http.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-comment\">/* ... */</span>);\n  }\n}\n</code></pre>\n<p>The corresponding resolver is relatively easy to implement since it just returns the <code>config$</code> Observable from the service:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ providedIn: <span class=\"hljs-string\">&#x27;root&#x27;</span> })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConfigResolverService</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">Resolve</span>&lt;<span class=\"hljs-type\">AppConfig</span>&gt; {\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-keyword\">private</span> cs: ConfigService) { }\n\n  resolve(): Observable&lt;AppConfig&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.cs.config$;\n  }\n}\n</code></pre>\n<p>All routes that use this resolver will now have the config object available in their route data.\nWhen loading the first route, the HTTP request will be performed, but only once for the lifetime of the application.</p>\n<p>Of course, this doesn&#39;t come without caveats:\nSince resolvers are used by the router, the route data can only be accessed by routed components and not by the <code>AppComponent</code>.\nAnd if we take a closer look, we can see: We could just inject the <code>ConfigService</code> into any component and use the <code>config$</code> Observable directly.\nSo no actual need for resolvers here? 😇</p>\n<p>You can play around with this example in a StackBlitz project:</p>\n<iframe style=\"width:100%; height: 25em\" title=\"Stackblitz-Demo\" src=\"https://stackblitz.com/edit/angular-resolver-config?ctl=1&embed=1&file=src/app/config.service.ts\"></iframe>\n\n\n<h2 id=\"a-word-on-resolvers-summary\">A word on resolvers: Summary</h2>\n<p>Resolvers are cool, but the use cases are very rare.\nWhen it comes to retrieving async data via resolvers, like HTTP requests, the User Experience suffers a lot: Resolvers wait for the async tasks to finish, before the routing continues.\nThat means, you should only use resolvers for operations that are predictably fast – so your users don&#39;t need to wait.\nHowever, with the ideas of Reactive Programming, we can apply a variety of reactive patterns to our code that make resolvers superfluous.\nObservables are powerful and you should use that power!\nAn Observable can easily be resolved directly within the component using the <code>AsyncPipe</code>.\nThat&#39;s also possible with multiple Observables, by combining them into one single stream of values.\nIf you still need the data synchronously and without Observables, you can use child components and pass the values to them via property bindings.</p>\n<p>You can see that there is always a way around resolvers.\nIf you have resolvers in your code base and it works well – great!\nIf you think about introducing resolvers, please also evaluate a reactive approach – because Reactive Programming is a <em>lot</em> of fun! 😍</p>\n<hr>\n\n<p>Special thanks to <strong>Johannes Hoppe</strong> for the technical review and to <strong>Rhianna Masson</strong> for the native language review!</p>\n<p><small><strong>Header image:</strong> Photo by Yuting Gao from <a href=\"https://www.pexels.com/photo/silhouette-of-two-person-standing-during-nighttime-1567069/\">Pexels</a>, modified\n</small></p>\n","meta":{"title":"A word on Angular route resolvers – and a praise for Reactive Programming","author":"Ferdinand Malcher","mail":"mail@fmalcher.de","published":"2019-07-29T00:00:00.000Z","last-change":"2019-07-29T00:00:00.000Z","keywords":["Angular","Router","Resolver","Data Loading","Data Provider","RxJS","Reactive Programming","Observables"],"language":"en","header":{"url":"resolvers-header.jpg","width":1512,"height":567},"hidden":false}}
