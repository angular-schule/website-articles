{"slug":"2018-06-5-useful-effects-without-actions","html":"<p><strong>In this article we will discuss how we can leverage the power of Effects in NgRx. We will use observable streams other than the usual action stream to build some powerful and neat effects.</strong></p>\n<hr>\n\n<h2 id=\"effects-effects-effects\">Effects, effects, effects</h2>\n<p>When working with the <a href=\"https://github.com/ngrx/platform\">ngrx/store library</a> you might be familiar with the concept of <em>Effects</em>.\nEffects provide a powerful model to keep our reducers pure and describe side effect handling in a declarative way using RxJS streams.</p>\n<blockquote>\n<p>If you&#39;re not familiar with ngrx/store or effects, please read about the core concepts and building blocks <a href=\"https://gist.github.com/btroncone/a6e4347326749f938510\">here</a>.</p>\n</blockquote>\n<p>Simply speaking, an effect is an Observable that maps its items to actions that will then be dispatched to the store automatically.\nIn most cases, the source of an Effect is the global stream of actions:</p>\n<pre><code class=\"language-ts\">@Effect()\nmyEffect<span class=\"hljs-number\">$</span> = this.actions<span class=\"hljs-number\">$</span>.pipe(\n  ofType(BooksActionTypes.LoadBooks),\n  <span class=\"hljs-comment\">// do awesome things like fetching books from an API</span>\n  map(books =&gt; LoadBooksSuccess(books))\n);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">constructor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">private</span> actions$: Actions)</span> <span class=\"hljs-comment\">{}</span></span>\n</code></pre><p>This effect takes the stream of all our actions and filters it by specific actions of the type <code>LoadBooks</code>. For each <code>LoadBooks</code> action it then performs some awesome stuff, e.g. retrieving the book list from the server. Finally, it converts the book list into a new action <code>LoadBooksSuccess</code>. The <code>@Effect()</code> decorator makes sure that the new action is being dispatched automatically.</p>\n<p>While we usually take the actions stream as the source for our effects, it is not actually bound to this source. In fact you can take whatever Observable you want and take its values as your effect source.</p>\n<h2 id=\"the-example-data-books\">The example data: Books</h2>\n<p>In the following examples we will use a <em>book list</em> as our data.\nThe state tree looks like this:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">BooksState</span> {\n  books: Book[];\n}\n</code></pre><p>We have a <code>LoadBooks</code> action that triggers an HTTP request through an effect:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Effect</span>()\nloadBooks = this.actions$.<span class=\"hljs-built_in\">pipe</span>(\n  <span class=\"hljs-built_in\">ofType</span>(BooksActionTypes.LoadBooks),\n  <span class=\"hljs-built_in\">mergeMap</span>(() =&gt; this.service.<span class=\"hljs-built_in\">getBooks</span>().<span class=\"hljs-built_in\">pipe</span>( <span class=\"hljs-comment\">// get book list from service</span>\n    <span class=\"hljs-built_in\">map</span>(books =&gt; new <span class=\"hljs-built_in\">LoadBooksSuccess</span>(books)) <span class=\"hljs-comment\">// trigger action that saves new books to the store</span>\n  ))\n);\n</code></pre><p>The <code>LoadBooksSuccess</code> action invokes a reducer to add the book list to the state:</p>\n<pre><code class=\"language-ts\">// ...\ncase BooksActionTypes.LoadBooksSuccess: {\n  <span class=\"hljs-keyword\">const</span> books = action.payload;\n  return { ...<span class=\"hljs-keyword\">state</span>, books };\n}\n</code></pre><hr>\n\n<p>Now that you know the setup, let&#39;s go through some use cases where it comes in handy to take some other Observables as source for our effects.</p>\n<h2 id=\"1-native-events\">1.) Native events</h2>\n<p>Imagine you want to trigger an action whenever the user resizes the browser window. We&#39;re talking about a native event here that&#39;s not bound to a specific DOM node in our view.\nUsing the <a href=\"https://rxjs-dev.firebaseapp.com/api/index/fromEvent\"><code>fromEvent</code> function</a> from RxJS we can easily build up an observable stream of window resizing events.\nThe debounce is just cosmetic and makes the stream only emit once when the user has stopped resizing for a certain amount of time.\nWith the final resize event we can then dispatch a new action to our store:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { fromEvent } from <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n@Effect()\n<span class=\"hljs-built_in\">resize</span>$ = fromEvent(window, <span class=\"hljs-string\">&#x27;resize&#x27;</span>).pipe(\n  debounceTime(<span class=\"hljs-number\">300</span>),\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> MyWindowResizeAction(e))\n);\n</code></pre><p>This solution is very nice and clean, compared to subscribing to the event and then dispatching actions from one of our components.</p>\n<h2 id=\"2-timersintervals\">2.) Timers/Intervals</h2>\n<p>We can follow a similar approach when it comes to intervals using the <a href=\"https://rxjs-dev.firebaseapp.com/api/index/interval\"><code>interval</code> function</a>. A specific use case could be a polling scenario where you want to dispatch an action every <code>n</code> seconds. Look at how slick we can go for this with an effect:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { interval } from <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n@Effect()\ninterval$ = interval(<span class=\"hljs-number\">2000</span>).pipe(\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> MyFancyAction())\n);\n</code></pre><h2 id=\"3-route-events\">3.) Route events</h2>\n<p>Angular itself uses Observables extensively, e.g. in the router or for reactive forms. Of course, we can also use those streams in our effects.\nLet&#39;s say we want to fetch some data from the server when a specific route is being activated.</p>\n<p>There are a few approaches to this:</p>\n<ol>\n<li>Dispatching the action from the routed component using <code>this.store.dispatch()</code>, usually within <code>ngOnInit()</code></li>\n<li>Using a route guard to intercept the routing process and dispatch the action (as described in an <a href=\"https://toddmotto.com/preloading-ngrx-store-route-guards\">article by Todd Motto here</a>)</li>\n<li>Listen to router events in an effect</li>\n</ol>\n<p>Number #3 is as simple as our previous examples:\nWe can use the <code>events</code> Observable from the Angular <a href=\"https://angular.io/api/router/Router\"><code>Router</code> class</a> and listen to some specific routing events.\nWith the event payload we can decide what to do next, for example dispatching a <code>LoadBooks</code> action:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Effect</span>()\nloadBooks$ = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">router</span>.<span class=\"hljs-property\">events</span>.<span class=\"hljs-title function_\">pipe</span>(\n  <span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> e <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ActivationStart</span>)),\n  <span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-title function_\">isRoute</span>(<span class=\"hljs-string\">&#x27;books/list&#x27;</span>))\n  <span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LoadBooks</span>())\n);\n\n<span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">router</span>: <span class=\"hljs-title class_\">Router</span></span>) {}\n\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isRoute</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">path</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">event</span>: <span class=\"hljs-title class_\">ActivationStart</span></span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">currentPath</span>: <span class=\"hljs-built_in\">string</span>[] = [];\n  <span class=\"hljs-keyword\">let</span> route = event.<span class=\"hljs-property\">snapshot</span>;\n\n  <span class=\"hljs-keyword\">while</span> (route.<span class=\"hljs-property\">parent</span>) {\n    <span class=\"hljs-keyword\">if</span> (route.<span class=\"hljs-property\">routeConfig</span> &amp;&amp; route.<span class=\"hljs-property\">routeConfig</span>.<span class=\"hljs-property\">path</span>) {\n      currentPath.<span class=\"hljs-title function_\">push</span>(route.<span class=\"hljs-property\">routeConfig</span>.<span class=\"hljs-property\">path</span>);\n    }\n    route = route.<span class=\"hljs-property\">parent</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> path === currentPath.<span class=\"hljs-title function_\">reverse</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;/&#x27;</span>);\n}\n</code></pre><p>The event payload object is quite complex and we don&#39;t need to pick it to pieces here.\nWhat we did is to build the <code>isRoute</code> function to traverse through the router tree and bring all our route segments together.</p>\n<p>Actually, this idea is pretty much the same like <a href=\"https://twitter.com/amcdnl\">amcdnl</a> followed with his <a href=\"https://github.com/amcdnl/ngrx-router\">ngrx-router</a> library.\nYour effects become very simple and clean like this one:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { ofRoute } from <span class=\"hljs-string\">&#x27;ngrx-router&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\n@Effect()\nloadBooks$ = this.actions$.pipe(\n  ofRoute(<span class=\"hljs-string\">&#x27;books/list&#x27;</span>),\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> LoadBooks())\n);\n</code></pre><p>Using <a href=\"https://github.com/amcdnl/ngrx-router\">ngrx-router</a> you can also match multiple routes, use route param placeholders or match by regular expressions.\n<strong>If you like the approach above you might want to check this one out!</strong></p>\n<h2 id=\"4-fill-the-store-implicitly\">4.) Fill the store implicitly</h2>\n<p>Exploring this a bit further we can do some advanced implicit magic:\nRetrieving data from somewhere whenever they are not present in the store. This is quite convenient when it comes to data we need all the time like configuration objects or generic lists of helping entities.</p>\n<p>The key behind this idea is that store selectors like <code>store.pipe(select(mySelector))</code> also return Observables. Thus, we can build an effect like the one following. Just read the code carefully first and then continue with the explanation below:</p>\n<pre><code class=\"language-ts\">@Effect()\ngetBooks$ = this.store$.pipe(\n  select(getAllBooks), <span class=\"hljs-comment\">// get book list from store</span>\n  <span class=\"hljs-built_in\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">booksFromStore</span> =&gt;</span> booksFromStore.<span class=\"hljs-built_in\">length</span> == <span class=\"hljs-number\">0</span>), <span class=\"hljs-comment\">// only continue if there are no books</span>\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =&gt;</span> <span class=\"hljs-keyword\">new</span> LoadBooks())\n);\n\n<span class=\"hljs-comment\">// Selector</span>\nconst getAllBooks = createSelector(getBooksState, state =&gt; state.books);\n</code></pre><p>This effect starts working when the book list in our store changes. Using the <code>filter</code> operator it continues the pipeline only when there are no books in the store. This can be the case when</p>\n<ul>\n<li>the application starts with an empty initial state</li>\n<li>or when the books have been deleted by some user action.</li>\n</ul>\n<p>We then dispatch a <code>LoadBooks</code> action to load books from the server.\nSo, whenever the books list happens to be empty, our store will automatically call the service and push the new books to the store.</p>\n<p><strong>⚠️ Please be careful when using this as it might introduce an anti-pattern.\nAs <a href=\"https://twitter.com/MikeRyanDev/status/1003236783490990080\">Mike Ryan stated in a tweet</a>, using store selectors as effects source &quot;breaks a pattern and should probably be avoided&quot;.</strong></p>\n<h2 id=\"5-loop-of-death-️\">5.) Loop of Death ☠️</h2>\n<p>Last but not least will be one of my favorites.\nWhat looks like a harmless little line of code is one of the most evil effects:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Effect()</span>\nloopOfDeath$ = <span class=\"hljs-keyword\">this</span>.actions$;\n</code></pre><p>It just takes all actions and replicates them into an infinite loop. Yay! Please… don&#39;t do this.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>You can see that effects can go far beyond reacting to actions. Since effects basically are nothing more than observables that map to actions, we can use <em>every</em> observable as the source for our effects.\nHowever, please be careful not to mix up things and do not overuse this pattern! The majority of your effects should still follow the usual pattern described at the very top.</p>\n<p>In some cases this one will come in handy, though. Have you experienced some cases other than the ones described here? <strong>Please write us an e-mail or ping us on <a href=\"https://twitter.com/angular_schule\">Twitter</a> – we&#39;re happy to discuss them!</strong></p>\n<hr>\n\n<p><small><strong>Header image:</strong> Island In The Sky, Canyonlands National Park, Utah, 2018</small></p>\n","meta":{"title":"5 useful NgRx effects that don't rely on actions","author":"Ferdinand Malcher","mail":"mail@fmalcher.de","published":"2018-06-02T00:00:00.000Z","lastModified":"2018-06-03T00:00:00.000Z","keywords":["Angular","NgRx","RxJS","Effects","State Management","Observables","Redux"],"language":"en","header":{"url":"canyonlands.jpg","width":1200,"height":636},"hidden":false,"sticky":false,"darkenHeader":false}}
