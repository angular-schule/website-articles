{"slug":"2025-05-resource-api","html":"<p>An interesting new feature in Angular is the <em>Resource API</em>. It allows us to intuitively load data and process it in components.\nIn this blog post, we introduce the ideas behind this new interface.</p>\n<p>A Resource represents a data set that is loaded asynchronously. This usually involves HTTP requests to fetch data from a server. However, Resource goes a step further than just executing a simple HTTP request: The data can be reloaded at any time or even manually overwritten. Additionally, Resource independently provides information about the loading state. All information and data are exposed as signals, ensuring the current value is always available when changes occur.</p>\n<blockquote>\n<p>ðŸ‡©ðŸ‡ª This article is available in German language here: <a href=\"https://angular-buch.com/blog/2024-10-resource-api\">Neu in Angular 19: Daten laden mit der Resource API</a></p>\n</blockquote>\n<h2 id=\"what-happened-before-example-without-resource\">What happened before: Example without Resource</h2>\n<p>To start, let&#39;s consider a scenario implemented in the classic way, without the new Resource API.</p>\n<p>We want to display a list of books in a component, which will be loaded via HTTP from a server.\nThe corresponding <code>BookStore</code> service already exists and is injected via dependency injection. The <code>getAll()</code> method in the service uses Angular&#39;s <code>HttpClient</code> and returns an Observable.</p>\n<p>In the component, we need a <code>books</code> property to cache the data for display in the template.\nThe property is initialized as a signal, following modern practices.\nIn the constructor, we subscribe to the Observable from <code>getAll()</code>. As soon as the list of books arrives from the server, we set the data on the <code>books</code> signal.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookList</span> {\n  #bs = inject(BookStore);\n  books = signal&lt;Book[]&gt;([]);\n\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">this</span>.#bs.getAll().subscribe(receivedBooks =&gt; {\n      <span class=\"hljs-keyword\">this</span>.books.<span class=\"hljs-keyword\">set</span>(receivedBooks);\n    });\n  }\n}\n</code></pre><p>However, it usually doesn&#39;t stop with this simple scenario as additional requirements arise:</p>\n<ul>\n<li><strong>The book list should be reloadable on button click.</strong> This requires creating a new method (e.g., <code>reloadList()</code>) to restart the HTTP request, subscribe again, etc. This duplicates the constructor code.</li>\n<li><strong>No parallel requests should be made.</strong> If data is to be reloaded while a previous request is still running, it should either be canceled or the new request ignored.</li>\n<li><strong>A loading indicator should be shown.</strong> We could add a <code>loading</code> property and toggle it to <code>true</code> or <code>false</code> at the appropriate points.</li>\n<li><strong>Data should be modifiable/overwritable locally.</strong> We could set a new value on the signal. But afterwards, we wouldn&#39;t know whether the value was set locally or loaded from the server.</li>\n<li><strong>The subscription should end when the component is destroyed.</strong> For this we can use <a href=\"https://angular.dev/api/core/rxjs-interop/takeUntilDestroyed\"><code>takeUntilDestroyed()</code></a> or another RxJS-based solution.</li>\n</ul>\n<p>All these aspects can of course be implemented with moderate effor, but we often need to repeat similar steps to achieve our goal.\nInstead of using imperative style as shown, we could also use RxJS. However, the core issue remains: it&#39;s relatively tedious to implement recurring everyday tasks.</p>\n<p>The new Resource API aims to fill this gap!</p>\n<h2 id=\"the-new-resource-api\">The new Resource API</h2>\n<p>A Resource represents data loaded via a loader function.\nWe initialize it using the <code>resource()</code> function.\nThe provided loader is a function that performs the asynchronous data loading.\nThis loader runs immediately when the Resource is initialized.</p>\n<p>The documentation describes the Resource as follows:</p>\n<blockquote>\n<p>A Resource is an asynchronous dependency (for example, the results of an API call) that is managed and delivered through signals.\n[It] projects a reactive request to an asynchronous operation defined by a loader function, which exposes the result of the loading operation via signals.</p>\n</blockquote>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { resource } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\nmyResource = resource({\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-comment\">/* load data */</span>\n});\n</code></pre><p>Interestingly, the loader must return a Promise. Though there is nothing wrong with this native browser model, Angular has traditionally used Observables and RxJS for asynchronous operations.\nAngular breaks from tradition here by favoring the browser&#39;s native construct.</p>\n<p>To perform an HTTP request using a Resource, we have three options:</p>\n<ul>\n<li>1.) Use an HTTP client that returns Promises, such as the native <code>fetch()</code> or the <code>axios</code> library.</li>\n<li>2.) Use the <code>firstValueFrom()</code> function from RxJS to convert an Observable into a Promise that resolves with the first item.</li>\n<li>3.) Use an <code>rxResource</code>, which uses an Observable as the loader. More on that later!</li>\n</ul>\n<h3 id=\"option-1-promises-and-the-native-fetch-api\">Option 1: Promises and the native Fetch API</h3>\n<p>In the <code>BookStore</code>, we use the native Fetch API so that the <code>getAll()</code> method returns a Promise. In the loader, we can use this Promise directly.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  getAll(): Promise&lt;Book[]&gt; {\n    <span class=\"hljs-keyword\">return</span> fetch(<span class=\"hljs-keyword\">this</span>.apiUrl + <span class=\"hljs-string\">&#x27;/books&#x27;</span>).then(res =&gt; res.json());\n  }\n}\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-regexp\">//</span> Component\nbooksResource = resource({\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.<span class=\"hljs-comment\">#bs.getAll()</span>\n});\n</code></pre><h3 id=\"option-2-observables-and-angulars-httpclient\">Option 2: Observables and Angular&#39;s <code>HttpClient</code></h3>\n<p>We use Angular&#39;s <code>HttpClient</code> as usual, so the <code>getAll()</code> method returns an Observable.\nTo define the loader, we must convert the Observable to a Promise using <code>firstValueFrom()</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  getAll(): Observable&lt;Book[]&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.http.<span class=\"hljs-keyword\">get</span>&lt;Book[]&gt;(<span class=\"hljs-keyword\">this</span>.apiUrl + <span class=\"hljs-string\">&#x27;/books&#x27;</span>);\n  }\n}\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-regexp\">//</span> Component\nbooksResource = resource({\n  loader: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> firstValueFrom(this.<span class=\"hljs-comment\">#bs.getAll())</span>\n});\n</code></pre><h2 id=\"accessing-the-data\">Accessing the data</h2>\n<p>The loader is executed immediately when the Resource object is initialized. The Resource processes the response and offers the following signals to work with the data:</p>\n<ul>\n<li><code>value</code>: loaded data, here <code>Book[]</code></li>\n<li><code>status</code>: state of the Resource, type <code>ResourceStatus</code>, e.g., <code>resolved</code> or <code>loading</code>, see next section</li>\n<li><code>error</code>: error</li>\n</ul>\n<p>We can display the loaded books in the template like this:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">booksResource.value</span>() | json }}</span><span class=\"language-xml\">\n\n@for(book of booksResource.value(); track book.isbn) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n}</span>\n</code></pre><h2 id=\"status-of-the-resource\">Status of the Resource</h2>\n<p>Using the <code>status</code> signal, we can evaluate the state of the Resource, e.g., to show a loading indicator. All <code>status</code> values are defined by the <a href=\"https://angular.dev/api/core/ResourceStatus\"><code>ResourceStatus</code> union type</a>:</p>\n<table>\n<thead>\n<tr>\n<th>Status from <code>ResourceStatus</code></th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>idle</code></td>\n<td>No params are defined and nothing is loading. <code>value()</code> is <code>undefined</code>.</td>\n</tr>\n<tr>\n<td><code>error</code></td>\n<td>Loading failed. <code>value()</code> is <code>undefined</code>.</td>\n</tr>\n<tr>\n<td><code>loading</code></td>\n<td>The Resource is currently loading.</td>\n</tr>\n<tr>\n<td><code>reloading</code></td>\n<td>The Resource is reloading after <code>reload()</code> was called.</td>\n</tr>\n<tr>\n<td><code>resolved</code></td>\n<td>Loading is complete.</td>\n</tr>\n<tr>\n<td><code>local</code></td>\n<td>The value was overwritten locally.</td>\n</tr>\n</tbody></table>\n<p>For a loading indicator, we could process the state in a computed signal and return a boolean if the Resource is currently loading:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { resource, computed, ResourceStatus } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\nisLoading = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.booksResource.status() === <span class=\"hljs-string\">&#x27;loading&#x27;</span>);\n</code></pre><pre><code class=\"language-html\"><span class=\"hljs-keyword\">@if</span> (isLoading()) {\n  &lt;<span class=\"hljs-selector-tag\">div</span>&gt;LOADING&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;\n}\n</code></pre><p>To cover all cases, we also need to account for the <code>Reloading</code> state.\nUsing the built-in <code>isLoading</code> property solves this quickly: this signal returns <code>true</code> if the Resource is in the <code>loading</code> or <code>reloading</code> state:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-keyword\">@if</span> (booksResource.isLoading()) {\n  &lt;<span class=\"hljs-selector-tag\">div</span>&gt;LOADING&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;\n}\n</code></pre><h2 id=\"reloading-the-resource\">Reloading the Resource</h2>\n<p>A Resource provides a <code>reload()</code> method.\nWhen called, the loader function is executed again internally and the data is reloaded.\nThe result is then again available through the <code>value</code> signal.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;reloadList()&quot;</span>&gt;</span>Reload book list<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookList</span> </span>{\n  booksResource = resource({ <span class=\"hljs-regexp\">/* ... */</span> });\n\n  reloadList() {\n    this.booksResource.reload();\n  }\n}\n</code></pre><p>The Resource ensures that only one request is executed at a time.\nReloading is only possible once the previous load has completed.\nYou can see this behavior clearly in the <a href=\"https://github.com/angular/angular/blob/20.0.0/packages/core/src/resource/resource.ts#L294-L296\">Angular source code</a>.</p>\n<h2 id=\"overwriting-the-value-locally\">Overwriting the Value Locally</h2>\n<p>The Resource allows the value to be overwritten locally.\nThe <code>value</code> signal is a <code>WritableSignal</code> and offers the familiar <code>set()</code> and <code>update()</code> methods.</p>\n<p>We want to sort the book list locally on button click, sorted by rating.\nIn the method, we can sort the list and directly overwrite the <code>value</code> signal.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookList</span> {\n  booksResource = <span class=\"hljs-title function_\">resource</span>({ <span class=\"hljs-comment\">/* ... */</span> });\n\n  <span class=\"hljs-title function_\">sortBookListLocally</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> currentBookList = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksResource</span>.<span class=\"hljs-title function_\">value</span>();\n\n    <span class=\"hljs-keyword\">if</span> (currentBookList) {\n      <span class=\"hljs-keyword\">const</span> sortedList = currentBookList.<span class=\"hljs-title function_\">toSorted</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> b.<span class=\"hljs-property\">rating</span> - a.<span class=\"hljs-property\">rating</span>);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">booksResource</span>.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">set</span>(sortedList);\n    }\n  }\n}\n</code></pre><p>We want to point out two things in this code:</p>\n<ul>\n<li>The <code>value</code> signal returns type <code>T | undefined</code>, in our case <code>Book[] | undefined</code>. If the data hasn&#39;t been loaded yet, the value is <code>undefined</code>. Therefore, we need to check whether <code>currentBookList</code> exists. We can also pass a default value through the <code>defaultValue</code> option to avoid this behavior.</li>\n<li>Instead of <code>Array.sort()</code>, we use the new method <code>Array.toSorted()</code>, which does not mutate the array and returns a sorted copy. This preserves immutability. <code>toSorted()</code> can only be used if the <code>lib</code> option in <code>tsconfig.json</code> includes at least <code>ES2023</code>, which is not the case in new Angular projects yet.</li>\n</ul>\n<h2 id=\"params-loader-with-parameter\"><code>params</code>: Loader with Parameter</h2>\n<p>Our app should have a detail page that displays a single book.\nSo the HTTP request must receive information about which book to load.\nWhen navigating to a different detail page, loading must restart for another book.</p>\n<p>The loader must therefore be able to work with parameters.\nLet&#39;s assume the component has an input property <code>isbn</code> through which the current ISBN is available.</p>\n<p>In the loader, we could now use the signal <code>this.isbn</code> to pass the ISBN to the service:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({ <span class=\"hljs-regexp\">/* ... */</span> })\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetails</span> </span>{\n  <span class=\"hljs-comment\">#bs = inject(BookStore);</span>\n  readonly isbn = input.required&lt;string&gt;();\n\n  bookResource = resource({\n    <span class=\"hljs-regexp\">//</span> NOTE: Only executed once!\n    loader: () =&gt; this.<span class=\"hljs-comment\">#bs.getSingle(this.isbn())</span>\n  });\n}\n</code></pre><p>This code basically works â€“ but only once! The loader function is <em>untracked</em>. This means it won&#39;t automatically rerun when the signal values it depends on change (unlike with <code>effect()</code> or <code>computed()</code>).</p>\n<p>To solve this, we can use the <code>params</code> property: Here we pass a signal or a function that uses signals inside. Whenever these signal change their value, the loader will automatically run again.</p>\n<p>The request signal thus provides the parameters with which the loader is executed.</p>\n<pre><code class=\"language-ts\">@Component({ <span class=\"hljs-comment\">/* ... */</span> })\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetails</span> {\n  <span class=\"hljs-meta\">#bs = inject(BookStore);</span>\n  <span class=\"hljs-keyword\">readonly</span> isbn = input.<span class=\"hljs-keyword\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  bookResource = resource({\n    <span class=\"hljs-keyword\">params</span>: <span class=\"hljs-keyword\">this</span>.isbn,\n    <span class=\"hljs-comment\">// or</span>\n    <span class=\"hljs-keyword\">params</span>: () =&gt; <span class=\"hljs-keyword\">this</span>.isbn(),\n    loader: () =&gt; <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-meta\">#bs.getSingle(this.isbn())</span>\n  });\n}\n</code></pre><p>To make the loader a bit more generic and reusable, we can avoid directly calling <code>this.isbn()</code>.\nThe value from <code>params</code> is conveniently passed as an argument to the loader function.\nThis allows us to outsource the loader to a separate function and reuse it in other Resources.</p>\n<p>The loader automatically receives an argument of type <code>ResourceLoaderParams</code>, which has a <code>params</code> property. In our example, it holds the ISBN returned by the <code>params</code> function.</p>\n<pre><code class=\"language-ts\">@Component({ <span class=\"hljs-comment\">/* ... */</span> })\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BookDetails</span> {\n  <span class=\"hljs-meta\">#bs = inject(BookStore);</span>\n  <span class=\"hljs-keyword\">readonly</span> isbn = input.<span class=\"hljs-keyword\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  bookResource = resource({\n    <span class=\"hljs-keyword\">params</span>: <span class=\"hljs-keyword\">this</span>.isbn,\n    loader: ({ <span class=\"hljs-keyword\">params</span> }) =&gt; <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-meta\">#bs.getSingle(params)</span>\n  });\n}\n</code></pre><blockquote>\n<p><strong>Route Parameters with Component Input Binding:</strong> To automatically bind the <code>isbn</code> input property to the current route parameter, you can use the router&#39;s <a href=\"https://netbasal.com/binding-router-information-to-routed-component-inputs-in-angular-78ee92f63e64\"><em>Component Input Binding</em></a> feature.</p>\n</blockquote>\n<h2 id=\"rxresource-resource-with-observables\"><code>rxResource</code>: Resource with Observables</h2>\n<p>In all previous examples, we implemented the loader function using Promises. The browser&#39;s Fetch API returns a Promise, and the RxJS function <code>firstValueFrom()</code> helped us create a Promise from the Observable returned by Angular&#39;s <code>HttpClient</code>.</p>\n<p>Even though Angular now uses signals in many places instead of Observables, reactive programming with RxJS still has its valid use cases.\nAngular therefore provides the <code>rxResource</code> function. It works just like <code>resource</code>, but the loader function returns an Observable instead.\nThis way, we can use Observables from <code>HttpClient</code> directly.</p>\n<p>Since an Observable <em>can</em> emit an infinite number of values, the property here is called <code>stream</code> instead of <code>loader</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Injectable({ /* ... */ })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookStore</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  getAll(): Observable&lt;Book[]&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.http.<span class=\"hljs-keyword\">get</span>&lt;Book[]&gt;(<span class=\"hljs-keyword\">this</span>.apiUrl + <span class=\"hljs-string\">&#x27;/books&#x27;</span>);\n  }\n}\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { rxResource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> ...\n\nbooksResource = rxResource({\n  stream: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> this.<span class=\"hljs-comment\">#bs.getAll()</span>\n});\n</code></pre><h2 id=\"cancelling-ongoing-requests\">Cancelling Ongoing Requests</h2>\n<p>The Resource provides a way to cancel a running request when a new one is started.\nEspecially for loaders with parameters (like the ISBN on the detail page), it&#39;s important that only the most recently requested data is processed.</p>\n<p>The <code>rxResource</code> manages this mechanism internally, because an Observable provides a direct way to cancel the request.</p>\n<p>For loaders based on Promises, cancelling is a bit more complicated.\nThe loader also receives a so-called <code>AbortSignal</code> in its parameter object.\nThis is a native browser object that indicates when the request should be aborted.</p>\n<p>Together with the native Fetch API, this object can be used directly.\nIf <code>this.isbn</code> changes while the loader is still running, the current fetch request will be aborted.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-comment\">/* ... */</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookDetails</span> {\n  #bs = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BookStore</span>);\n  <span class=\"hljs-keyword\">readonly</span> isbn = input.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n\n  bookResource = <span class=\"hljs-title function_\">resource</span>({\n    <span class=\"hljs-attr\">params</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isbn</span>,\n    <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ abortSignal, aprams }</span>) =&gt;</span> <span class=\"hljs-title function_\">fetch</span>(\n      detailsUrl + <span class=\"hljs-string\">&#x27;/&#x27;</span> + params,\n      { <span class=\"hljs-attr\">signal</span>: abortSignal }\n    )\n  });\n}\n</code></pre><p>If we&#39;re using Angular&#39;s <code>HttpClient</code> and <code>firstValueFrom</code>, cancellation becomes very cumbersome â€“ we would need to convert the <code>AbortSignal</code> into an Observable to use the <code>takeUntil</code> operator to stop the stream. In this case, we strongly recommend using <code>rxResource</code>.</p>\n<p>By the way, the Resource also ensures that an active request is stopped when the component is destroyed.</p>\n<h2 id=\"httpresource-resource-for-http-requests\">httpResource: Resource for HTTP Requests</h2>\n<p>In early 2025, another variant of the Resource was introduced: <code>httpResource</code>.\nIt uses Angular&#39;s <code>HttpClient</code> under the hood to perform an HTTP request directly.\nYou no longer need to write the request yourself â€“ the resource handles it for you.</p>\n<pre><code class=\"language-ts\">booksResource = httpResource&lt;Book[]&gt;(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-string\">&#x27;https://api.example.org/books&#x27;</span>,\n  { defaultValue: [] }\n);\n</code></pre><p>The request must be generated using a function.\nThis is because it runs in a <em>reactive context</em>: If you use signals inside the function, the request is re-executed automatically when any of those signals change. This is similar to the <code>params</code> property in a resource.\nAdditional request details can be passed in an options object:</p>\n<pre><code class=\"language-ts\">booksResource = httpResource&lt;Book[]&gt;(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({\n    url: <span class=\"hljs-string\">&#x27;https://api.example.org/books&#x27;</span>,\n    params: {\n      search: <span class=\"hljs-string\">&#x27;Angular&#x27;</span>\n    }\n  })\n);\n</code></pre><p>Please note that a resource is only meant for <em>retrieving</em> data from an API and exposing it with signals.\nWrite operations such as create, update, or delete cannot be handled with a resource.\nYou must continue to use <code>HttpClient</code> directly for those.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>With the new Resource API, Angular introduces an intuitive and well-integrated interface for loading data from a server.\nUse cases beyond a simple HTTP request, especially reloading data and showing a loading indicator, can be implemented quickly with the Resource.\nUntil now, that required a lot of manual effort.</p>\n<p>We welcome Angular&#39;s focus on addressing this common everyday problem. The solution covers most use cases reliably and offers a standardized approach-only more advanced needs will require custom implementation going forward.</p>\n<p>Angular continues its journey toward embracing signals in the framework. The need to use RxJS and Observables for simple tasks is further reduced.</p>\n<p>It remains to be seen what role Angular&#39;s <code>HttpClient</code> will play in the future. By promoting the use of Promises, Angular encourages HTTP communication via the native Fetch API. It would be desirable for <code>HttpClient</code> and Resource to work seamlessly together. One could imagine <code>HttpClient</code> directly returning a Resource, avoiding the intermediate step through an Observable or Promise.\nIn our view, the new interface is a solid foundation-and we&#39;re excited to see what comes next!</p>\n<hr>\n<small>Many thanks to Johannes Hoppe and Danny Koppenhagen for review and feedback.</small>\n\n<p><small><strong>Cover image:</strong> Photo by <a href=\"https://unsplash.com/de/@thepaintedsquarejessica\">Jessica Lewis ðŸ¦‹ thepaintedsquare</a> on <a href=\"https://unsplash.com/de/fotos/geschnittene-erdbeeren-auf-blaugrunem-keramikteller-15nvaBz_doc\">Unsplash</a> (edited) </small></p>\n","meta":{"title":"Reactive Angular: Loading Data with the Resource API","author":"Ferdinand Malcher","mail":"ferdinand@malcher.media","published":"2025-05-13T00:00:00.000Z","lastModified":"2025-06-18T00:00:00.000Z","keywords":["Resource API","Promise","Observable","resource","rxResource","Fetch API"],"language":"en","header":{"url":"header-resource-api.jpg","width":2000,"height":1159},"hidden":false,"sticky":false,"darkenHeader":false}}
