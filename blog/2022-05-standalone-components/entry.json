{"slug":"2022-05-standalone-components","html":"<p>Das wohl am heißesten diskutierte aktuelle Feature von Angular 14 sind die <em>Standalone Components</em>.\nKomponenten, Pipes und Direktiven müssen damit nicht mehr in einem NgModule deklariert werden, sondern können eigenständig genutzt werden.\nIn diesem Artikel geben wir einen Überblick und zeigen, wie Sie das neue Feature praktisch verwenden.</p>\n<blockquote>\n<p>Wichtig: Die Standalone Features sind derzeit in <em>Developer Preview</em>. Die Schnittstelle kann sich also noch ändern, bevor sie als stable veröffentlicht wird.</p>\n</blockquote>\n<h2 id=\"ngmodule-und-standalone-components\">NgModule und Standalone Components</h2>\n<p>Angular-Module mit NgModule sind ein fester Bestandteil des Frameworks, um Anwendungen zu strukturieren. Mithilfe von Modulen können wir vor allem fachliche Features und andere zusammenhängende Teile von Apps gruppieren.\nDamit eine Komponente verwendet werden kann, muss sie immer in einem Modul deklariert werden – aber nur in genau einem.</p>\n<p>Diese Bündelung birgt immer wieder praktische Probleme, wenn es um Wiederverwendbarkeit von Komponenten, Pipes und Direktiven geht.\nWo werden die Komponenten deklariert? Wo müssen welche Module importiert werden?\nHäufig steckt man diese Dinge in ein globales <code>SharedModule</code>, das überall dort importiert wird, wo eine wiederverwendbare Komponente benötigt wird.\nDadurch entsteht ein schwerfälliges und allwissendes Modul, das eine entkoppelte Struktur der Anwendung eher verhindert.\nAußerdem macht der mentale Overhead der Module es komplizierter, das Angular-Framework zu erlernen.</p>\n<p>Einige Entwicklerinnen und Entwickler setzen deshalb in der Praxis darauf, für jede Komponente ein eigenes Modul zu erstellen. Dadurch wird die Idee von Modulen fast vollständig verabschiedet: Eine Komponente muss in ihr Modul genau die Dinge importieren, die sie verwenden möchte – nicht mehr und nicht weniger.\n(Dieses Konzept ist auch als <em>SCAM (Single-Component Angular Module)</em> bekannt.)</p>\n<p>Nun wurde die Problematik der NgModules direkt vom Angular-Team angegangen: Seit Angular 14 sind die sogenannten <em>Standalone Components</em> als Developer Preview verfügbar!\nEine Komponente, Pipe oder Direktive, die als Standalone markiert ist, wird nicht in einem Modul deklariert, sondern wird alleinstehend verwendet.\nDadurch werden NgModules optional: Die Komponenten importieren selbst die Dinge, die sie in ihren Templates benötigen. Eine Bündelung in Modulen entfällt, und die Struktur der Anwendung wird vereinfacht.</p>\n<h2 id=\"standalone-components-verwenden\">Standalone Components verwenden</h2>\n<blockquote>\n<p>Die neuen Standalone Features funktionieren gleichermaßen für Komponenten, Pipes und Direktiven.\nDer Einfachheit halber gehen wir im Folgenden aber nur auf Komponenten ein.</p>\n</blockquote>\n<p>Um eine Komponente, Pipe oder Direktive alleinstehend zu verwenden, setzen wir das neue Flag <code>standalone</code> im Decorator der Klasse:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  selector: <span class=\"hljs-string\">&#x27;app-dashboard&#x27;</span>,\n  standalone: true,\n  <span class=\"hljs-regexp\">//</span> ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DashboardComponent</span> </span>{}\n</code></pre><p>Dadurch wird die Komponente unabhängig von einem Angular-Modul und kann alleinstehend genutzt werden.\nDiese Einstellung können wir auch sofort beim Generieren der Komponente mit der Angular CLI angeben:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-selector-tag\">g</span> component dashboard <span class=\"hljs-attr\">--standalone</span>\n</code></pre><p>Damit die Komponente nun tatsächlich genutzt werden kann, müssen wir sie dort importieren, wo sie benötigt wird.\nEine andere Standalone Component kann dafür in ihren Metadaten Imports definieren. Auf diese Weise erklärt die Komponente selbst, welche anderen Teile der Anwendung sie in ihrem Template verwenden möchte:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  selector: <span class=\"hljs-string\">&#x27;app-root&#x27;</span>,\n  standalone: true,\n  imports: [DashboardComponent]\n  // ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> </span>{}\n</code></pre><p>Das sieht zunächst etwas aufwendiger aus, allerdings profitiert die Struktur der Anwendung stark davon: Die tatsächlichen Beziehungen zwischen Komponenten sind so noch klarer auf den ersten Blick erkennbar.\nAußerdem entfällt die Deklaration in einem Modul.</p>\n<h2 id=\"kombination-mit-ngmodules\">Kombination mit NgModules</h2>\n<p>Beim Design von Standalone Components wurde sehr viel Wert auf die Abwärtskompatibilität gelegt.\nStandalone Components und NgModules können deshalb in Kombination genutzt werden.\nEine Standalone Component kann dafür auch unter <code>imports</code> in einem NgModule eingetragen werden, so als wäre sie ein eigenes Modul. (Tatsächlich besitzt die Komponente natürlich kein Modul, denn sie ist ja standalone.)\nSie ist dann in dem gesamten NgModule sichtbar und verwendbar:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@NgModule</span>({\n  imports: [\n    <span class=\"hljs-regexp\">//</span> andere Module\n    BrowserModule,\n    AppRoutingModule,\n\n    <span class=\"hljs-regexp\">//</span> Standalone Components\n    DashboardComponent\n  ],\n  <span class=\"hljs-regexp\">//</span> ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{}\n</code></pre><p>Genauso kann eine Standalone Component selbst Module importieren, deren Bestandteile sie in ihrem Template nutzen möchte.\nDas ist insbesondere für das <code>CommonModule</code> wichtig, das die eingebauten Pipes und Direktiven wie <code>ngIf</code> mitbringt.\nBeim Generieren einer Komponente mit der Angular CLI wird deshalb immer schon das <code>CommonModule</code> standardmäßig importiert.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  standalone: true,\n  imports: [\n    CommonModule,\n    BooksSharedModule\n  ]\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DashboardComponent</span> </span>{}\n</code></pre><p>Um mehrere Komponenten, Pipes und Direktiven gemeinsam einzubinden, können diese als Array exportiert und importiert werden.\nZum Beispiel kann eine Bibliothek all jene Direktiven zusammen exportieren, die auch gemeinsam genutzt werden sollen.\nAuf diese Weise erhält man einen ähnlichen Komfort wie mit einem NgModule, das mehrere Dinge zur Nutzung bereitstellt.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-attribute\">export SHARED_THINGS</span> = [BookComponent, IsbnPipe, ConfirmDirective];\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  standalone: true,\n  imports: [CommonModule, SHARED_THINGS]\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DashboardComponent</span> </span>{}\n</code></pre><h2 id=\"appcomponent-direkt-bootstrappen\">AppComponent direkt bootstrappen</h2>\n<p>Besteht die gesamte Anwendung nur aus Standalone Components ohne Module, können wir auch das globale <code>AppModule</code> entfernen.\nStattdessen wird direkt die Wurzelkomponente gebootstrappt, in der Regel die <code>AppComponent</code>.\nIn der Datei <code>main.ts</code> nutzen wir dazu die neue Funktion <code>bootstrapApplication()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-keyword\">import</span> { bootstrapApplication } from <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { AppComponent } from <span class=\"hljs-string\">&#x27;./app/app.component&#x27;</span>;\n\nbootstrapApplication(AppComponent)\n  .<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n</code></pre><h2 id=\"providers-in-modulen\">Providers in Modulen</h2>\n<blockquote>\n<p>Für Services werden in der Regel <em>Tree-Shakable Providers</em> verwendet, indem die Klasse mit <code>providedIn</code> markiert wird. Die folgenden Infos treffen nur auf Providers zu, die bisher direkt im <code>AppModule</code> unter <code>providers</code> angegeben wurden.</p>\n</blockquote>\n<p>Neben Komponenten, Pipes und Direktiven können Module verschiedene Providers für die Dependency Injection bereitstellen.\nImportiert man das Modul, sind die Providers mit an Bord.</p>\n<p>An dieser Stelle wird es etwas komplizierter, denn auch Providers werden nun eigenständig behandelt.\nDafür können wir in der Funktion <code>bootstrapApplication()</code> ein Array von Providers angeben.\nDas Ergebnis ist das gleiche, als hätten wir die Providers im <code>AppModule</code> hinterlegt.</p>\n<pre><code class=\"language-ts\">bootstrapApplication(AppComponent, {\n  <span class=\"hljs-attr\">providers</span>: [\n    { <span class=\"hljs-attr\">provide</span>: MY_SETTING, <span class=\"hljs-attr\">useValue</span>: <span class=\"hljs-string\">&#x27;my value&#x27;</span> }\n  ]\n}).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n</code></pre><p>Importieren wir über den Decorator einer Komponente ein Modul, das Providers beinhaltet, so werden diese für die aktuelle und alle darunterliegenden Komponenten bereitgestellt.\nAuch die Eigenschaft <code>providers</code> im <code>Component</code>-Decorator funktioniert weiterhin ohne Veränderungen, sollte aber bewusst eingesetzt werden.</p>\n<p>Möchte man nur die Providers eines Moduls extrahieren und global bereitstellen, kann die neue Funktion <code>importProvidersFrom()</code> genutzt werden.\nDie im Modul enthaltenen Komponenten, Pipes und Direktiven werden dabei ignoriert.\nDas ist besonders praktisch, wenn Module angefordert werden sollen, die ausschließlich Providers beinhalten, z. B. das <code>HttpClientModule</code> oder <code>StoreModule</code> und <code>EffectsModule</code> von NgRx.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { importProvidersFrom } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-comment\">// ...</span>\n\nbootstrapApplication(AppComponent, {\n  <span class=\"hljs-attr\">providers</span>: [\n    importProvidersFrom(HttpClientModule)\n  ]\n}).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n</code></pre><h2 id=\"projektstruktur\">Projektstruktur</h2>\n<p>Strukturieren wir die Anwendung mit NgModules, so wird jedes Modul in einem eigenen Unterordner generiert.\nAuch bisher empfehlen wir, abgrenzbare fachliche Features in eigenen Modulen (oder sogar eigenen Bibliotheken) zu strukturieren, die im Dateisystem sauber voneinander getrennt sind.</p>\n<p>Ohne Module ist diese Architekturidee weiterhin anwendbar:\nTeile der Anwendung, die ein zusammenhängendes fachliches Feature repräsentieren, sollten in einem gemeinsamen Ordner untergebracht werden.\nDiese Feature-Ordner oder -Bibliotheken sollten möglichst &quot;flach&quot; im Dateisystem strukturiert werden, also ohne eine tiefe Verschachtelung.</p>\n<p>Für gemeinsam genutzte Teile war bisher immer ein oder mehrere <code>SharedModule</code> notwendig, das Komponenten, Pipes und Direktiven bereitstellt.\nWerden diese Teile nun als Standalone deklariert, ist der tatsächliche Ort im Dateisystem irrelevant.\nEntscheidend ist, wer welche Teile importiert.\nDie gemeinsam genutzten Komponenten, Pipes und Direktiven sollten deshalb z. B. nach fachlichen Belangen in Unterordner gruppiert werden.</p>\n<p><strong>Kurz: Die Ideen zur Ordnerstruktur der Anwendung bleiben erhalten, auch wenn Standalone Components genutzt werden.</strong></p>\n<h2 id=\"routing\">Routing</h2>\n<p>Um den Router zu konfigurieren, musste bisher das <code>RouterModule</code> importiert werden.\nNeben den Direktiven wie <code>RouterLink</code> stellt das Modul auch Services bereit, z. B. <code>Router</code> oder <code>ActivatedRoute</code>.\nDiese beiden Bestandteile müssen nun getrennt behandelt werden.</p>\n<h3 id=\"routen-konfigurieren\">Routen konfigurieren</h3>\n<p>Zunächst müssen wir in der Datei <code>main.ts</code> das <code>RouterModule</code> mit der Methode <code>forRoot()</code> importieren.\nWir nutzen auch hier wieder die Funktion <code>importProvidersFrom()</code>, um nur die Providers zu erhalten.\nDadurch werden die Services und Root-Routen bereitgestellt.</p>\n<p>Wir empfehlen, die Routendefinitionen weiterhin in einer separaten Datei unterhalb des Ordners <code>src/app</code> aufzubewahren, damit sie nicht in der <code>main.ts</code> notiert werden müssen:</p>\n<pre><code class=\"language-ts\">// app<span class=\"hljs-selector-class\">.routes</span><span class=\"hljs-selector-class\">.ts</span>\nexport const appRoutes: Routes = [\n  { <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;books&#x27;</span>, component: DashboardComponent },\n  { <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;books/:isbn&#x27;</span>, component: BookDetailsComponent },\n];\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-comment\">// main.ts</span>\n<span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-keyword\">import</span> { appRoutes } from <span class=\"hljs-string\">&#x27;./app/app.routes&#x27;</span>;\n\nbootstrapApplication(AppComponent, {\n  <span class=\"hljs-attr\">providers</span>: [\n    importProvidersFrom(RouterModule.forRoot(appRoutes)),\n  ]\n}).<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));\n</code></pre><p>Um diesen Schritt zu vereinfachen, wird Angular vermutlich in Zukunft selbst eine Funktion wie <code>provideRouter()</code> anbieten, die nur die Providers ohne ein Modul liefert.\nAuch für das Framework NgRx sind Funktionen wie <code>provideStore()</code> oder <code>provideEffects()</code> denkbar.</p>\n<h3 id=\"direktiven-des-routers-nutzen\">Direktiven des Routers nutzen</h3>\n<p>Wenn wir im Template einer Standalone-Komponente die Direktiven des Routers nutzen wollen, z. B. <code>RouterLink</code> oder <code>RouterOutlet</code>, müssen wir das <code>RouterModule</code> dort importieren:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-variable\">@Component</span>({\n  <span class=\"hljs-regexp\">//</span> ...\n  standalone: true,\n  imports: [CommonModule, RouterModule]\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> </span>{}\n</code></pre><h3 id=\"lazy-loading\">Lazy Loading</h3>\n<p>Beim Lazy Loading mit dem Router werden für eine gemeinsame Basisroute die Kindrouten aus einem anderen Modul nachgeladen.\nDieses zu ladende Kindmodul wird in ein eigenes Bundle verpackt, das erst zur Laufzeit asynchron heruntergeladen wird.\nMit Modulen kann die Basisroute für Lazy Loading wie folgt definiert werden, <code>loadChildren</code> verweist auf ein Feature-Modul:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// mit NgModule:</span>\n<span class=\"hljs-comment\">// loadChildren lädt ein Modul</span>\n{\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books&#x27;</span>,\n  <span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./books/books.module&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.BooksModule)\n}\n</code></pre><p>Mit Standalone Components funktioniert dieses Konzept sehr ähnlich – nur ohne Module.\nWir definieren ebenfalls in den App-Routen eine Basisroute.\nDie Eigenschaft <code>loadChildren</code> verweist nun allerdings auf ein Array von Routen:</p>\n<pre><code class=\"language-ts\">// books/books<span class=\"hljs-selector-class\">.routes</span><span class=\"hljs-selector-class\">.ts</span>\nexport const booksRoutes: Routes = [\n  { <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>, component: DashboardComponent },\n  { <span class=\"hljs-selector-tag\">path</span>: <span class=\"hljs-string\">&#x27;:isbn&#x27;</span>, component: BookDetailsComponent },\n];\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-comment\">// app.routes.ts</span>\n<span class=\"hljs-comment\">// ...</span>\n\n<span class=\"hljs-comment\">// mit Standalone Components:</span>\n<span class=\"hljs-comment\">// loadChildren lädt ein Array von Routen</span>\n{\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;books&#x27;</span>,\n  <span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./books/books.routes&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.booksRoutes)\n}\n</code></pre><p>Neu ist außerdem die Möglichkeit, eine einzelne Komponente mittels Lazy Loading direkt zu laden.\nDas ist besonders praktisch, wenn es sich bei der gerouteten Komponente gar nicht um ein komplexes Feature mit mehreren Kind-Routen handelt, sondern nur um eine einzelne Ansicht.\nUm eine Komponente zu laden, nutzen wir <code>loadComponent</code>:</p>\n<pre><code class=\"language-ts\">{\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;dashboard&#x27;</span>,\n  <span class=\"hljs-attr\">loadComponent</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./dashboard/dashboard.component&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.DashboardComponent)\n}\n</code></pre><p>Prinzipiell funktioniert es also so, als würden wir die Komponente über <code>component</code> direkt in der Route angeben.\nTrotzdem ist das Lazy Loading aktiv, sodass die Komponente erst beim Aktivieren der Route überhaupt heruntergeladen wird.</p>\n<h2 id=\"fazit\">Fazit</h2>\n<p>Die neuen Standalone Features von Angular beseitigen den Overhead, der durch NgModules verursacht wurde.\nEine Standalone Component importiert genau die Dinge, die sie selbst in ihrem Template nutzen möchte.\nDie Sichtbarkeit wird also nicht über die Zugehörigkeit zu einem Modul geregelt, sondern durch den Import.\nDie Struktur der Anwendung wird dadurch leichter verständlich, weil das gesamte Wissen über die Abhängigkeiten in der Komponente liegt.</p>\n<p>Das Angular-Team hat das Design der Standalone Features sehr sorgfältig abgewägt und diskutiert.\nDadurch integrieren sich Standalone Components nahtlos in eine bestehende Anwendung.\nEs handelt sich aber weiterhin um normale Komponenten, Pipes und Direktiven – sie sind jetzt nur keinem Modul mehr zugeordnet.</p>\n<p>Die neue Herangehensweise an die Angular-Entwicklung ist ein großer Bruch. Es wird einige Zeit dauern, bis sich die neuen Patterns und Architekturen etabliert haben.\nDas langfristige Ziel ist es, Module vollständig abzuschaffen. Doch keine Angst:\nNgModules werden noch so lange bestehen bleiben, bis die Standalone Features sicher in der Community angekommen sind.\nWir empfehlen Ihnen daher, nicht sofort alle bestehenden Anwendungen zu migrieren, sondern auch weiterhin auf NgModules zu setzen.\nFür wiederverwendbare Komponenten, Pipes und Direktiven kann sich jedoch der Umstieg auf die neuen Standalone Components auch jetzt schon lohnen.</p>\n<p>Zur Ergänzung und Vertiefung empfehlen wir Ihnen einen Blick in die <a href=\"https://angular.io/guide/standalone-components\">Angular-Dokumentation zu Standalone Components</a>.</p>\n<hr>\n\n<p>Vielen Dank an <strong>Danny Koppenhagen</strong> für Diskussion und Review zum Artikel!</p>\n<p><small><strong>Titelbild:</strong> Photo by <a href=\"https://unsplash.com/@mourimoto\">Mourizal Zativa</a> on <a href=\"https://unsplash.com\">Unsplash</a> (edited)</small></p>\n","meta":{"title":"Standalone Components – neu ab Angular 14","author":"Ferdinand Malcher","mail":"mail@fmalcher.de","published":"2022-05-29T00:00:00.000Z","lastModified":"2022-06-02T00:00:00.000Z","keywords":["Angular","Angular 14","NgModule","Standalone Features","Standalone Components","Standalone Pipes","Standalone Directives"],"language":"de","header":{"url":"standalone.jpg","width":2000,"height":1095},"hidden":false,"sticky":false,"darkenHeader":false}}
