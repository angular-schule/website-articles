{"slug":"2025-10-rx-resource-is-broken","html":"<p>Angular ships with three Resource APIs for declarative async data loading: <code>resource()</code>, <code>rxResource()</code>, and <code>httpResource()</code>.\nThey&#39;re powerful additions to Angular&#39;s reactive toolkit, but they share a common foundation with some sharp edges.\nThis article examines three bugs in the shared core, supports them with source code, and shows how to fix each one.</p>\n<blockquote>\n<p><strong>Version note:</strong> This article targets <strong>Angular v20 docs</strong> and references unreleased <strong>Angular 21.0.x source</strong> for code examples.\nThe Resource APIs are <strong>experimental</strong> in v20.\nSource internals can change at any time.\nAlways prefer the documented contract (<a href=\"https://angular.dev/api/core/ResourceRef\"><code>ResourceRef</code></a>, <a href=\"https://angular.dev/api/core/ResourceStatus\"><code>ResourceStatus</code></a>) over internal classes.</p>\n</blockquote>\n<h2 id=\"why-this-article-uses-rxresource-examples\">Why This Article Uses rxResource Examples</h2>\n<p>Before we dive into the bugs, a quick note: This article is relevant for all three Resource APIs, because they share the same foundation and most of the same bugs.\nWe&#39;ll use <code>rxResource</code> for our examples because it&#39;s particularly useful for existing codebases:</p>\n<h3 id=\"you-have-existing-observable-based-services\">You Have Existing Observable-Based Services</h3>\n<p>If you&#39;re like me, your Angular app is built on Angular&#39;s <code>HttpClient</code>, which returns Observables, uses RxJS operators for data transformation, and has an existing service layer that returns <code>Observable&lt;T&gt;</code>.\nIn my case, I generate these services from OpenAPI specifications using the <a href=\"https://angular.schule/blog/2025-06-openapi-generator\">OpenAPI Generator</a>, which provides full type safety and uses Angular&#39;s HttpClient.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Your existing services might look like this:</span>\n<span class=\"hljs-meta\">@Injectable({ provideIn: <span class=\"hljs-string\">&#x27;root&#x27;</span> })</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookService</span> {\n\n  http = inject(HttpClient);\n\n  getBooks(search: string): Observable&lt;Book[]&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.http.<span class=\"hljs-keyword\">get</span>&lt;Book[]&gt;(`https:<span class=\"hljs-comment\">//api6.angular-buch.com/api/books?search=${search}`);</span>\n  }\n}\n</code></pre><p>This is exactly why <code>rxResource</code> exists.\nIt bridges existing Observable services to Angular&#39;s new signal-based reactivity.\nThe alternative would be to rewrite all generated services to return Promises or manually wrapping everything in <code>toSignal()</code>.</p>\n<p><code>rxResource</code> is perfect for this!\nIt lets you use these existing Observables directly:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">readonly</span> booksResource = <span class=\"hljs-title function_\">rxResource</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">search</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">searchTerm</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBooks</span>(params.<span class=\"hljs-property\">search</span>) <span class=\"hljs-comment\">// ‚Üê Your existing service!</span>\n});\n</code></pre><h3 id=\"understanding-the-three-resource-apis\">Understanding the Three Resource APIs</h3>\n<p>Angular provides three Resource APIs that accept different data sources but share the same foundation:</p>\n<p><strong><code>resource()</code>: For Promise-based data loading</strong>\nWorks with <code>fetch()</code> or any function that returns Promises.\nIf you&#39;re already using Promises in your services, this API provides a clean interface.</p>\n<p><strong><code>rxResource()</code>: For Observable-based services</strong>\nThe only Resource API that works with Observables.\nIt&#39;s aimed at existing codebases built on Angular&#39;s <code>HttpClient</code>.\nThis aligns with many existing Angular applications that use Observable-based service layers.\n<code>rxResource()</code> was added in <strong>v19</strong> to bridge Observables into the Resource model.\nFor HTTP, consider <code>httpResource()</code> first.</p>\n<p><strong><code>httpResource()</code>: For direct HTTP requests</strong>\nExperimental since Angular <strong>19.2</strong>.\nIf you pass a <strong>URL function</strong>, it performs a GET.\nIf you pass a <strong>request function</strong>, you can specify any HTTP method and other request options.\nReturns an <code>HttpResourceRef</code> which, in addition to <code>value/status/error/isLoading</code>, exposes <strong><code>headers</code></strong>, <strong><code>statusCode</code></strong>, and <strong><code>progress</code></strong> signals for HTTP-specific reactivity.</p>\n<p>Since all three APIs share the same core foundation, they exhibit (nearly) the same bugs in state management, error handling, and reload behavior.\nThis article uses <code>rxResource()</code> examples because it&#39;s the most relevant for existing projects with Observable-based services.</p>\n<p><strong>TL;DR: If you have existing Observable services (which is very likely), you need <code>rxResource()</code>, but you also need the fixes we&#39;re about to discuss!</strong></p>\n<h2 id=\"what-is-rxresource\">What is rxResource?</h2>\n<p><code>rxResource</code> is Angular&#39;s experimental API for declarative async data loading with Observables:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">const</span> booksResource = <span class=\"hljs-title function_\">rxResource</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">search</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">searchTerm</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBooks</span>(params.<span class=\"hljs-property\">search</span>)\n});\n</code></pre><pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- In template (simplified, no error handling here) --&gt;</span>\n@if (booksResource.hasValue()) {\n  @for (book of booksResource.value(); track book.isbn) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">article</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">article</span>&gt;</span>\n  }\n}</span>\n</code></pre><p>It&#39;s supposed to handle automatic loading when params change, loading state management, error handling, and manual reload capability.\nSounds great, right?\n<strong>And it IS great when it works!</strong></p>\n<h2 id=\"all-three-resource-apis-share-the-same-foundation\">All Three Resource APIs Share the Same Foundation</h2>\n<p>Before we dive into the bugs, it&#39;s important to understand that <strong>all three Resource APIs conform to the same Resource contract and state model</strong> (<code>value</code>, <code>status</code>, <code>error</code>, <code>isLoading</code>, <code>hasValue</code>).</p>\n<p>These are factory functions that instantiate and return internal implementation classes:</p>\n<ul>\n<li><code>resource()</code> in <code>@angular/core</code> returns <code>ResourceImpl</code> instances</li>\n<li><code>rxResource()</code> in <code>@angular/core/rxjs-interop</code> delegates to <code>resource()</code> and returns the same <code>ResourceImpl</code> instances</li>\n<li><code>httpResource()</code> in <code>@angular/common/http</code> returns <code>HttpResourceImpl</code> instances which extend <code>ResourceImpl</code></li>\n</ul>\n<p>The public contract is defined by the <code>ResourceRef&lt;T&gt;</code> and <code>HttpResourceRef&lt;T&gt;</code> interfaces.\nThe implementation classes (<code>ResourceImpl</code>, <code>HttpResourceImpl</code>) are internal details that could theoretically change at any time.\nSince all these APIs are experimental, there&#39;s no guarantee that internal implementations, or even public behaviors, will remain stable between versions.\nIt&#39;s safer to code against the documented contract than to rely on implementation specifics.\n(Which is precisely what we&#39;ll be examining in this article, so be prepared for changes in future versions.)\nAs a result, most state-handling behaviors are shared, but a few gotchas (especially around HTTP errors) differ for <code>httpResource()</code>.</p>\n<p>Let me show you the source code evidence:</p>\n<p><strong><code>resource()</code> factory function instantiates <code>ResourceImpl</code>:</strong></p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// packages/core/src/resource/resource.ts, line 65</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">resource</span>&lt;<span class=\"hljs-title function_\">T</span>, <span class=\"hljs-title function_\">R</span>&gt;(<span class=\"hljs-params\">options: ResourceOptions&lt;T, R&gt;</span>): <span class=\"hljs-title function_\">ResourceRef</span>&lt;<span class=\"hljs-title function_\">T</span> | <span class=\"hljs-title function_\">undefined</span>&gt; {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ResourceImpl&lt;T | <span class=\"hljs-literal\">undefined</span>, R&gt;(\n    params,\n    getLoader(options),\n    options.<span class=\"hljs-built_in\">defaultValue</span>,\n    <span class=\"hljs-comment\">// ...</span>\n  );\n}\n</code></pre><p><a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L65-L81\">View source</a></p>\n<p><strong><code>rxResource()</code> factory function delegates to <code>resource()</code>:</strong></p>\n<pre><code class=\"language-typescript\">// packages/core/rxjs-interop/src/rx_resource.ts, line 54\nexport function rxResource&lt;T, R&gt;(opts: RxResourceOptions&lt;T, R&gt;): ResourceRef&lt;T | undefined&gt; {\n  // ...\n <span class=\"hljs-built_in\"> return </span>resource&lt;T, R&gt;({  // ‚Üê Calls resource(), returns ResourceImpl<span class=\"hljs-built_in\"> instance\n</span><span class=\"hljs-keyword\">    .</span>..opts,\n    stream: (params) =&gt; {\n      // Observable ‚Üí Promise wrapper\n    },\n  });\n}\n</code></pre><p><a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/rxjs-interop/src/rx_resource.ts#L54-L106\">View source</a></p>\n<p><strong><code>httpResource()</code> factory function instantiates <code>HttpResourceImpl</code>:</strong></p>\n<p>The <code>httpResource</code> factory is implemented using <code>makeHttpResourceFn</code>, which instantiates <code>HttpResourceImpl</code>.\nThis is an internal class that extends <code>ResourceImpl</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// packages/common/http/src/resource.ts, line 237</span>\n<span class=\"hljs-keyword\">return</span> new HttpResourceImpl(\n  injector,\n  () =&gt; normalizeRequest(request, responseType),\n  options?.defaultValue,\n  <span class=\"hljs-comment\">// ...</span>\n) as HttpResourceRef&lt;TResult&gt;;\n\n<span class=\"hljs-comment\">// packages/common/http/src/resource.ts, line 298 (internal implementation class)</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">HttpResourceImpl</span>&lt;<span class=\"hljs-symbol\">T</span>&gt;\n  <span class=\"hljs-symbol\">extends</span> <span class=\"hljs-symbol\">ResourceImpl</span>&lt;<span class=\"hljs-symbol\">T, <span class=\"hljs-symbol\">HttpRequest</span></span>&lt;<span class=\"hljs-symbol\">unknown</span>&gt; | <span class=\"hljs-symbol\">undefined</span>&gt;\n  <span class=\"hljs-symbol\">implements</span> <span class=\"hljs-symbol\">HttpResourceRef</span>&lt;<span class=\"hljs-symbol\">T</span>&gt;\n{\n  <span class=\"hljs-comment\">// Adds HTTP-specific signals: headers, progress, statusCode</span>\n  <span class=\"hljs-comment\">// Inherits core state management from ResourceImpl</span>\n}\n</code></pre><p><a href=\"https://github.com/angular/angular/blob/21.0.x/packages/common/http/src/resource.ts#L228-L244\">View source (factory)</a> | <a href=\"https://github.com/angular/angular/blob/21.0.x/packages/common/http/src/resource.ts#L297-L298\">View source (class)</a></p>\n<p><strong>What This Means:</strong></p>\n<p>All three APIs conform to the documented <a href=\"https://angular.dev/api/core/ResourceRef\"><code>ResourceRef</code></a> contract and <a href=\"https://angular.dev/api/core/ResourceStatus\"><code>ResourceStatus</code></a> semantics:</p>\n<ul>\n<li>State management (loading, resolved, error, idle, reloading)</li>\n<li>Parameter reactivity</li>\n<li>The <code>reload()</code> method</li>\n<li>Value/error signals</li>\n</ul>\n<p>The differences between the APIs are in their input types and additional features:</p>\n<ul>\n<li><a href=\"https://angular.dev/api/core/resource\"><code>resource()</code></a> works with Promises. It&#39;s also the most basic and direct way to get a resource via a public API.</li>\n<li><a href=\"https://angular.dev/api/core/rxjs-interop/rxResource\"><code>rxResource()</code></a> works with Observables.</li>\n<li><a href=\"https://angular.dev/api/common/http/httpResource\"><code>httpResource()</code></a> is built for HTTP requests and adds HTTP-specific signals (headers, progress, statusCode) and HTTP-specific error handling.</li>\n</ul>\n<p>This is why most of the bugs we&#39;ll discuss affect all three APIs.\nThey originate from the shared foundation.\nHowever, <code>httpResource()</code> has HTTP-specific behavior that avoids one of these issues.</p>\n<h2 id=\"the-3-bugs-we-need-to-fix\">The 3 Bugs We Need to Fix</h2>\n<p>These aren&#39;t showstoppers if you know about them, but they can cause serious UX problems in production.\nBecause the Resource APIs share a common foundation, <strong>most of the bugs</strong> affect <code>resource()</code>, <code>rxResource()</code>, and <code>httpResource()</code>, though <code>httpResource()</code> handles one case differently (error handling).\nLet&#39;s understand what&#39;s happening and how to fix each one:</p>\n<h3 id=\"bug-1-value-resets-when-parameters-change-causes-flickering--scroll-jumping\">Bug #1: Value Resets When Parameters Change (Causes Flickering &amp; Scroll Jumping)</h3>\n<p><strong>Affects</strong>: <code>resource()</code>, <code>rxResource()</code>, and <code>httpResource()</code> (all share the same foundation)</p>\n<p><strong>GitHub Issue</strong>: <a href=\"https://github.com/angular/angular/issues/58602\">#58602</a></p>\n<p><strong>What Should Happen (in my opinion):</strong></p>\n<p>When you change parameters, the previous data should remain visible while new data is being fetched.\nThis prevents the UI from collapsing and keeps users oriented on the page.\nThe loading state should indicate that fresh data is being loaded, but the existing content should stay visible until the new data arrives.</p>\n<p><strong>What Actually Happens</strong>:</p>\n<p>Imagine the previous example (<code>booksResource</code>) with a long list of books displayed on the page.\nWhen a user changes the search parameter (e.g., from &quot;Angular&quot; to &quot;TypeScript&quot;), the following sequence occurs:\nFirst, <code>value()</code> becomes <code>undefined</code> (making <code>hasValue()</code> return <code>false</code>).\nThen your <code>@for</code> loop has no books to iterate over, so all book cards disappear.\nThe DOM collapses, causing the page height to shrink and the scroll position to jump.\nAfter a short time, new books arrive from the API.\nFinally, the book cards reappear, but the user is disoriented by the flickering and unexpected scroll position.</p>\n<p><strong>This behavior is by design</strong>: <code>loading</code> (params changed) clears the value, while <code>reloading</code> (manual reload) preserves it.\nThis is documented in the official <a href=\"https://angular.dev/api/core/ResourceStatus\"><code>ResourceStatus</code> semantics</a>:</p>\n<blockquote>\n<ul>\n<li><code>loading</code> - The resource is currently loading a new value as a result of a change in its reactive dependencies. <code>value()</code> will be <code>undefined</code>.</li>\n<li><code>reloading</code> - The resource is currently reloading a fresh value for the same reactive dependencies. <code>value()</code> will continue to return the previously fetched value during the reloading operation.</li>\n</ul>\n</blockquote>\n<p>However, whether this is the right default behavior remains debatable.\nMatthieu Riegler from the Angular team <a href=\"https://github.com/angular/angular/issues/58602#issuecomment-2500212775\">commented on the issue</a> saying:</p>\n<blockquote>\n<p>&quot;We discussed that topic yesterday and we see a value (pun intended) in keeping the value while reloading. [...] One of the question that arose from the discussion was, what usecase could take an advantage of setting the value to <code>undefined</code> while reloading?&quot;</p>\n</blockquote>\n<p>It seems that a final decision hasn&#39;t been made.\nBug or feature?\nI don&#39;t know, but it&#39;s <strong>super annoying</strong>.</p>\n<p><strong>What Would Be Ideal</strong>:\nEven if the current default behavior is kept (resetting to <code>undefined</code>), this should at least be configurable.\nAn optional setting like <code>keepValueOnReload: true</code> would let developers choose the behavior that fits their use case.\nSome scenarios might benefit from clearing the value, but stable, non-flickering UIs are generally preferred, in my opinion.\nMaking this configurable would satisfy both camps without breaking existing code.</p>\n<p><strong>Built-in Mitigations</strong>:</p>\n<p>But right now the situation is not ideal.\nIf you want to keep showing the previous value during a parameter change, you have several options:</p>\n<p><strong>1. Provide a <code>defaultValue</code> (static fallback):</strong></p>\n<p>The simplest approach is to provide a default value that shows an empty array or placeholder items during loading:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">const</span> booksResource = <span class=\"hljs-title function_\">rxResource</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">search</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">searchTerm</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBooks</span>(params.<span class=\"hljs-property\">search</span>),\n  <span class=\"hljs-attr\">defaultValue</span>: []\n});\n</code></pre><p>This can be an effective mitigation when your design uses a fixed page size.\nBy populating the default value with placeholder items (perhaps skeleton loaders), the page maintains consistent height and doesn&#39;t jump during transitions.\nOf course, this only works if your design supports this pattern.</p>\n<p><strong>2. Simple linkedSignal pattern (always keep previous value):</strong></p>\n<p>You can use <code>linkedSignal</code> to automatically preserve the previous value whenever the source becomes undefined:</p>\n<pre><code class=\"language-typescript\">const stableBooks = linkedSignal&lt;Book[] | <span class=\"hljs-literal\">undefined</span>&gt;({\n  source: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> booksResource.value(),\n  computation: <span class=\"hljs-function\"><span class=\"hljs-params\">(source, previous)</span> =&gt;</span> source ?? previous?.value\n});\n</code></pre><p>This is simpler but means stale data remains visible during error states.\nI recommend using <code>hasValue()</code> or <code>error()</code> guards in the template to handle those cases explicitly.</p>\n<p><strong>3. Status-gated pattern (clear on error immediately):</strong></p>\n<p>For better error handling, you can also keep old data only during loading while clearing it immediately on error:</p>\n<pre><code class=\"language-typescript\">const stableBooks = linkedSignal({\n  source: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> ({ v: booksResource.value(), s: booksResource.status() }),\n  computation: <span class=\"hljs-function\"><span class=\"hljs-params\">(src, prev)</span> =&gt;</span> src.s === <span class=\"hljs-string\">&#x27;loading&#x27;</span> ? prev?.v : src.v\n});\n</code></pre><p>This prevents stale data from masking error states.\n<code>stableBooks</code> becomes <code>undefined</code> immediately on error, which makes error detection straightforward.</p>\n<p><strong>4. Status-driven pattern with hybrid clearing (used in the final version):</strong></p>\n<p>The most robust approach uses status-based tracking to provide a hybrid behavior.\nThis pattern clears the value on error while preserving data during loading:</p>\n<pre><code class=\"language-typescript\">const stableBooks = linkedSignal({\n  source: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> booksResource.status(),\n  computation: <span class=\"hljs-function\"><span class=\"hljs-params\">(status, previous)</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (status === <span class=\"hljs-string\">&#x27;error&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;\n    <span class=\"hljs-keyword\">if</span> (status === <span class=\"hljs-string\">&#x27;loading&#x27;</span>) <span class=\"hljs-keyword\">return</span> previous?.value ?? booksResource.value();\n    <span class=\"hljs-keyword\">return</span> booksResource.value();\n  }\n});\n</code></pre><p>You might have noticed that this pattern uses the advanced API of <code>linkedSignal</code>.\nIt uses separate <code>source</code> and <code>computation</code> properties.\nThis is necessary for correct dependency tracking.\nWe track <code>status()</code> changes in <code>source</code>, which triggers recomputation.\nSignals read inside <code>computation</code> are not tracked and won&#39;t trigger updates.</p>\n<p>The advanced API also provides <code>previous.value</code> in the computation function.\nThis lets us preserve stale data during loading.\nFinally, we can implement hybrid clearing logic that clears on error while preserving data during loading.\nIt also respects <code>defaultValue</code> during initial loads.\nThis is the pattern used in <code>rxResourceFixed</code> (see below).</p>\n<blockquote>\n<p><strong>‚úÖ Edit (January 2025):</strong> Great news! The Angular team listened to community feedback and <strong>fixed this issue</strong> in <a href=\"https://github.com/angular/angular/pull/62111\">PR #62111</a>, merged into Angular 21.0.x.\nThe fix introduces an <code>isErrorLike()</code> check that recognizes objects implementing the <code>Error</code> interface (like <code>HttpErrorResponse</code>), not just classes that inherit from <code>Error</code>.\n<code>HttpErrorResponse</code> now passes through unwrapped, making error handling consistent across all Resource APIs.\nThank you, Matthieu Riegler and the Angular team! üéâ</p>\n<p>The section below is kept for historical context and for developers on older Angular versions.</p>\n</blockquote>\n<h3 id=\"bug-2-httperrorresponse-gets-wrapped-in-resourcewrappederror-resourcerxresource\"><del>Bug #2: HttpErrorResponse Gets Wrapped in ResourceWrappedError (resource/rxResource)</del></h3>\n<p><strong>Affects</strong>: <code>resource()</code> and <code>rxResource()</code>. <code>httpResource()</code> is typically not affected.</p>\n<p><strong>GitHub Issue</strong>: <a href=\"https://github.com/angular/angular/issues/61861\">#61861</a></p>\n<p><strong>Regression</strong>: Introduced in <a href=\"https://github.com/angular/angular/pull/61441\">PR #61441</a> (<a href=\"https://github.com/angular/angular/commit/9045e229c2899ee910ff6ce41fa822f2af5f88bf\">Commit 9045e22</a>)</p>\n<p><strong>Fix</strong>: <a href=\"https://github.com/angular/angular/pull/62111\">PR #62111</a> (merged December 2025, available in Angular 21.0.x)</p>\n<p><strong>What Should Happen</strong>:</p>\n<p>When an HTTP error occurs, you want to check the error and display appropriate messages to your users.\nThe error details should be directly accessible so you can show helpful information like status codes or error messages.</p>\n<p><strong>What Actually Happens</strong>:</p>\n<p>Let&#39;s look at a simpler example that focuses on the error handling issue.\nUnlike Bug #1 (which focuses on lists disappearing), this bug affects any HTTP request when an error occurs.\nHere we&#39;re fetching a single book to keep the example focused:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">readonly</span> bookResource = <span class=\"hljs-title function_\">rxResource</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">selectedIsbn</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBook</span>(params.<span class=\"hljs-property\">isbn</span>)\n});\n</code></pre><p>When the HTTP request fails with an error, the following happens:\nFirst, the resource (in this example created via <code>rxResource</code>, but <code>resource()</code> behaves identically) receives the <a href=\"https://angular.dev/api/common/http/HttpErrorResponse\"><code>HttpErrorResponse</code></a> from Angular&#39;s <a href=\"https://angular.dev/api/common/http/HttpClient\"><code>HttpClient</code></a>.\nThen it checks if the error is an instance of the native <code>Error</code> class using <code>error instanceof Error</code>.\nThis seems simple, but it isn&#39;t!\nThis check is too narrow because it only recognizes classes that inherit from <code>Error</code>, not objects that implement the <code>Error</code> interface.\nUnfortunately, <code>HttpErrorResponse</code> does not inherit from <code>Error</code>.\nIt only implements the <code>Error</code> interface!\nAs a result, the resource wraps it in a <code>ResourceWrappedError</code>.\nThe message is unhelpful:</p>\n<blockquote>\n<p>&quot;Resource returned an error that&#39;s not an Error instance: [object Object]. Check this error&#39;s .cause for the actual error.&quot;</p>\n</blockquote>\n<p>To access the actual HTTP status code, statusText, or URL, you must dig into the <code>cause</code> property: <code>bookResource.error().cause.status</code>.\nThis makes error handling cumbersome when working with HTTP errors.\nWhat&#39;s particularly annoying is that other errors that inherit from <code>Error</code> are not wrapped at all, creating inconsistent error handling patterns across your application.</p>\n<p>This wrapping behavior was introduced in <a href=\"https://github.com/angular/angular/pull/61441\">PR #61441</a> (<a href=\"https://github.com/angular/angular/commit/9045e229c2899ee910ff6ce41fa822f2af5f88bf\">commit 9045e22</a>) via the shared <code>encapsulateResourceError()</code> function, which affects both <code>resource</code> and <code>rxResource</code>:</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">encapsulateResourceError</span>(<span class=\"hljs-built_in\">error</span>: unknown): <span class=\"hljs-built_in\">Error</span> {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">error</span> instanceof <span class=\"hljs-built_in\">Error</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">error</span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ResourceWrappedError(<span class=\"hljs-built_in\">error</span>);\n}\n</code></pre><p><strong>Note about <code>httpResource()</code></strong>: <code>httpResource()</code> passes errors through unwrapped (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/common/http/src/resource.ts#L366-L374\">source code line 372</a>), thus avoiding this issue entirely.\nInstances of <code>HttpErrorResponse</code> are even handled to set headers and the status code.\nOnly errors thrown by the optional <code>parse</code> function get wrapped (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/common/http/src/resource.ts#L355-L359\">source code line 358</a>), but here the wrapping makes sense.</p>\n<blockquote>\n<p><strong>üí° Workaround</strong>: If you&#39;re making HTTP requests, consider using <code>httpResource()</code> instead of wrapping <code>HttpClient</code> with <code>rxResource()</code>.\nIn practice, <code>httpResource()</code> typically surfaces <code>HttpErrorResponse</code> directly, making error handling simpler.</p>\n</blockquote>\n<p><strong>Important Note</strong>: Accessing <code>value()</code> while the resource is in an error state causes an exception.\nThis is by design.\n<strong>Always use <code>hasValue()</code> to guard <code>value()</code> reads</strong> (<a href=\"https://angular.dev/guide/http/http-resource\">Angular docs recommendation</a>).\nThe <code>hasValue()</code> method safely checks both error state and value existence.\nSo for your reference, here is a recommended pattern to follow:</p>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- In template --&gt;</span>\n@if (bookResource.hasValue()) {\n  @let book = bookResource.value()!;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">article</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">article</span>&gt;</span>\n} @else if (bookResource.error()) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;alert&quot;</span>&gt;</span>Error loading books<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n} @else if (bookResource.isLoading()) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Loading books...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n}</span>\n</code></pre><blockquote>\n<p><strong>TL;DR</strong>: The <code>error()</code> signal is typed as <a href=\"https://angular.dev/api/core/ResourceRef\"><code>Signal&lt;Error | undefined&gt;</code></a>.\nIf your underlying data source uses Angular&#39;s <code>HttpClient</code>, errors will be <code>HttpErrorResponse</code> instances.\nBut with <code>rxResource</code> and <code>resource()</code>, <code>HttpErrorResponse</code> gets wrapped in <code>ResourceWrappedError</code>, accessible via <code>cause</code>.\nWith <code>httpResource()</code> (which is built on top of <code>HttpClient</code>), you get <code>HttpErrorResponse</code> directly unwrapped.\nNote that other HTTP sources like <code>fetch()</code> produce different error types.\nFor <code>HttpClient</code>-based errors, we can safely narrow with <code>instanceof HttpErrorResponse</code> to access HTTP-specific properties:</p>\n</blockquote>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpErrorResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n\n<span class=\"hljs-comment\">// With rxResource - error is wrapped</span>\n<span class=\"hljs-keyword\">const</span> bookResource1 = <span class=\"hljs-title function_\">rxResource</span>(<span class=\"hljs-comment\">/* [...] */</span>);\n<span class=\"hljs-keyword\">const</span> err1 = bookResource1.<span class=\"hljs-title function_\">error</span>();\n\n<span class=\"hljs-keyword\">if</span> (err1?.<span class=\"hljs-property\">cause</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HttpErrorResponse</span>) {\n  <span class=\"hljs-comment\">// Access via .cause for wrapped errors</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err1.<span class=\"hljs-property\">cause</span>.<span class=\"hljs-property\">status</span>);      <span class=\"hljs-comment\">// e.g., 404</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err1.<span class=\"hljs-property\">cause</span>.<span class=\"hljs-property\">statusText</span>);  <span class=\"hljs-comment\">// e.g., &quot;Not Found&quot;</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err1.<span class=\"hljs-property\">cause</span>.<span class=\"hljs-property\">url</span>);         <span class=\"hljs-comment\">// e.g., &quot;/books/123&quot;</span>\n}\n\n<span class=\"hljs-comment\">// With httpResource - error is unwrapped</span>\n<span class=\"hljs-keyword\">const</span> bookResource2 = <span class=\"hljs-title function_\">httpResource</span>(<span class=\"hljs-comment\">/* [...] */</span>);\n<span class=\"hljs-keyword\">const</span> err2 = bookResource2.<span class=\"hljs-title function_\">error</span>();\n\n<span class=\"hljs-keyword\">if</span> (err2 <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HttpErrorResponse</span>) {\n  <span class=\"hljs-comment\">// Access directly for unwrapped errors</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err2.<span class=\"hljs-property\">status</span>);      <span class=\"hljs-comment\">// e.g., 404</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err2.<span class=\"hljs-property\">statusText</span>);  <span class=\"hljs-comment\">// e.g., &quot;Not Found&quot;</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err2.<span class=\"hljs-property\">url</span>);         <span class=\"hljs-comment\">// e.g., &quot;/books/123&quot;</span>\n}\n</code></pre><p>It&#39;s easy to see how this becomes confusing.</p>\n<blockquote>\n<p><strong>‚úÖ Edit (January 2025):</strong> With Angular 21.0.x and later, this confusion is resolved! All Resource APIs now return <code>HttpErrorResponse</code> directly unwrapped. The code example above showing <code>.cause</code> access is only needed for Angular versions before 21.0.x. Note: The <code>rethrowHttpResourceError()</code> operator in <code>rxResourceFixed</code> is still useful if you want to customize the error message (e.g., &quot;HTTP Error 404: Not Found&quot; instead of the raw <code>HttpErrorResponse</code>).</p>\n</blockquote>\n<h3 id=\"bug-3-reload-doesnt-clear-error-state-immediately\">Bug #3: reload() Doesn&#39;t Clear Error State Immediately</h3>\n<p><strong>Affects</strong>: <code>resource()</code>, <code>rxResource()</code>, and <code>httpResource()</code> (all share the same <code>reload()</code> behavior)</p>\n<!-- **GitHub Issue**: No dedicated issue found for this specific behavior (as of January 2025) -->\n\n<p><strong>What Should Happen (in my opinion):</strong></p>\n<p>When a resource is in error state and you call <code>reload()</code>, the error should clear immediately.\nThis gives users visual feedback that their reload action was received and the system is now attempting to recover.</p>\n<p>However, no official Angular documentation explicitly covers how a resource&#39;s error state is handled during a reload.\nThe Angular docs describe how <code>value()</code> behaves, but say nothing about the <code>error()</code> signal or clearing errors when reloading.</p>\n<p><strong>What Actually Happens</strong>:</p>\n<p>When you call <code>reload()</code> on a failed request, the error message stays visible throughout the entire attempt, which creates a confusing user experience.</p>\n<p>Here&#39;s what happens with the following resource when you reload after an error. This is the same example as before:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">readonly</span> bookResource = <span class=\"hljs-title function_\">rxResource</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isbn</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBook</span>(params.<span class=\"hljs-property\">isbn</span>)\n});\n</code></pre><p><strong>Starting Point - Resource in Error State:</strong>\nThe resource is in error state.\nThe <code>error()</code> signal returns an error object (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L261-L264\">source code line 262-263</a> computes error from the stream).\nAttempting to read <code>value()</code> throws a <code>ResourceValueError</code> exception (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L198-L204\">source code line 199-200</a>).\nNote: There&#39;s an internal flag to control this throwing behavior (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L33-L38\">line 38</a>), but it&#39;s not exposed as a public option and defaults to throwing in v21.</p>\n<p><strong>User Clicks &quot;Reload&quot;:</strong>\nThe application calls <code>bookResource.reload()</code> on the failed request.\nThe <code>reload()</code> method increments the reload counter (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L300-L310\">source code line 308</a>), which triggers the loading effect.</p>\n<p><strong>DURING Reload - The Inconvenient Behavior (or Bug?):</strong>\nWhile the new request is in flight, <code>isLoading()</code> correctly returns <code>true</code>.\nHowever, the <code>error()</code> signal <strong>still returns the previous error</strong> throughout the entire reload operation.\nThis happens because the error is only cleared when the stream provides new data (see next phase).\nThe old error remains visible in the UI, creating a confusing experience where users see alarming red error messages even though they&#39;ve already clicked &quot;Reload&quot; and the system is attempting recovery.</p>\n<p><strong>After Successful Response:</strong>\nOnly after the new request completes successfully does the error clear.\nThe state transitions to <code>resolved</code> (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L381-L386\">source code line 383-385</a>), which causes <code>error()</code> to return <code>undefined</code>, and <code>value()</code> becomes accessible again.</p>\n<p><strong>Why This Behavior Is Inconsistent</strong>:</p>\n<p>The confusing part is that resources handle error clearing differently.\nIt depends on how you trigger a new request.\nWhen you <strong>change parameters</strong> to request different data, the error state clears immediately (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L238-L243\">source code lines 238-243</a>).\nThe moment your parameters change, the old error disappears and the UI shows a clean loading state.\nThis makes sense since you&#39;re requesting something new, so the old error no longer applies.\nBut when you call <strong><code>reload()</code></strong> on the same request, the old error remains visible during the entire fetch operation and only disappears after the new response successfully arrives.\nThis inconsistency creates a confusing UX where users click &quot;Reload&quot; but still see alarming red error messages during the reload attempt.\nThey&#39;ve already taken action, yet the UI suggests the problem still exists.</p>\n<p>By the way, the <code>reload()</code> method has another intentional behavior that can cause problems.\nWhen the status is <code>loading</code> (a params-driven load is in progress), calling <code>reload()</code> is actively prohibited and simply returns <code>false</code> without doing anything (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L303-L306\">source code lines 303-306</a>).\nThe resource is basically saying &quot;No!&quot; to your reload command and simply returns false.\nI think this is pretty harsh!\nThe comment in the source code states: &quot;We don&#39;t want to restart in-progress loads.&quot;\nInterestingly, this prohibition only applies to <code>loading</code> status (and <code>idle</code>), but not to <code>reloading</code> status.\nThis means you CAN call <code>reload()</code> again while a manual reload is already in progress, but you CANNOT interrupt a params-driven load with <code>reload()</code>.\nWhile this distinction might seem reasonable at first, it creates confusing UX: if parameters change and trigger a slow load, users cannot click &quot;Reload&quot; to cancel and restart.\nNothing happens, so the button appears broken.\nThis is inconsistent because parameter changes themselves abort any in-progress request and start fresh.\nThe final solution (<code>rxResourceFixed</code>) bypasses this limitation by forcing a parameter change, which consistently aborts any in-progress request and starts a new one.\nThis was also the reason to take the brute force approach in the final solution.\nThe <code>reload()</code> method is simply not doing what I need it to do.\nOther possible solutions would still interfere with this intentional behavior.\nI&#39;m sorry, Angular team! üòÖ</p>\n<h2 id=\"the-solution-rxresourcefixed-it-actually-works\">The Solution: rxResourceFixed (It Actually Works!)</h2>\n<p>The good news? <strong>All three bugs are fixable with simple patterns!</strong>\nI have built <code>rxResourceFixed</code> that wraps <code>rxResource</code> with the fixes we need.\nIt&#39;s a 100% drop-in replacement for <code>rxResource()</code> and returns the standard <code>ResourceRef&lt;T&gt;</code> interface.\nYou don&#39;t have to wait for Angular to fix these.\nYou can use this today:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { rxResourceFixed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./rx-resource-fixed&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> booksResource = <span class=\"hljs-title function_\">rxResourceFixed</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">search</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">searchTerm</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBooks</span>(params.<span class=\"hljs-property\">search</span>)\n});\n</code></pre><h3 id=\"what-rxresourcefixed-does-differently\">What rxResourceFixed Does Differently</h3>\n<ol>\n<li><p>It preserves previous data when parameters change using <code>linkedSignal</code>.\n  The old value stays in memory until new data arrives from the API.\n  This prevents DOM collapse and eliminates the flickering problem.\n  Users see a smooth transition from old data to new data without any jarring jumps or empty states.\n  Note: When an error occurs, the value is cleared immediately (becomes undefined).\n  This ensures error states are clearly visible and not masked by stale data.\n  Combine with <code>hasValue()</code> and <code>error()</code> guards in your template to handle both loading and error states appropriately.</p>\n</li>\n<li><p>It auto-applies proper error handling with a simple operator that I called <code>rethrowHttpResourceError</code>.\n  The <code>HttpErrorResponse</code> from Angular&#39;s HTTP client is properly converted to a standard <code>Error</code> object with a clean, readable message (e.g., &quot;HTTP 500: Internal Server Error&quot;).\n  The error is accessible via <code>resource.error()</code> with HTTP status codes and details directly in the message.\n  You no longer need to dig into <code>.cause</code>.\n  The original <code>HttpErrorResponse</code> is still preserved in <code>error.cause</code> if you need the raw response object.</p>\n</li>\n<li><p>It provides a reliable reload that clears the error state immediately.\n  The implementation internally uses a <code>refreshKey</code> signal to force parameter re-evaluation.\n  This triggers the same state management path as parameter changes, which clears the error state immediately before fetching.\n  This gives users clear visual feedback when they reload after an error, without alarming red messages persisting during the reload.\n  <strong>Trade-off</strong>: Bumping an internal <code>refreshKey</code> forces a <strong>parameter change</strong>, so the <code>status()</code> will be <code>loading</code> (not <code>reloading</code>).\n  While the status differs, <code>isLoading()</code> behaves the same because it returns <code>true</code> for both <code>loading</code> and <code>reloading</code> states (<a href=\"https://github.com/angular/angular/blob/21.0.x/packages/core/src/resource/resource.ts#L129\">source code line 129</a>).</p>\n</li>\n</ol>\n<h2 id=\"live-demo\">Live Demo</h2>\n<p>I&#39;ve created a demo project that proves each bug and shows that <code>rxResourceFixed</code> works as expected.\nCheck out the <a href=\"https://angular-schule.github.io/2025-10-rx-resource-is-broken/\">demo</a> to see:</p>\n<p><a href=\"https://angular-schule.github.io/2025-10-rx-resource-is-broken/bug-1-value-reset\">üêõ <strong>Bug #1: Value Resets When Parameters Change</strong></a>: Side-by-side comparison showing rxResource flickering/scroll jumping<br><a href=\"https://angular-schule.github.io/2025-10-rx-resource-is-broken/bug-2-error-handling\">üêõ <strong>Bug #2: HttpErrorResponse Gets Wrapped</strong></a>: Error handling comparison<br><a href=\"https://angular-schule.github.io/2025-10-rx-resource-is-broken/bug-3-reload\">üêõ <strong>Bug #3: reload() Doesn&#39;t Clear Error State</strong></a>: Reload behavior comparison  </p>\n<p>‚ûî Of course, you can also <a href=\"https://github.com/angular-schule/2025-10-rx-resource-is-broken\"><strong>download the full source on GitHub</strong></a>.</p>\n<h2 id=\"how-to-use-rxresourcefixed-in-your-project\">How to Use <code>rxResourceFixed</code> in Your Project</h2>\n<h3 id=\"step-1-copy-the-utility\">Step 1: Copy the utility</h3>\n<p><a href=\"https://raw.githubusercontent.com/angular-schule/2025-10-rx-resource-is-broken/refs/heads/main/src/app/shared/rx-resource-fixed.ts\">Copy <code>rx-resource-fixed.ts</code></a> from the demo into your project, or copy and paste it directly from this snippet:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpErrorResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { linkedSignal, <span class=\"hljs-title class_\">ResourceRef</span>, <span class=\"hljs-title class_\">Signal</span>, signal, <span class=\"hljs-title class_\">WritableSignal</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { rxResource, <span class=\"hljs-title class_\">RxResourceOptions</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { catchError, <span class=\"hljs-title class_\">MonoTypeOperatorFunction</span>, throwError } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>;\n\n<span class=\"hljs-comment\">/**\n * A wrapper for rxResource that fixes three bugs:\n *\n * Bug #1: Value Resets When Parameters Change\n * Bug #2: HttpErrorResponse Gets Wrapped\n * Bug #3: reload() Doesn&#x27;t Clear Error State Immediately\n */</span>\n<span class=\"hljs-comment\">// Overload: with defaultValue ‚Üí ResourceRef&lt;T&gt; (value never undefined)</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> rxResourceFixed&lt;T, P = <span class=\"hljs-built_in\">void</span>&gt;(\n  <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">RxResourceOptions</span>&lt;T, P&gt; &amp; { <span class=\"hljs-attr\">defaultValue</span>: T }\n): <span class=\"hljs-title class_\">ResourceRef</span>&lt;T&gt;;\n\n<span class=\"hljs-comment\">// Overload: without defaultValue ‚Üí ResourceRef&lt;T | undefined&gt;</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> rxResourceFixed&lt;T, P = <span class=\"hljs-built_in\">void</span>&gt;(\n  <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">RxResourceOptions</span>&lt;T, P&gt;\n): <span class=\"hljs-title class_\">ResourceRef</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;;\n\n<span class=\"hljs-comment\">// Implementation</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> rxResourceFixed&lt;T, P = <span class=\"hljs-built_in\">void</span>&gt;(\n  <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">RxResourceOptions</span>&lt;T, P&gt;\n): <span class=\"hljs-title class_\">ResourceRef</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt; {\n  <span class=\"hljs-comment\">// Internal refresh key to fix Bug #3</span>\n  <span class=\"hljs-comment\">// When incremented, the params change triggers a new loading phase which also aborts any pending request</span>\n  <span class=\"hljs-keyword\">const</span> refreshKey = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-comment\">// Create underlying rxResource with auto-applied error handling (Bug #2 fix)</span>\n  <span class=\"hljs-comment\">// The refreshKey is included in params so that we can increment it (Bug #3 fix)</span>\n  <span class=\"hljs-comment\">// Spread options to preserve defaultValue, equal, and injector</span>\n  <span class=\"hljs-keyword\">const</span> resource = rxResource&lt;T, { <span class=\"hljs-attr\">userParams</span>: P; <span class=\"hljs-attr\">_refresh</span>: <span class=\"hljs-built_in\">number</span> }&gt;({\n    ...options, <span class=\"hljs-comment\">// Preserve all options (defaultValue, equal, injector)</span>\n    <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({\n      <span class=\"hljs-attr\">userParams</span>: options.<span class=\"hljs-property\">params</span>?.() ?? (<span class=\"hljs-literal\">undefined</span> <span class=\"hljs-keyword\">as</span> P),\n      <span class=\"hljs-attr\">_refresh</span>: <span class=\"hljs-title function_\">refreshKey</span>()\n    }),\n    <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">context</span>) =&gt;</span> {\n      <span class=\"hljs-comment\">// Pass user params, abortSignal, and previous status to the stream function</span>\n      <span class=\"hljs-keyword\">return</span> options.<span class=\"hljs-title function_\">stream</span>({\n        <span class=\"hljs-attr\">params</span>: context.<span class=\"hljs-property\">params</span>.<span class=\"hljs-property\">userParams</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Exclude</span>&lt;P, <span class=\"hljs-literal\">undefined</span>&gt;,\n        <span class=\"hljs-attr\">abortSignal</span>: context.<span class=\"hljs-property\">abortSignal</span>,\n        <span class=\"hljs-attr\">previous</span>: context.<span class=\"hljs-property\">previous</span>\n      }).<span class=\"hljs-title function_\">pipe</span>(\n        <span class=\"hljs-title function_\">rethrowHttpResourceError</span>() <span class=\"hljs-comment\">// Bug #2 fix: Convert HttpErrorResponse to Error</span>\n      );\n    }\n  });\n\n  <span class=\"hljs-comment\">// Create stable value signal using linkedSignal (Bug #1 fix)</span>\n  <span class=\"hljs-comment\">// Keeps previous value during params-driven loading and reloading from success.</span>\n  <span class=\"hljs-comment\">// Clears value on error (and therefore shows a clean slate on reload after error).</span>\n  <span class=\"hljs-keyword\">const</span> stableValue = <span class=\"hljs-title function_\">linkedSignal</span>({\n    <span class=\"hljs-attr\">source</span>: <span class=\"hljs-function\">() =&gt;</span> resource.<span class=\"hljs-title function_\">status</span>(),\n    <span class=\"hljs-attr\">computation</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">status</span>: <span class=\"hljs-title class_\">ReturnType</span>&lt;<span class=\"hljs-keyword\">typeof</span> resource.status&gt;, previous</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (status === <span class=\"hljs-string\">&#x27;error&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// clear on error</span>\n      }\n      <span class=\"hljs-keyword\">if</span> (status === <span class=\"hljs-string\">&#x27;loading&#x27;</span>) {\n        <span class=\"hljs-keyword\">return</span> previous?.<span class=\"hljs-property\">value</span> ?? resource.<span class=\"hljs-title function_\">value</span>(); <span class=\"hljs-comment\">// keep stale or use defaultValue</span>\n      }\n      <span class=\"hljs-comment\">// For resolved, reloading, local, idle: return current value</span>\n      <span class=\"hljs-keyword\">return</span> resource.<span class=\"hljs-title function_\">value</span>();\n    }\n  });\n\n  <span class=\"hljs-comment\">// Wrap stableValue to look like a WritableSignal for ResourceRef compatibility</span>\n  <span class=\"hljs-comment\">// While we expose set/update/asReadonly to match the interface, we delegate to the underlying resource</span>\n  <span class=\"hljs-keyword\">const</span> stableValueAsWritable = stableValue <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">unknown</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">WritableSignal</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;;\n  stableValueAsWritable.<span class=\"hljs-property\">set</span> = resource.<span class=\"hljs-property\">value</span>.<span class=\"hljs-property\">set</span>.<span class=\"hljs-title function_\">bind</span>(resource.<span class=\"hljs-property\">value</span>);\n  stableValueAsWritable.<span class=\"hljs-property\">update</span> = resource.<span class=\"hljs-property\">value</span>.<span class=\"hljs-property\">update</span>.<span class=\"hljs-title function_\">bind</span>(resource.<span class=\"hljs-property\">value</span>);\n  stableValueAsWritable.<span class=\"hljs-property\">asReadonly</span> = stableValue.<span class=\"hljs-property\">asReadonly</span>.<span class=\"hljs-title function_\">bind</span>(stableValue) <span class=\"hljs-title function_\">as</span> () =&gt; <span class=\"hljs-title class_\">Signal</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;;\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">value</span>: stableValueAsWritable,\n    <span class=\"hljs-attr\">isLoading</span>: resource.<span class=\"hljs-property\">isLoading</span>,\n    <span class=\"hljs-attr\">error</span>: resource.<span class=\"hljs-property\">error</span>,\n    <span class=\"hljs-attr\">status</span>: resource.<span class=\"hljs-property\">status</span>,\n    <span class=\"hljs-attr\">hasValue</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">stableValue</span>() !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; resource.<span class=\"hljs-title function_\">error</span>() == <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-comment\">/**\n     * Reloads the resource by incrementing an internal refresh key.\n     * Note: This triggers a params change, so status() will be `loading` (not `reloading`).\n     * This is intentional to ensure error state clears immediately on reload.\n     */</span>\n    <span class=\"hljs-attr\">reload</span>: <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-comment\">// Bug #3 fix: Increment refreshKey to trigger param change</span>\n      refreshKey.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">k</span> =&gt;</span> k + <span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    },\n    <span class=\"hljs-attr\">set</span>: resource.<span class=\"hljs-property\">set</span>.<span class=\"hljs-title function_\">bind</span>(resource),\n    <span class=\"hljs-attr\">update</span>: resource.<span class=\"hljs-property\">update</span>.<span class=\"hljs-title function_\">bind</span>(resource),\n    <span class=\"hljs-attr\">asReadonly</span>: resource.<span class=\"hljs-property\">asReadonly</span>.<span class=\"hljs-title function_\">bind</span>(resource),\n    <span class=\"hljs-attr\">destroy</span>: resource.<span class=\"hljs-property\">destroy</span>.<span class=\"hljs-title function_\">bind</span>(resource)\n  } <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">ResourceRef</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;;\n}\n\n<span class=\"hljs-comment\">/**\n * RxJS operator to re-throw HttpErrorResponse as a native Error for Angular resources.\n * Preserves original details in .cause; formats a descriptive message.\n *\n * <span class=\"hljs-doctag\">@returns</span> MonoTypeOperatorFunction&lt;T&gt; - Transforms the stream, catching/re-throwing only HTTP errors.\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> rethrowHttpResourceError&lt;T&gt;(): <span class=\"hljs-title class_\">MonoTypeOperatorFunction</span>&lt;T&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">catchError</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">err</span>: <span class=\"hljs-built_in\">unknown</span></span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (err <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">HttpErrorResponse</span>) {\n      <span class=\"hljs-comment\">// Create native Error with descriptive message and original as cause</span>\n      <span class=\"hljs-comment\">// Status 0 indicates network error (no connection, CORS, etc.)</span>\n      <span class=\"hljs-keyword\">const</span> prefix = err.<span class=\"hljs-property\">status</span> === <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&#x27;Network Error&#x27;</span> : <span class=\"hljs-string\">`HTTP Error <span class=\"hljs-subst\">${err.status}</span>`</span>;\n      <span class=\"hljs-keyword\">const</span> nativeError = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(\n        <span class=\"hljs-string\">`<span class=\"hljs-subst\">${prefix}</span><span class=\"hljs-subst\">${err.message ? <span class=\"hljs-string\">`: <span class=\"hljs-subst\">${err.message}</span>`</span> : <span class=\"hljs-string\">&#x27;&#x27;</span>}</span>`</span>,\n        { <span class=\"hljs-attr\">cause</span>: err }\n      );\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">throwError</span>(<span class=\"hljs-function\">() =&gt;</span> nativeError);\n    }\n    <span class=\"hljs-comment\">// Re-throw non-HTTP errors unchanged (e.g., for other loader types)</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">throwError</span>(<span class=\"hljs-function\">() =&gt;</span> err);\n  });\n}\n</code></pre><h3 id=\"step-2-replace-rxresource-with-rxresourcefixed\">Step 2: Replace rxResource with rxResourceFixed</h3>\n<pre><code class=\"language-typescript\"><span class=\"hljs-comment\">// Before</span>\n<span class=\"hljs-keyword\">import</span> { rxResource } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core/rxjs-interop&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> resource = <span class=\"hljs-title function_\">rxResource</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">selectedIsbn</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBook</span>(params.<span class=\"hljs-property\">isbn</span>)\n});\n\n<span class=\"hljs-comment\">// After</span>\n<span class=\"hljs-keyword\">import</span> { rxResourceFixed } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./rx-resource-fixed&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> resource = <span class=\"hljs-title function_\">rxResourceFixed</span>({\n  <span class=\"hljs-attr\">params</span>: <span class=\"hljs-function\">() =&gt;</span> ({ <span class=\"hljs-attr\">isbn</span>: <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">selectedIsbn</span>() }),\n  <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{ params }</span>) =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">bookService</span>.<span class=\"hljs-title function_\">getBook</span>(params.<span class=\"hljs-property\">isbn</span>)\n});\n</code></pre><h3 id=\"step-3-use-the-stable-value-in-templates\">Step 3: Use the stable value in templates</h3>\n<pre><code class=\"language-html\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- Your data never flickers! --&gt;</span>\n@if (booksResource.hasValue()) {\n  @for (book of booksResource.value(); track book.isbn) {\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">article</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">book.title</span> }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">article</span>&gt;</span>\n  }\n} @else if (booksResource.error()) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">&quot;alert&quot;</span>&gt;</span>Error loading books: </span><span class=\"hljs-template-variable\">{{ <span class=\"hljs-name\">booksResource.error</span>()?.message }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n} @else if (booksResource.isLoading()) {\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;loading-indicator&quot;</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n}</span>\n</code></pre><p><strong>Trade-offs to be aware of:</strong></p>\n<p>The <code>reload()</code> method has changed its semantics.\nThis wrapper intentionally trades the official <code>reloading</code> status for a fresh <code>loading</code> cycle.\nIf your UI relies on distinguishing <code>loading</code> from <code>reloading</code>, you will need to adapt your solution.\nAdditionally, it preserves stale data during loading but clears it on error to ensure error states are clearly visible.\nThis is by design.\nI think this makes the most sense, but I don&#39;t have strong feelings if you disagree.</p>\n<p>If you&#39;re making HTTP requests and don&#39;t need Observables and/or RxJS, consider using <code>httpResource()</code> with the built-in <code>defaultValue</code> option!</p>\n<h2 id=\"conclusion-i-fixed-it-and-so-can-you\">Conclusion: I Fixed It (And So Can You!)</h2>\n<p>Angular&#39;s Resource APIs have amazing potential.\nBut the shared foundation has three bugs that break real-world apps.</p>\n<p><strong>The good news?</strong> These bugs are fixable!\n<code>rxResourceFixed</code> (or a similar approach) solves all three issues.\nIt&#39;s a true drop-in replacement that returns the standard <code>ResourceRef&lt;T&gt;</code> interface, so it works seamlessly with existing code.</p>\n<p>The bugs are documented on GitHub (<a href=\"https://github.com/angular/angular/issues/58602\">#58602</a> and <a href=\"https://github.com/angular/angular/issues/61861\">#61861</a>) with significant community reactions.\nThe Angular team is aware, but remember: <strong>experimental APIs can change in any release</strong>.\nDon&#39;t let these bugs block your migration to signals!\nUse <code>rxResourceFixed</code> today, and when Angular fixes these issues, you can drop the wrapper and use the native <code>rxResource</code> again.</p>\n<p><strong>Found this helpful?</strong>\nShare it with your Angular developer friends who might be struggling with the same issues! üôÇ</p>\n<hr>\n<h2 id=\"a-final-note-on-the-title\">A Final Note on the Title</h2>\n<p>I&#39;ll admit, I struggled with the title &quot;Angular&#39;s Resource APIs Are Broken.&quot;\nIt feels harsh.\nBut after documenting these issues in detail, I believe it&#39;s justified.\nEach individual bug might seem like a minor inconvenience, but together they add up to something significant.\nFor me, the Resource APIs are simply not usable in production without workarounds.\nI want the defaults to serve my imaginary 80% use case.\nI want APIs that work out of the box for the most common scenarios.\nLet&#39;s hope the Angular team will fix these experimental APIs to be truly usable without wrappers or workarounds.</p>\n","meta":{"title":"Angular's Resource APIs Are Broken - Let's Fix Them!","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-10-31T00:00:00.000Z","lastModified":"2025-01-10T00:00:00.000Z","keywords":["Angular","Angular","rxResource","resource","httpResource","Resource API","Angular signals","RxJS","HttpErrorResponse","rxResourceFixed"],"language":"en","header":{"url":"signal.jpg","width":2473,"height":1411},"hidden":false,"sticky":false,"darkenHeader":false}}
