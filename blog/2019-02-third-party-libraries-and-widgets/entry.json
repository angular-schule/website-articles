{"slug":"2019-02-third-party-libraries-and-widgets","html":"<p><strong>For an upcoming workshop we were asked how to integrate third-party libraries into an Angular application.\nIn this blog post we want to have a closer look at this question.\nWe will discuss a few possible strategies that depend on which technology to integrate.</strong></p>\n<blockquote>\n<p>Note: The whole article is based on the assumption that you are using the <a href=\"https://cli.angular.io/\">Angular CLI</a>.</p>\n</blockquote>\n<hr>\n\n<p>Table of contents:</p>\n<ul>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#general-considerations\">General Considerations</a></li>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#integrating-a-pure-es6-javascript-library\">Integrating a pure ES6 JavaScript Library</a> (lodash)</li>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#integrating-javascript-widgets\">Integrating JavaScript Widgets</a> (plotly.js)</li>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#integrating-old-jquery-widgets\">Integrating old jQuery Widgets</a> (jquery-datetimepicker)</li>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#integrating-modern-jquery-widgets\">Integrating modern jQuery Widgets</a> (Kendo UI for jQuery)</li>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#improving-performance\">Improving performance</a> (NgZone)</li>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#don-t-reinvent-the-wheel\">Don&#39;t reinvent the wheel</a></li>\n<li><a href=\"/blog/2019-02-third-party-libraries-and-widgets#conclusion\">Conclusion</a></li>\n</ul>\n<h2 id=\"general-considerations\">General Considerations</h2>\n<p>First of all, we would like to state that it is basically a better idea to use native Angular modules.\nThis is the only way to profit from an optimal bundle size.\nHowever, it is often simply necessary to fall back on existing solutions that already meet all technical requirements and thus save a lot of time and money.</p>\n<p>Usually the following questions should be answered in advance in order to keep the effort as low as possible:</p>\n<ul>\n<li>Are there alternatives that are already based on Angular and how much effort would there be to use this alternative?</li>\n<li>Is the library / widget compatible with ES2015 (ES6) Modules or do we have to use the global object (<code>window</code>)? </li>\n<li>How big is the foreign code? Will it slow down the build process significantly? Can we use a CDN if necessary?</li>\n<li>Is jQuery a dependency? (jQuery itself can be quite large, see <a href=\"https://mathiasbynens.be/demo/jquery-size\">jQuery file size</a>)</li>\n</ul>\n<h2 id=\"integrating-a-pure-es6-javascript-library\">Integrating a pure ES6 JavaScript Library</h2>\n<p>As an example of a perfect third party library we would like to introduce lodash.\nLodash is the Swiss Army Knife for all kinds of programming tasks.\nIt is well organized and supports ES2015 modules.</p>\n<p>For example, if we want to make a deep copy of an object, we are very well served with Lodash.\nFirst, we have to install it:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> install lodash\n<span class=\"hljs-built_in\">npm</span> install @types/lodash --save-dev\n</code></pre><p>Now we are able to import the method as usual.\nThe required command looks like this:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { cloneDeep } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> nestedObject = {\n  nested: {\n     hello: <span class=\"hljs-string\">&#x27;world&#x27;</span>\n  }\n}\n<span class=\"hljs-keyword\">const</span> deepCopy = cloneDeep(nestedObject);\n\nnestedObject === deepCopy <span class=\"hljs-regexp\">// false\nnestedObject.nested === deepCopy.nested //</span> <span class=\"hljs-literal\">false</span> (<span class=\"hljs-literal\">it</span><span class=\"hljs-string\">&#x27;s a deep copy)</span>\n</code></pre><p>Since clean tree shaking <a href=\"https://medium.com/@martin_hotell/tree-shake-lodash-with-webpack-jest-and-typescript-2734fa13b5cd\">can be tricky</a>, we can also try a separate package.\nSo we don&#39;t install the whole codebase but only the necessary parts and its types.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> install lodash.clonedeep\n<span class=\"hljs-built_in\">npm</span> install @types/lodash.clonedeep --save-dev\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> cloneDeep <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;lodash.clonedeep&#x27;</span>;\n</code></pre><p>This doesn&#39;t just apply to lodash.\nWe should always check how big the bundles will be by our new dependencies.\nIn fact, if we work with 3rd party libraries, the bundle sizes will become one of the biggest showstoppers.</p>\n<p>You might get the following error, when using the Angular CLI with <code>lodash.clonedeep</code>:</p>\n<blockquote>\n<p>lodash-example.component.ts(7,8): error TS1192: Module &#39;&quot;xxx/node_modules/@types/lodash.clonedeep/index&quot;&#39; has no default export.</p>\n</blockquote>\n<p>No worries, there is compiler option to fix the typechecking.\nThe option <code>allowSyntheticDefaultImports</code> allows default imports from modules with no explicit default export.\nSo we want to open the file <code>tsconfig.json</code> and add the following value:</p>\n<pre><code class=\"language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;allowSyntheticDefaultImports&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre><p><strong><a href=\"https://stackblitz.com/edit/angular-3rd-party-libraries-and-widgets?file=src%2Fapp%2Flodash-example%2Flodash-example.component.ts\">ðŸ‘‰ Code on Stackblitz</a></strong></p>\n<h2 id=\"integrating-javascript-widgets\">Integrating JavaScript Widgets</h2>\n<p>Lets take a look at <a href=\"https://plot.ly/javascript/\">plotly.js</a>.\nIt is a high-level, declarative charting library, which is built on top of <a href=\"http://d3js.org/\">d3.js</a> and <a href=\"http://stack.gl/\">stack.gl</a>,\nThe library ships with many preconfigured chart types, including scientific charts, 3D graphs, statistical charts, SVG maps, financial charts, and more.</p>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2019-02-third-party-libraries-and-widgets/plotly_2017.png\" alt=\"plotly.js demo\"></p>\n<p>We can again start by installing it via npm</p>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-keyword\">install</span> plotly.js-dist\n</code></pre><p>and import plotly.js as</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> Plotly <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;plotly.js-dist&#x27;</span>; \n</code></pre><p>But beware, plotly.js with all its depedencies (including D3.js) is huge!\nAgain, we can save a lot of bundle size if we choose the right package.\nPlease refer to the official <a href=\"https://github.com/plotly/plotly.js/blob/master/dist/README.md#bundle-information\">bundle information</a> to choose the right partial bundle.</p>\n<p>The main plotly.js bundle weighs in at:</p>\n<table>\n<thead>\n<tr>\n<th>plotly.js</th>\n<th>plotly.min.js</th>\n<th>plotly.min.js + gzip</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>6.1 MB</td>\n<td>2.8 MB</td>\n<td>849.5 kB</td>\n</tr>\n</tbody></table>\n<p>That&#39;s a hell of a lot of code to draw a pie chart, for example.\nIf we just want to draw a pie chart we can choose the <code>basic</code> partial bundle instead.\nIt contains trace modules <code>scatter</code>, <code>bar</code> and <code>pie</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Raw size</th>\n<th>Minified size</th>\n<th>Minified + gzip size</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2.3 MB</td>\n<td>810.9 kB</td>\n<td>264.8 kB</td>\n</tr>\n</tbody></table>\n<p>At least that&#39;s a little better.</p>\n<!--\nThere are also CDN links available, which can be used, too.\nWe will take a look at them later on.\nhttps://cdn.plot.ly/plotly-basic-1.44.4.min.js\n-->\n\n<p>So we are going to install <a href=\"https://www.npmjs.com/package/plotly.js-basic-dist\"><code>plotly.js-basic-dist</code></a> via</p>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-keyword\">install</span> plotly.js-basic-dist\n</code></pre><p>and import it like this:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> Plotly <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;plotly.js-basic-dist&#x27;</span>\n</code></pre><p>The plotly.js packages with the <code>-dist</code> suffix contain a ready-to-use plotly.js distributed bundle.\nIt is not minified, but we don&#39;t want it to be minified here.\nInstead, we will minify the code from plotly.js along with the other code in the productive build of Angular (<code>ng build --prod</code>).</p>\n<p>Ok. Let&#39;s start.</p>\n<p>The idea behind plotly.js is quite simple.\nWe have a <code>&lt;div&gt;</code> element, get a reference to it and draw a &quot;plot&quot; into it. \nIn a world without Angular our code would look like this:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> myDiv = document.getElementById(<span class=\"hljs-string\">&#x27;id_of_the_div&#x27;</span>)\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">data</span> = [{\n  values: [<span class=\"hljs-number\">66</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">12</span>],\n  labels: [<span class=\"hljs-string\">&#x27;Angular&#x27;</span>, <span class=\"hljs-string\">&#x27;React&#x27;</span>, <span class=\"hljs-string\">&#x27;Vue&#x27;</span>],\n  type: <span class=\"hljs-string\">&#x27;pie&#x27;</span>\n}];\n\n<span class=\"hljs-keyword\">const</span> layout = {\n  title: <span class=\"hljs-string\">&#x27;Top 3 Most Popular SPA Frameworks in 2019*&#x27;</span>,\n  height: <span class=\"hljs-number\">400</span>,\n  width: <span class=\"hljs-number\">500</span>\n};\n\nPlotly.newPlot(myDiv, <span class=\"hljs-keyword\">data</span>, layout);\n</code></pre><p><small>(&ast;Note: exactly one person was interviewed for this ranking.)</small></p>\n<p>The question is, where do we get a reference to the DOM element from?</p>\n<p>The simplest way provided by angular is the wrapper <code>ElementRef</code>.\nIt&#39;s the return type of the <code>@ViewChild()</code> decorator, if there is no component applied (otherwise it will return a component instance instead). \nThe decorator accepts various selectors, as described <a href=\"https://angular.io/api/core/ViewChild\">here</a>. \nWe will use a template reference variable as a string, so <code>@ViewChild(&#39;myDiv&#39;)</code> will query against <code>&lt;div #myDiv&gt;&lt;/div&gt;</code>.\nThe <code>ElementRef</code> will be ready when <code>ngAfterViewInit()</code> is called:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-title class_\">ViewChild</span>, <span class=\"hljs-title class_\">AfterViewInit</span>, <span class=\"hljs-title class_\">ElementRef</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Plotly</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;plotly.js-basic-dist&#x27;</span>\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-plotlyjs-example&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div #myDiv&gt;&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PlotlyjsExampleComponent</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">AfterViewInit</span> {\n\n  <span class=\"hljs-meta\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;myDiv&#x27;</span>)\n  <span class=\"hljs-attr\">myDiv</span>: <span class=\"hljs-title class_\">ElementRef</span>;\n\n  <span class=\"hljs-title function_\">ngAfterViewInit</span>(<span class=\"hljs-params\"></span>) {\n\n    <span class=\"hljs-keyword\">const</span> myDivEl = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">myDiv</span>.<span class=\"hljs-property\">nativeElement</span>;\n\n    <span class=\"hljs-keyword\">const</span> data = [{\n      <span class=\"hljs-attr\">values</span>: [<span class=\"hljs-number\">66</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">12</span>],\n      <span class=\"hljs-attr\">labels</span>: [<span class=\"hljs-string\">&#x27;Angular&#x27;</span>, <span class=\"hljs-string\">&#x27;React&#x27;</span>, <span class=\"hljs-string\">&#x27;Vue&#x27;</span>],\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;pie&#x27;</span>\n    }];\n\n    <span class=\"hljs-keyword\">const</span> layout = {\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;Top 3 Most Popular SPA Frameworks in 2019*&#x27;</span>,\n      <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">400</span>,\n      <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">500</span>\n    };\n\n    <span class=\"hljs-title class_\">Plotly</span>.<span class=\"hljs-title function_\">newPlot</span>(myDivEl, data, layout);\n  }\n}\n</code></pre><p>There are multiple other ways to get a reference to a DOM element.\nWe recommend the following article if you are interested in other ways to get a reference to a DOM element: <a href=\"https://blog.angularindepth.com/exploring-angular-dom-abstractions-80b3ebcfc02\">Angular in Depth: Exploring Angular DOM manipulation techniques</a></p>\n<p><strong><a href=\"https://stackblitz.com/edit/angular-3rd-party-libraries-and-widgets?file=src%2Fapp%2Fplotlyjs-example%2Fplotlyjs-example.component.ts\">ðŸ‘‰ Code on Stackblitz</a></strong></p>\n<h2 id=\"integrating-old-jquery-widgets\">Integrating old jQuery Widgets</h2>\n<p>As we have seen, ES2015 modules are an ideal way to use third-party libraries.\nHowever, not all third-party libraries support this modern way.\nThese libraries often assume that jQuery is available in the global scope and very old ones don&#39;t utilize modules at all.</p>\n<p>Here it is important to pay attention to the version of jQuery.\nNot all libraries support jQuery v3, because it has a some of breaking changes.\nFor this example I have chosen the plugin <code>jquery-datetimepicker</code> since it requires &quot;classic&quot; jQuery.\nSo let&#39;s install jQuery from the outdated v1 branch and the library with the help of npm.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">npm</span> install jquery@<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">12</span>.<span class=\"hljs-number\">4</span>\n<span class=\"hljs-attribute\">npm</span> install @types/jquery@<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">10</span>.<span class=\"hljs-number\">35</span> --save-dev\n<span class=\"hljs-attribute\">npm</span> install jquery-datetimepicker@<span class=\"hljs-number\">2</span>.<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">20</span>\n</code></pre><p>Fortunately, the Angular CLI provides a declarative way to provide these libraries/widgets via the <code>angular.json</code> file.\nLocate the build configuration of your project and search for the <code>scripts</code> property.\nIt accepts an array of JavaScript files that are added to the global scope of the project.\nThis is especially useful for legacy libraries or analytic snippets.    </p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;app&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;build&quot;</span>: {\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;scripts&quot;</span>: [\n              <span class=\"hljs-string\">&quot;node_modules/jquery/dist/jquery.min.js&quot;</span>,\n              <span class=\"hljs-string\">&quot;node_modules/jquery-datetimepicker/build/jquery.datetimepicker.full.js&quot;</span>\n            ],\n            <span class=\"hljs-string\">&quot;styles&quot;</span>: [\n              <span class=\"hljs-string\">&quot;src/styles.css&quot;</span>,\n              <span class=\"hljs-string\">&quot;node_modules/jquery-datetimepicker/jquery.datetimepicker.css&quot;</span>\n            ]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre><p>First we have to load jQuery, then the plugins.\nNext to the <code>scripts</code> property we see the <code>styles</code> property. \nIt allows us to add global stylesheets.\nAngular CLI supports CSS imports and all major CSS preprocessors.</p>\n<p>To satisfy the type checking we create an interface with the name <code>JQuery</code> in your local typings declaration file <code>typings.d.ts</code> and introduce the plugin function.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">interface</span> JQuery {\n  datetimepicker(<span class=\"hljs-keyword\">options</span>?: <span class=\"hljs-keyword\">any</span>): <span class=\"hljs-keyword\">any</span>;\n}\n</code></pre><p>Now we are ready to do all that dirty jQuery stuff we used to love for so many years:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { Component, AfterViewInit } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component(<span class=\"hljs-params\">{\n  selector: <span class=\"hljs-string\">&#x27;app-jquery-old-example&#x27;</span>,\n  template: `&lt;<span class=\"hljs-built_in\">input</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;datetimepicker&quot;</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span>&gt;`\n}</span>)</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JqueryOldExampleComponent</span> implements AfterViewInit {\n\n  public ngAfterViewInit()\n  {\n    jQuery(<span class=\"hljs-string\">&#x27;#datetimepicker&#x27;</span>).datetimepicker();\n  }\n}\n</code></pre><p>Note that this is not clean code.\nWe use an object in the global scope (<code>jQuery</code>) and select directly against an element by ID.\nIf we include the component twice and thus have two IDs, the result is not deterministic.\nThe next example shows a better approach.</p>\n<p><strong><a href=\"https://stackblitz.com/edit/angular-3rd-party-libraries-and-widgets?file=src%2Fapp%2Fjquery-old-example%2Fjquery-old-example.component.ts\">ðŸ‘‰ Code on Stackblitz</a></strong></p>\n<h2 id=\"integrating-modern-jquery-widgets\">Integrating modern jQuery Widgets</h2>\n<p>Of course, also jQuery as well as modern jQuery plugins support all kind of module formats and can be imported via <code>import</code> statements.\nAs an example, we want to try out the Scheduler of Kendo UI for jQuery (which hasn&#39;t been ported to Kendo UI for Angular until now!)</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">npm</span> install jquery@<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">1</span>\n<span class=\"hljs-attribute\">npm</span> install @types/jquery@<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">29</span> --save-dev\n</code></pre><p>Here we will install the full version of Kendo UI for jQuery.\nPlease keep in mind that the vendor provides customized versions, too.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> install @progress/kendo-ui\n</code></pre><p>Since we are able to use modules, we can import jQuery and the plugin directly from the typescript code.\nThere is no need to add an entry to <code>angular.json</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-title class_\">ViewChild</span>, <span class=\"hljs-title class_\">AfterViewInit</span>, <span class=\"hljs-title class_\">ElementRef</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> options <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./options&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> jQuery <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;jquery&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;@progress/kendo-ui&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-kendo-ui-jquery-example&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;div #myDiv&gt;&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KendoUiJqueryExampleComponent</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">AfterViewInit</span> {\n\n  <span class=\"hljs-meta\">@ViewChild</span>(<span class=\"hljs-string\">&#x27;myDiv&#x27;</span>)\n  <span class=\"hljs-attr\">myDiv</span>: <span class=\"hljs-title class_\">ElementRef</span>;\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ngAfterViewInit</span>(<span class=\"hljs-params\"></span>)\n  {\n    <span class=\"hljs-keyword\">const</span> myDivEl = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">myDiv</span>.<span class=\"hljs-property\">nativeElement</span>;\n    <span class=\"hljs-title function_\">jQuery</span>(myDivEl).<span class=\"hljs-title function_\">kendoScheduler</span>(options);\n  }\n}\n</code></pre><p>We also see again the use of <code>ElementRef</code>.\nIt&#39;s a better approach to ask Angular for reference to a DOM element instead of grabbing it directly.</p>\n<p><strong><a href=\"https://stackblitz.com/edit/angular-3rd-party-libraries-and-widgets?file=src%2Fapp%2Fkendo-ui-jquery-example%2Fkendo-ui-jquery-example.component.ts\">ðŸ‘‰ Code on Stackblitz</a></strong></p>\n<h2 id=\"improving-performance\">Improving performance</h2>\n<p>We can improve the performance of all shown solutions.\nThe default change detection from Angular is triggered on every event that our code is subscribed to.\nThis can have a huge impact to the overall performance of our Angular app.\nA lot of old code listens actively to the mouse movements or scroll events.\nAs a result, change detection is called multiple times and makes everything slow.</p>\n<p>To omit that problem, we can make use of the <code>NgZone</code> class.\nBy default, Angular works together with <a href=\"https://github.com/angular/zone.js/\">zone.js</a> that introduces a concept of zones.\nWithin a zone, all async APIs are patched and therefore it is possible to run code whenever the asynchronous code finishes.\nAs long as we use the default change detection strategy (<code>ChangeDetectionStrategy.Default</code>), everything that happens within the zone of Angular triggers a change detection run.\nIf we are not interested in triggering CD, because our third party library does not interact at all with Angular, we can move our code execution into our own zone.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-title class_\">ViewChild</span>, <span class=\"hljs-title class_\">AfterViewInit</span>, <span class=\"hljs-title class_\">ElementRef</span>, <span class=\"hljs-title class_\">NgZone</span>\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">// [...]</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">KendoUiJqueryExampleComponent</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">AfterViewInit</span> {\n\n  <span class=\"hljs-comment\">// [...]</span>\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">ngZone</span>: <span class=\"hljs-title class_\">NgZone</span></span>) { }\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ngAfterViewInit</span>(<span class=\"hljs-params\"></span>)\n  {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">ngZone</span>.<span class=\"hljs-title function_\">runOutsideAngular</span>(<span class=\"hljs-function\">() =&gt;</span> { \n      <span class=\"hljs-keyword\">const</span> myDivEl = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">myDiv</span>.<span class=\"hljs-property\">nativeElement</span>;\n      <span class=\"hljs-title function_\">jQuery</span>(myDivEl).<span class=\"hljs-title function_\">kendoScheduler</span>(options);\n    });\n  }\n}\n</code></pre><p> We can return back to the angular zone anytime via <code>this.ngZone.run(() =&gt; { })</code>.</p>\n<h2 id=\"dont-reinvent-the-wheel\">Don&#39;t reinvent the wheel</h2>\n<p>It happens to us developers quite often that we reinvent the wheel.\nIn the case of plotly.js, there is already a wrapper that has the same technical foundation as described in our article (see <a href=\"https://github.com/plotly/angular-plotly.js/blob/78b9385da1a9a56fe2c9b3b914fce1e63707ae02/src/app/shared/plot/plot.component.ts#L37\">here</a>):</p>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-keyword\">install </span>angular-plotly.<span class=\"hljs-keyword\">js\n</span>npm <span class=\"hljs-keyword\">install </span>plotly.<span class=\"hljs-keyword\">js</span>\n</code></pre><p>A large number of inputs and outputs have already been implemented, so it is better to have a look at this solution twice.</p>\n<p>So we should add the <code>PlotlyModule</code> into the main app module of your project:</p>\n<pre><code class=\"language-typescript\">import { PlotlyModule } from <span class=\"hljs-string\">&#x27;angular-plotly.js&#x27;</span>;\n\n<span class=\"hljs-variable\">@NgModule</span>({\n    imports: [\n      <span class=\"hljs-regexp\">//</span> ...\n      PlotlyModule\n    ],  \n    <span class=\"hljs-regexp\">//</span> ...\n})\nexport <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }\n</code></pre><p>Then use the <code>&lt;plotly-plot&gt;</code> component to display the same chart as before:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-angular-plotlyjs-example&#x27;</span>,\n  template: `&lt;plotly-plot [data]=<span class=\"hljs-string\">&quot;data&quot;</span> [layout]=<span class=\"hljs-string\">&quot;layout&quot;</span>&gt;&lt;/plotly-plot&gt;`,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AngularPlotlyjsExampleComponent</span> {\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">data</span> = [{\n    values: [<span class=\"hljs-number\">66</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-number\">12</span>],\n    labels: [<span class=\"hljs-string\">&#x27;Angular&#x27;</span>, <span class=\"hljs-string\">&#x27;React&#x27;</span>, <span class=\"hljs-string\">&#x27;Vue&#x27;</span>],\n    type: <span class=\"hljs-string\">&#x27;pie&#x27;</span>\n  }];\n\n  <span class=\"hljs-keyword\">public</span> layout = {\n    title: <span class=\"hljs-string\">&#x27;Top 3 Most Popular SPA Frameworks in 2019*&#x27;</span>,\n    height: <span class=\"hljs-number\">400</span>,\n    width: <span class=\"hljs-number\">500</span>\n  }\n}\n</code></pre><p>But note: it&#39;s still just a wrapper around that large library!</p>\n<p><strong><a href=\"https://stackblitz.com/edit/angular-3rd-party-libraries-and-widgets?file=src%2Fapp%2Fangular-plotlyjs-example%2Fangular-plotlyjs-example.component.ts\">ðŸ‘‰ Code on Stackblitz</a></strong></p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>We have seen some ways to use existing (legacy) code in a modern Angular applications.\nUnless there is a true Angular based solution, this is a legitimate approach.\nIf there is a wrapper around, it is always a good idea to evaluate it first!\nAnd if something important is not implemented for that wrapper, just make a pull-request! ðŸ˜‰</p>\n<p>For your reference, this is the full example on Stackblitz:</p>\n<iframe style=\"width: 98%; height: 800px;\" title=\"Stackblitz-Demo\" src=\"https://stackblitz.com/edit/angular-3rd-party-libraries-and-widgets?embed=1&view=preview&ctl=1\"></iframe>\n\n","meta":{"title":"How to integrate third party libraries and widgets into Angular","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2019-02-27T00:00:00.000Z","keywords":["Angular","jQuery","library","libraries"],"language":"en","header":{"url":"pixabay-books-1655783.jpg","width":1847,"height":1039},"hidden":false,"sticky":false,"darkenHeader":false}}
