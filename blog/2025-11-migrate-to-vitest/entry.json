{"slug":"2025-11-migrate-to-vitest","html":"<p>Angular 21 introduces a significant change to unit testing:\nVitest is now the default, replacing the previous standard combination of Karma and Jasmine.\nWhen creating a new project with <code>ng new</code>, Angular 21 now uses <strong>Vitest</strong> as the default test runner.\nVitest promises significantly faster startup times, modern features, and an easy-to-use Jest-compatible API.\nIn this article, we&#39;ll show you what Vitest means for you, how to migrate existing Angular projects, and what benefits Vitest offers.</p>\n<blockquote>\n<p>ðŸ‡©ðŸ‡ª This article is available in German language here: <a href=\"https://angular-buch.com/blog/2025-11-zu-vitest-migrieren\">Vitest in Angular 21: Was ist neu und wie kann man migrieren?</a></p>\n</blockquote>\n<h2 id=\"content\">Content</h2>\n<ul>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#why-angular-replaces-karma-and-jasmine\">Why Angular replaces Karma and Jasmine</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#migration-guide-from-karmajasmine-to-vitest\">Migration guide: From Karma/Jasmine to Vitest</a><ul>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#manual-migration-steps\">Manual migration steps</a><ul>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#1-install-dependencies\">1. Install dependencies</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#2-update-angularjson\">2. Update <code>angular.json</code></a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#3-adapt-a-custom-karmaconfjs-configuration\">3. Adapt a custom <code>karma.conf.js</code> configuration</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#4-remove-karma-and-testts-files\">4. Remove Karma and <code>test.ts</code> files</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#5-configure-browser-mode-optional\">5. Configure browser mode (optional)</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#automatic-test-refactoring-using-the-schematic\">Automatic test refactoring using the schematic</a><ul>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#1-overview\">1. Overview</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#2-execute-the-schematic\">2. Execute the schematic</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#3-after-the-migration\">3. After the migration</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#4-custom-configuration-optional\">4. Custom configuration (optional)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#the-new-syntax-and-apis\">The new syntax and APIs</a><ul>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#global-functions\">Global functions</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#matchers\">Matchers</a><ul>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#1-tobetrue--tobefalse-do-not-exist-in-jestvitest\">1) <code>toBeTrue()</code> / <code>toBeFalse()</code> do not exist in Jest/Vitest</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#2-tohavebeencalledoncewith-does-not-exist-in-jestvitest\">2) <code>toHaveBeenCalledOnceWith()</code> does not exist in Jest/Vitest</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#3-asynchronous-matchers-expectasync-jasmine-vs-resolvesrejects-jestvitest\">3) Asynchronous Matchers: <code>expectAsync(...)</code> (Jasmine) vs. <code>.resolves/.rejects</code> (Jest/Vitest)</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#spies-and-mocks\">Spies and mocks</a><ul>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#important-difference-default-behavior-of-spies\">Important difference: Default behavior of spies</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#cleaning-up-spies\">Cleaning up spies</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#asynchrony-without-zonejs-using-vitest-timers\">Asynchrony without Zone.js using Vitest timers</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#testbed-and-componentfixture\">TestBed and ComponentFixture</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#known-limitations-and-pitfalls\">Known limitations and pitfalls</a></li>\n<li><a href=\"/blog/2025-11-migrate-to-vitest#conclusion\">Conclusion</a></li>\n</ul>\n<h2 id=\"why-angular-replaces-karma-and-jasmine\">Why Angular replaces Karma and Jasmine</h2>\n<p>Karma and Jasmine served Angular well for many years, primarily because they ran in a real browser.\nHowever, there were disadvantages: the execution speed was never optimal and the ecosystem became outdated (<a href=\"https://github.com/karma-runner/karma#karma-is-deprecated-and-is-not-accepting-new-features-or-general-bug-fixes\">Karma has been deprecated since 2023</a>).\nOver several years, the Angular team evaluated alternatives (Jest, Web Test Runner, etc.) without finding a clear winner.\n<a href=\"https://vitest.dev/\">Vitest</a> has since become quite popular and proved to be a suitable solution.</p>\n<p>Vitest was particularly well-suited because it offers a real browser mode.\nAs with Karma before, tests can be run in a real browser with a &quot;real&quot; DOM and real events.\nThe browser mode was recently <a href=\"https://vitest.dev/blog/vitest-4.html#browser-mode-is-stable\">declared stable</a> with Vitest 4 in October 2025.\nAt the same time, Vitest is fast and modern: it is built on <a href=\"https://vite.dev/\">Vite</a>, is ESM- and TypeScript-first, and ensures extremely short startup and repetition times.\nAdditionally, Vitest provides a powerful API with snapshot testing, flexible <a href=\"https://vitest.dev/guide/mocking/timers.html\">fake timers</a>, the extremely helpful helper <a href=\"https://vitest.dev/api/expect.html#poll\"><code>expect.poll</code></a>, <a href=\"https://vitest.dev/guide/test-context\">test fixtures</a>, and Jest-compatible matchers.\nLast but not least, Vitest is widely adopted across the frontend ecosystem, allowing existing knowledge to transfer easily.\nIn short: Switching ensures speed, a significantly better developer experience, and future-proofing, while still allowing real browser testing.</p>\n<h2 id=\"migration-guide-from-karmajasmine-to-vitest\">Migration guide: From Karma/Jasmine to Vitest</h2>\n<!-- Source: https://github.com/angular/angular/blob/6178e3ebfbc69a2afa04dd19ea4d6d8b1bfb0649/adev/src/content/guide/testing/migrating-to-vitest.md -->\n\n<p>If you want to create a <strong>new project</strong> with Angular 21, the Angular CLI uses the new test runner Vitest by default.\nYou can control this choice using the <code>--test-runner</code> option:\nWith <code>--test-runner=vitest</code> you get the new, faster, and more modern default solution.\nIf you want to keep the proven Karma/Jasmine combination, use the option <code>--test-runner=karma</code>.\nIf you do not specify the option, Vitest is used automatically.</p>\n<p>To migrate an <strong>existing project</strong> to Angular 21 and Vitest, you must first update the project to version 21 using <code>ng update</code>.\nNote that migrating existing projects to Vitest is currently still <strong>experimental</strong>.\nThis process also requires Angular&#39;s <code>application</code> build system, which is enabled by default in newly created projects.\nOnce your project has been updated to version 21, you can continue with the following steps.</p>\n<h3 id=\"manual-migration-steps\">Manual migration steps</h3>\n<p>Before you use the automatic refactoring schematic, you need to adjust your project manually so that Vitest is used as the test runner.</p>\n<h4 id=\"1-install-dependencies\">1. Install dependencies</h4>\n<p>Install <code>vitest</code> and a DOM emulation library.\nAlthough tests can still run in the browser (see step 5), Vitest uses a DOM emulation by default to simulate a browser environment in Node.js and to execute tests faster.\nThe CLI automatically detects <code>happy-dom</code> if it is installed; otherwise it falls back to <code>jsdom</code>.\nOne of these two packages must be present.</p>\n<pre><code class=\"language-bash\">npm install --<span class=\"hljs-built_in\">save</span>-<span class=\"hljs-built_in\">dev</span> vitest jsdom\n</code></pre><h4 id=\"2-update-angularjson\">2. Update <code>angular.json</code></h4>\n<p>Find the <code>test</code> target of your project in the <code>angular.json</code> file and set the <code>builder</code> to <code>@angular/build:unit-test</code>.</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>\n        }\n      }\n    }\n  }\n}\n</code></pre><p>The <code>unit-test</code> builder uses <code>&quot;tsConfig&quot;: &quot;tsconfig.spec.json&quot;</code> and <code>&quot;buildTarget&quot;: &quot;::development&quot;</code> by default.\nIf your project needs different values, you can create your own build configuration. This is useful when the <code>development</code> configuration is missing or when you need special test settings, for example a configuration named <code>testing</code>.</p>\n<p>The previous builder <code>@angular/build:karma</code> allowed you to define build options (such as <code>polyfills</code>, <code>assets</code>, <code>styles</code>) directly in the <code>test</code> target. The new builder <code>@angular/build:unit-test</code> does not support this.\nIf your test build options differ from the <code>development</code> configuration, you must move these options into a separate build configuration.\nIf they already match <code>development</code>, no further step is necessary.</p>\n<blockquote>\n<p><strong>Tip:</strong> As an alternative, you can simply create a new project using <code>ng new</code> and copy the relevant parts of the newly generated <code>angular.json</code> into your existing project.\nThis gives you a clean template for the Vitest configuration automatically.</p>\n</blockquote>\n<h4 id=\"3-adapt-a-custom-karmaconfjs-configuration\">3. Adapt a custom <code>karma.conf.js</code> configuration</h4>\n<p>Custom settings from the file <code>karma.conf.js</code> are not migrated automatically.\nCheck this file before deleting it, and transfer the relevant options manually.\nMany Karma options have Vitest equivalents that you can define in a <code>vitest.config.ts</code> and then include through <code>runnerConfig</code> in the <code>angular.json</code>.</p>\n<p>Typical migration paths:</p>\n<ul>\n<li><strong>Reporters:</strong> Karma reporters must be replaced with Vitest-compatible reporters. Many of them can be configured directly in <code>angular.json</code> under <code>test.options.reporters</code>. For more complex cases, use <code>vitest.config.ts</code>.</li>\n<li><strong>Plugins:</strong> Karma plugins require suitable Vitest alternatives. Note that code coverage is already integrated in the Angular CLI and can be enabled with <code>ng test --coverage</code>.</li>\n<li><strong>Custom browser launchers:</strong> These are replaced by the <code>browsers</code> option in <code>angular.json</code> and by installing a browser provider such as <code>@vitest/browser-playwright</code>.</li>\n</ul>\n<p>You can find more settings in the official <a href=\"https://vitest.dev/config/\">Vitest documentation</a>.</p>\n<h4 id=\"4-remove-karma-and-testts-files\">4. Remove Karma and <code>test.ts</code> files</h4>\n<p>You can now delete the files <code>karma.conf.js</code> and <code>src/test.ts</code> and uninstall all Karma-related packages.\nThe following commands matches a standard Angular project.\nYour project may contain additional packages.</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> uninstall karma karma-chrome-launcher karma-coverage karma-jasmine karma-jasmine-html-reporter\n</code></pre><h4 id=\"5-configure-browser-mode-optional\">5. Configure browser mode (optional)</h4>\n<p>If you want to run tests in a real browser, you must install a browser provider and adjust the <code>angular.json</code>.\nChoose depending on your needs:</p>\n<ul>\n<li><strong>Playwright:</strong> <code>@vitest/browser-playwright</code> for Chromium, Firefox, and WebKit</li>\n<li><strong>WebdriverIO:</strong> <code>@vitest/browser-webdriverio</code> for Chrome, Firefox, Safari, and Edge</li>\n<li><strong>Preview:</strong> <code>@vitest/browser-preview</code> for WebContainer environments like StackBlitz</li>\n</ul>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> install --save-dev @vitest/browser-playwright\n</code></pre><p>After that, you must extend the <code>angular.json</code>.\nAdd the <code>browsers</code> option to the <code>test</code> target.\nThe browser name depends on the provider you use (for example <code>chromium</code> for Playwright).</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;browsers&quot;</span>: [<span class=\"hljs-string\">&quot;chromium&quot;</span>]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre><p>The headless mode is automatically activated if the environment variable <code>CI</code> is set or the browser name contains &quot;Headless&quot; (e.g., <code>ChromeHeadless</code>).\nOtherwise, the browser runs visibly.</p>\n<h3 id=\"automatic-test-refactoring-using-the-schematic\">Automatic test refactoring using the schematic</h3>\n<p>The Angular CLI provides a schematic that automatically converts your Jasmine tests to Vitest.</p>\n<p><strong>IMPORTANT:</strong> The <code>refactor-jasmine-vitest</code> schematic is experimental and does not cover all patterns.\nAlways review the changes manually.</p>\n<h4 id=\"1-overview\">1. Overview</h4>\n<p>The schematic currently performs the following transformations in files with the suffix <code>.spec.ts</code>:</p>\n<ul>\n<li><code>fit</code>/<code>fdescribe</code> â†’ <code>it.only</code>/<code>describe.only</code></li>\n<li><code>xit</code>/<code>xdescribe</code> â†’ <code>it.skip</code>/<code>describe.skip</code></li>\n<li><code>spyOn</code> â†’ <code>vi.spyOn</code></li>\n<li><code>jasmine.objectContaining</code> â†’ <code>expect.objectContaining</code></li>\n<li><code>jasmine.any</code> â†’ <code>expect.any</code></li>\n<li><code>jasmine.createSpy</code> â†’ <code>vi.fn</code></li>\n<li>Conversion of lifecycle hooks (<code>beforeAll</code>, <code>beforeEach</code>, etc.) to their Vitest equivalents</li>\n<li><code>fail()</code> â†’ <code>vi.fail()</code></li>\n<li>Adjustment of matchers to the Vitest API</li>\n<li><a href=\"https://github.com/angular/angular-cli/pull/31469\">TODO comments</a> for parts that cannot be converted automatically</li>\n<li>Tests with <code>done</code> callbacks are rewritten into <code>async</code>/<code>await</code> tests</li>\n</ul>\n<!--(see PR https://github.com/angular/angular-cli/pull/31435 and following -->\n\n<p>The schematic deliberately does not perform certain tasks.\nIt does not install Vitest or any other required dependencies.\nIt also does not modify the <code>angular.json</code> to enable the Vitest builder.\nLikewise, it does not remove Karma files from the project.\nFinally, the schematic does not convert complex spy scenarios, which must still be reviewed manually.\nThe manual migration (as described above) therefore remains necessary.</p>\n<h4 id=\"2-execute-the-schematic\">2. Execute the schematic</h4>\n<p>If your project is configured for Vitest, you can start the automatic refactoring:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng</span> g <span class=\"hljs-variable\">@schematics</span>/angular:refactor-jasmine-vitest\n</code></pre><p>The schematic provides several additional options:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--project &lt;name&gt;</code></td>\n<td>Selects a specific project from the workspace.</td>\n</tr>\n<tr>\n<td><code>--include &lt;path&gt;</code></td>\n<td>Limits the refactoring to a file or a directory.</td>\n</tr>\n<tr>\n<td><code>--file-suffix</code></td>\n<td>Defines a different file extension for test files.</td>\n</tr>\n<tr>\n<td><code>--add-imports</code></td>\n<td>Adds explicit Vitest imports.</td>\n</tr>\n<tr>\n<td><code>--verbose</code></td>\n<td>Enables detailed logging of the performed changes.</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-after-the-migration\">3. After the migration</h4>\n<ol>\n<li><strong>Execute the tests:</strong> Use <code>ng test</code> to make sure all tests still work.</li>\n<li><strong>Review the changes:</strong> Check the modifications, especially for complex spies or asynchronous tests.</li>\n</ol>\n<p><code>ng test</code> runs tests in <strong>watch mode</strong> when the terminal is interactive.\nIn CI environments, the test runner automatically runs the tests in single-run mode.</p>\n<h4 id=\"4-custom-configuration-optional\">4. Custom configuration (optional)</h4>\n<p>The Angular CLI generates the Vitest configuration behind the scenes based on the options in <code>angular.json</code>.</p>\n<p>If the provided options are not sufficient, you can use a custom configuration.\nThis makes extended options available, but the Angular team does not provide direct support for the specific contents of the configuration file or for any third-party plugins used inside it.\nThe CLI also overrides certain properties (<code>test.projects</code>, <code>test.include</code>) to ensure correct operation.</p>\n<p>If needed, you can include your own Vitest configuration file (<code>vitest.config.ts</code>) to make adjustments that go beyond the standard options.\nThere are two ways to do this: You can directly reference a specific configuration file by providing the exact path in the <code>angular.json</code>:</p>\n<pre><code class=\"language-json\">{\n  <span class=\"hljs-string\">&quot;projects&quot;</span>: {\n    <span class=\"hljs-string\">&quot;your-project-name&quot;</span>: {\n      <span class=\"hljs-string\">&quot;architect&quot;</span>: {\n        <span class=\"hljs-string\">&quot;test&quot;</span>: {\n          <span class=\"hljs-string\">&quot;builder&quot;</span>: <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">@angular</span>/build:unit-test&quot;</span>,\n          <span class=\"hljs-string\">&quot;options&quot;</span>: {\n            <span class=\"hljs-string\">&quot;runnerConfig&quot;</span>: <span class=\"hljs-string\">&quot;vitest.config.ts&quot;</span>\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre><p>Alternatively, you can let the Angular CLI search automatically.\nFor automatic discovery, set <code>&quot;runnerConfig&quot;: true</code> in the <code>angular.json</code>.\nThe builder will then search for a file named <code>vitest-base.config.*</code>, first in the project directory and then in the workspace root.\nThis allows you to define shared settings centrally and reuse them easily.</p>\n<h2 id=\"the-new-syntax-and-apis\">The new syntax and APIs</h2>\n<p>Most specs run unchanged because <strong>TestBed, ComponentFixture &amp; Co.</strong> remain available.\nWhen migrating from Jasmine to Vitest, many testing patterns stay familiar, but some parts of the API change.\nYou mainly have to get familiar with the parts that are specific to Jasmine.</p>\n<h3 id=\"global-functions\">Global functions</h3>\n<p>The well-known global test functions such as <code>describe</code>, <code>it</code> or <code>test</code>, <code>beforeEach</code>, <code>afterEach</code>, and <code>expect</code> remain available in Vitest without changes.\nThey are available without additional imports as long as your <code>tsconfig.spec.json</code> contains <code>types: [&quot;vitest/globals&quot;]</code>.\nHowever, we still recommend importing these functions explicitly.\nThis avoids possible name collisions, for example with functions from Cypress that have the same names, which has caused confusing problems in the past.</p>\n<h3 id=\"matchers\">Matchers</h3>\n<p>The usual matchers like <code>toBe</code>, <code>toEqual</code>, <code>toContain</code>, or <code>toHaveBeenCalledWith</code> remain available in Vitest. If you used <code>jasmine.any(...)</code> in Jasmine, you now use <code>expect.any(...)</code> in Vitest.\nImportant: Vitest does not aim to provide an API that is compatible with Jasmine.\nInstead, Vitest offers a <a href=\"https://vitest.dev/api/expect.html\"><strong>Jest-compatible</strong> expect API</a> based on Chai.\nThe Jest test framework itself aims to be somewhat compatible with Jasmine.\nBut since Vitest only wants to be compatible with Jest, some challenges arise because certain matchers simply do not exist.</p>\n<h4 id=\"1-tobetrue--tobefalse-do-not-exist-in-jestvitest\">1) <code>toBeTrue()</code> / <code>toBeFalse()</code> do not exist in Jest/Vitest</h4>\n<p>Jasmine includes the strict boolean matchers <code>toBeTrue()</code> and <code>toBeFalse()</code>.\nThey do not exist in Jest (and therefore not in Vitest).\nInstead, you can simply use the matcher <a href=\"https://vitest.dev/api/expect.html#tobe\"><code>toBe(true)</code></a> or <code>toBe(false)</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-built_in\">expect</span>(result)<span class=\"hljs-selector-class\">.toBeTrue</span>();\n<span class=\"hljs-built_in\">expect</span>(flag)<span class=\"hljs-selector-class\">.toBeFalse</span>();\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-built_in\">expect</span>(result)<span class=\"hljs-selector-class\">.toBe</span>(true);\n<span class=\"hljs-built_in\">expect</span>(flag)<span class=\"hljs-selector-class\">.toBe</span>(false);\n</code></pre><h4 id=\"2-tohavebeencalledoncewith-does-not-exist-in-jestvitest\">2) <code>toHaveBeenCalledOnceWith()</code> does not exist in Jest/Vitest</h4>\n<p>Jasmine has a convenient matcher for checking that a spy was called &quot;exactly once and with exactly these arguments&quot;.\nAs a replacement, you simply use <a href=\"https://vitest.dev/api/expect.html#tohavebeencalledexactlyoncewith\"><code>toHaveBeenCalledExactlyOnceWith()</code></a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">var</span> book = {};\n\n<span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-keyword\">expect</span>(spy).toHaveBeenCalledOnceWith(book);\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-keyword\">expect</span>(spy).toHaveBeenCalledExactlyOnceWith(book);\n</code></pre><h4 id=\"3-asynchronous-matchers-expectasync-jasmine-vs-resolvesrejects-jestvitest\">3) Asynchronous Matchers: <code>expectAsync(...)</code> (Jasmine) vs. <code>.resolves/.rejects</code> (Jest/Vitest)</h4>\n<p>Jasmine has its <a href=\"https://jasmine.github.io/api/5.12/async-matchers\">own async API</a>: <code>await expectAsync(promise).toBeResolved() / toBeRejectedWith(...)</code>.\nJest/Vitest instead uses the pattern <a href=\"https://vitest.dev/api/expect.html#resolves\"><code>await expect(promise).resolves/...</code></a> or <a href=\"https://vitest.dev/api/expect.html#rejects\"><code>.rejects/...</code></a>.\nFor the migration, you must rewrite these expectations. </p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeResolved</span>();\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeResolvedTo</span>(&#x27;OK&#x27;);\nawait <span class=\"hljs-built_in\">expectAsync</span>(doWork())<span class=\"hljs-selector-class\">.toBeRejectedWithError</span>(&#x27;Boom&#x27;);\n\n<span class=\"hljs-comment\">// Jest/Vitest</span>\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.resolves</span><span class=\"hljs-selector-class\">.toBeDefined</span>();\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.resolves</span><span class=\"hljs-selector-class\">.toBe</span>(&#x27;OK&#x27;);\nawait <span class=\"hljs-built_in\">expect</span>(doWork())<span class=\"hljs-selector-class\">.rejects</span><span class=\"hljs-selector-class\">.toThrow</span>(&#x27;Boom&#x27;);\n</code></pre><p>Vitest therefore aims for Jest compatibility when it comes to matchers.\nCompatibility with Jasmine is not a goal at all.\nIn practice, the amount of required changes is usually small (mainly for <code>toBeTrue</code>/<code>toBeFalse</code> and <code>toHaveBeenCalledOnceWith</code>), but it does exist.\nFor asynchronous expectations, the pattern is even different. \nBut don&#39;t worry: the chances that your project uses <code>expectAsync</code> are very low, because the Angular documentation always showed Angular-specific helper functions instead.\nBecause of this, most projects will probably not need additional changes here.</p>\n<h3 id=\"spies-and-mocks\">Spies and mocks</h3>\n<p>The spying concept is similar to Jasmine and is provided through the <a href=\"https://vitest.dev/api/vi.html#vi-spyon\"><code>vi</code> object</a>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-built_in\">spyOn</span>(service, &#x27;loadData&#x27;)<span class=\"hljs-selector-class\">.and</span><span class=\"hljs-selector-class\">.returnValue</span>(of([]));\n\n<span class=\"hljs-comment\">// Vitest</span>\nvi<span class=\"hljs-selector-class\">.spyOn</span>(service, &#x27;loadData&#x27;)<span class=\"hljs-selector-class\">.mockReturnValue</span>(of([]));\n</code></pre><p>For spies created in Jasmine using <code>jasmine.createSpy()</code>, you now simply use <a href=\"https://vitest.dev/api/vi.html#vi-fn\"><code>vi.fn()</code></a> in Vitest:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-keyword\">const</span> onItem = jasmine.createSpy().and.returnValue(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-keyword\">const</span> onItem = vi.fn().mockReturnValue(<span class=\"hljs-literal\">true</span>);\n</code></pre><p>In Jasmine, you can pass a name for the spy as the first argument.\nThis is used to show more descriptive text in error messages and reports (see the <a href=\"https://jasmine.github.io/api/5.12/jasmine#.createSpy\">documentation</a>).\nIf you also want to give a descriptive name in Vitest, you can do so with <code>.mockName(&#39;onItem&#39;)</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// Jasmine - with name</span>\n<span class=\"hljs-keyword\">const</span> onItem = jasmine.createSpy(<span class=\"hljs-string\">&#x27;onItem&#x27;</span>).and.returnValue(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// Vitest - with name</span>\n<span class=\"hljs-keyword\">const</span> onItem = vi.fn().mockName(<span class=\"hljs-string\">&#x27;onItem&#x27;</span>).mockReturnValue(<span class=\"hljs-literal\">true</span>);\n</code></pre><h4 id=\"important-difference-default-behavior-of-spies\">Important difference: Default behavior of spies</h4>\n<p>In Jasmine, a spy returns <code>undefined</code> by default if no specific return value has been configured.\nIn Vitest, however, the <strong>original implementation is executed</strong> unless you explicitly set a mock value:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> book = <span class=\"hljs-comment\">{ rating: 3 }</span><span class=\"hljs-punctuation\">;</span>\n\n<span class=\"hljs-comment\">// Jasmine</span>\n<span class=\"hljs-keyword\">const</span> spy = spyOn(service, <span class=\"hljs-string\">&#x27;rateUp&#x27;</span>)<span class=\"hljs-punctuation\">;</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">result</span> = service.rateUp(book)<span class=\"hljs-punctuation\">;</span>\n<span class=\"hljs-comment\">// result = undefined (Spy stubbed the method)</span>\n\n<span class=\"hljs-comment\">// Vitest</span>\n<span class=\"hljs-keyword\">const</span> spy = vi.spyOn(service, <span class=\"hljs-string\">&#x27;rateUp&#x27;</span>)<span class=\"hljs-punctuation\">;</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">result</span> = service.rateUp(book)<span class=\"hljs-punctuation\">;</span>\n<span class=\"hljs-comment\">// result = { rating: 4 } (Original method is called!)</span>\n</code></pre><p>This difference is especially important when migrating existing Jasmine tests to Vitest.\nIf you need the original Jasmine behavior (i.e., returning <code>undefined</code>), you must explicitly use <code>.mockReturnValue(undefined)</code>.</p>\n<h4 id=\"cleaning-up-spies\">Cleaning up spies</h4>\n<p>Angular TestBed creates a new test environment before each test.\nThis means services are also re-instantiated. Spies on services therefore disappear automatically between tests.</p>\n<p>However, spies on <strong>global objects</strong> remain active:</p>\n<pre><code class=\"language-ts\">vi.<span class=\"hljs-title function_\">spyOn</span>(<span class=\"hljs-title class_\">Math</span>, <span class=\"hljs-string\">&#x27;random&#x27;</span>).<span class=\"hljs-title function_\">mockReturnValue</span>(<span class=\"hljs-number\">0.5</span>);\nvi.<span class=\"hljs-title function_\">spyOn</span>(<span class=\"hljs-variable language_\">console</span>, <span class=\"hljs-string\">&#x27;log&#x27;</span>);\n</code></pre><p>Without explicit cleanup, such spies would &quot;leak&quot; into subsequent tests and cause unexpected behavior (test pollution).</p>\n<p><strong>If</strong> you mock global objects, you should clean up spies in <code>afterEach()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { afterEach, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n\nafterEach(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  vi.restoreAllMocks();\n});\n</code></pre><p>Alternatively, you can set the option <code>test.restoreMocks: true</code> in <code>vitest.config.ts</code>, and Vitest will handle the cleanup automatically.</p>\n<p>Unfortunately, this setting is not the default.\nThe Angular team has <a href=\"https://github.com/angular/angular-cli/issues/30478\">deliberately chosen the standard Vitest behavior</a>, forgoing maximum Jasmine compatibility.</p>\n<h3 id=\"asynchrony-without-zonejs-using-vitest-timers\">Asynchrony without Zone.js using Vitest timers</h3>\n<p>Since Angular 21, unit tests run zoneless by default.\nThis means: The old Angular helpers <code>waitForAsync()</code> and <code>fakeAsync()</code>/<code>tick()</code> no longer work automatically, because they rely on Zone.js.\nFirst of all, this has nothing to do with Vitest.\nEven under Jasmine, these utilities would have had to be replaced in a zone-free environment.</p>\n<p>For simple asynchronous tests, you replace <code>waitForAsync()</code> with normal <code>async/await</code>, which has also been possible with Jasmine for many years.\nThe following update therefore works independently of the test runner:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// BEFORE: waitForAsync + Zone.js</span>\nit(<span class=\"hljs-string\">&#x27;should load data&#x27;</span>, waitForAsync(() =&gt; {\n  service.getData().then(result =&gt; {\n    expect(result.title).toContain(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);\n  });\n}));\n\n<span class=\"hljs-comment\">// MODERN: zoneless + async/await</span>\nit(<span class=\"hljs-string\">&#x27;should load data&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> service.getData();\n  expect(result.title).toContain(<span class=\"hljs-string\">&#x27;Hello&#x27;</span>);\n});\n</code></pre><p>It may be necessary to &quot;mock&quot; the service to make this example work.\nNothing else changes here.\nOnly the syntax is modern, and there is no difference between Jasmine and Vitest.</p>\n<p>The second Angular classic, <a href=\"https://angular.dev/api/core/testing/fakeAsync\"><code>fakeAsync()</code></a> and <a href=\"https://angular.dev/api/core/testing/tick\"><code>tick()</code></a>, does need a real replacement.\n(Note: These helpers are not part of Jasmine, but come from <code>@angular/core/testing</code>.)\nVitest provides its own <a href=\"https://vitest.dev/api/vi.html#fake-timers\">fake timer system</a>.\nUsing it requires some practice, because not all timers behave the same and not every test needs the same tools.\nLet&#39;s start with a simple time-based example.\nThe following function increases a counter after exactly five seconds:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startFiveSecondTimer</span>(<span class=\"hljs-params\">counter: { value: number }</span>) {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    counter.<span class=\"hljs-property\">value</span>++;\n  }, <span class=\"hljs-number\">5000</span>);\n}\n</code></pre><p>In such cases, <code>vi.advanceTimersByTime()</code> is ideal because you can simulate that exactly a certain amount of time has elapsed. It works very similarly to the old <code>tick(5000)</code>, but without the <code>fakeAsync()</code> zone:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startFiveSecondTimer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-basic&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startFiveSecondTimer&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;increases the counter after exactly 5 seconds&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    vi.useFakeTimers();\n\n    const counter = { value: <span class=\"hljs-number\">0</span> };\n    startFiveSecondTimer(counter);\n\n    <span class=\"hljs-regexp\">//</span> simulate the passing <span class=\"hljs-keyword\">of</span> <span class=\"hljs-number\">5</span> seconds\n    vi.advanceTimersByTime(<span class=\"hljs-number\">5000</span>);\n\n    expect(counter.value).toBe(<span class=\"hljs-number\">1</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre><p><code>advanceTimersByTime()</code> is therefore the direct replacement for <code>tick()</code>.\nIt works especially well when you want to simulate a specific time period or run multiple timers in the correct order.</p>\n<p>But not all timers are this simple.\nSometimes the code works only with timer-based actions, but without additional promises. The following example increments a counter multiple times using only timeouts and intervals:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> function startSyncSequence(counter: { value: number }) {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> { counter.value++; }, <span class=\"hljs-number\">300</span>);\n  const interval = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    counter.value++;\n    <span class=\"hljs-keyword\">if</span> (counter.value === <span class=\"hljs-number\">3</span>) {\n      <span class=\"hljs-built_in\">clearInterval</span>(interval);\n    }\n  }, <span class=\"hljs-number\">200</span>);\n}\n</code></pre><p>In cases where you want to run <em>all</em> timers one after another without manually moving time forward, you use <code>vi.runAllTimers()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startSyncSequence } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-sync&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startSyncSequence&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;runs all synchronous timers completely&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    vi.useFakeTimers();\n\n    const counter = { value: <span class=\"hljs-number\">0</span> };\n    startSyncSequence(counter);\n\n    <span class=\"hljs-regexp\">//</span> runs all timers <span class=\"hljs-keyword\">and</span> intervals <span class=\"hljs-keyword\">until</span> the timer queue <span class=\"hljs-keyword\">is</span> empty\n    vi.runAllTimers();\n\n    expect(counter.value).toBe(<span class=\"hljs-number\">3</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre><p>Here, <code>advanceTimersByTime()</code> would be possible, but needlessly complicated. <code>runAllTimers()</code> simply executes every timeout and every interval until nothing is left.</p>\n<p>It becomes even more interesting when timer callbacks contain asynchronous work themselves, for example through an <code>await</code> or promise chains.\nIn that case, <code>runAllTimers()</code> is no longer enough. The following example shows a typical pattern from real applications:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startAsyncJob</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title class_\">Promise</span>&lt;string&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-title function_\">async</span> () =&gt; {\n      <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;done&#x27;</span>); <span class=\"hljs-comment\">// asynchronous step in the callback</span>\n      <span class=\"hljs-title function_\">resolve</span>(data);\n    }, <span class=\"hljs-number\">100</span>);\n  });\n}\n</code></pre><p>To ensure the test handles both the timeout and the <code>await</code> inside the callback, Vitest provides <code>runAllTimersAsync()</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { describe, it, expect, vi } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vitest&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { startAsyncJob } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./timer-async&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;startAsyncJob&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  it(<span class=\"hljs-string\">&#x27;runs timers and async callbacks completely&#x27;</span>, <span class=\"hljs-keyword\">async</span> () =&gt; {\n    vi.useFakeTimers();\n\n    const promise = startAsyncJob();\n\n    <span class=\"hljs-regexp\">//</span> runs timers AND asynchronous logic inside the timer callbacks\n    <span class=\"hljs-keyword\">await</span> vi.runAllTimersAsync();\n\n    <span class=\"hljs-keyword\">await</span> expect(promise).resolves.toBe(<span class=\"hljs-string\">&#x27;done&#x27;</span>);\n\n    vi.useRealTimers();\n  });\n});\n</code></pre><p><code>runAllTimersAsync()</code> is therefore a good replacement for tests where <code>fakeAsync()</code> and <code>tick()</code> were used together with microtask flushing.</p>\n<h3 id=\"testbed-and-componentfixture\">TestBed and ComponentFixture</h3>\n<p>After all the small but subtle differences between Jasmine and Vitest, there is good news here:\nThe use of <code>TestBed</code> and <code>ComponentFixture</code> remains completely unchanged, because Vitest does not affect this area.\nYou still create your components or services using <code>TestBed</code>.\nAn explicit call to <code>fixture.detectChanges()</code> is still necessary to manually trigger the change detection.</p>\n<h2 id=\"known-limitations-and-pitfalls\">Known limitations and pitfalls</h2>\n<p>Special Karma use cases such as custom Karma plugins or custom browser launchers cannot be transferred directly to Vitest, as expected.\nYou will need to look for alternatives in the Vitest ecosystem.</p>\n<p>When switching to Vitest, your team may need a short adjustment phase, because some new API concepts like <code>vi.spyOn</code>, <code>vi.fn</code>, or strategies for resetting mocks are easy to learn but still different from Jasmine.\nMake sure your tests clean up any changes to global objects completely, and ideally use methods like <a href=\"https://vitest.dev/api/#aftereach\"><code>afterEach</code></a> together with <a href=\"https://vitest.dev/api/vi.html#vi-restoreallmocks\"><code>vi.restoreAllMocks()</code></a>.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>With Vitest as the default in Angular 21, testing becomes much more modern and faster.\nThe migration is usually straightforward, and the migration schematics help you get started.\nIn the past, <code>fakeAsync</code> and Zone.js magic were necessary, but today <code>async/await</code> and flexible fake timers are sufficient. \nAnd if you need realistic behaviour, the browser mode is available.\nOverall, this means shorter feedback loops, more robust tests, and less friction in daily work. Have fun testing!</p>\n<hr>\n\n<p><small>Many thanks to Ferdinand Malcher and Danny Koppenhagen for the review and the valuable feedback!</small></p>\n","meta":{"title":"Vitest in Angular 21: What's new and how to migrate?","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2025-11-20T00:00:00.000Z","lastModified":"2025-11-20T00:00:00.000Z","keywords":["Angular","Angular 21","Vitest","Karma","Jasmine"],"language":"en","header":{"url":"angular-vitest.jpg","width":2000,"height":1089},"hidden":false,"sticky":false,"darkenHeader":false}}
