{"slug":"2016-06-angular-for-all-platforms","html":"<p>In den letzten Jahre haben mehr als eine Million Entwickler erfolgreich mit AngularJS Single-Page-Anwendungen erstellt. Angular ist damit das populärste Framework um client-seitige Webanwendungen zu entwickeln (siehe z.B.  <a href=\"http://stackoverflow.com/research/developer-survey-2016#most-popular-technologies-per-occupation\">Stack Overflow</a>). Allerdings blieb das Framework dabei bislang immer auf das Web beschränkt. Das bedeutet, dass man bis dato völlig andere Tools, Programmiersprachen und Frameworks benötigte, um Anwendungen für den Desktop oder für mobile Geräte an den Start zu bringen.</p>\n<h2 id=\"plattformunabhängige-architektur\">Plattformunabhängige Architektur</h2>\n<p>Hier wird Angular interessant. Der komplette Rewrite von AngularJS 1 wurde stark auf Plattformunabhängigkeit ausgerichtet. Das bedeutet, dass das Framework so entworfen wurde, dass diverse Plattformen angesprochen werden können (sei es Web, Mobil, Desktop und sogar <a href=\"https://medium.com/@urish/building-simon-with-angular2-iot-fceb78bb18e5\">IoT-Geräte</a>).\nVereinfacht ausgedrückt ist die Angular-2-Architektur in zwei Teile aufgeteilt:</p>\n<ul>\n<li><strong>Plattform-unabhängiger Teil</strong>: hier wir das Markup (HTML) durch einen DOM-Adapter geparst und in so genannte „Proto Views“ compiliert. Dieser Prozess ist nicht spezifisch für eine Zielplattform und die meisten Funktionen können in den verschiedenen Plattformen genutzt werden</li>\n<li><strong>Plattform-spezifischer Teil</strong>: hier geschieht die Magie. Es werden plattformspezifische Renderer verwendet, um die unterschiedlichen Zielplattformen abzubilden. Jene Renderer haben die Aufgabe, aus den „Proto Views“ einen „Visual Tree“ zu generieren. Dieser kann dann verwendet werden, um die Oberfläche anzuzeigen. Der Renderer ist ebenso dafür verantwortlich, Änderungen und Events zwischen „Proto Views“ und „Visual Tree“ auszutauschen.</li>\n</ul>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2016-06-angular-for-all-platforms/images/Angular2-platform-agnostic.png\" alt=\"Angular2 Platform Agnostic\" title=\"Angular2 Platform Agnostic\"></p>\n<p>Durch diese durchdachte Architektur ist es möglich, neue Ziele zu definieren. Es müssen nur die notwendigen Erweiterungen implementiert werden.</p>\n<h2 id=\"native-mobile-anwendungen\">Native Mobile Anwendungen</h2>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2016-06-angular-for-all-platforms/images/LoginScreen.png\" alt=\"Login Screen\" title=\"Login Screen\"></p>\n<p>Auf Grundlage der plattformunabhängigen Architektur von Angular kann <a href=\"https://www.nativescript.org/\">NativeScript</a> seine Stärken zeigen. NativeScript ist ein Open-Source-Framework, mit dem man native Apps für iOS, Android und <a href=\"https://www.nativescript.org/blog/details/nativescript-runtime-preview-for-windows-10\">bald</a> auch Windows 10 bzw. Windows Phone 10 entwickeln kann. „Nativ“ bedeutet, dass tatsächlich echte native UI-Elemente aus der JavaScript-Umgebung heraus angesprochen werden können. Seit Mitte 2015 arbeiten das Angular-Team und das NativeScript-Team zusammen, um beide Frameworks miteinander zu verbinden. Das Ergebnis dieser Zusammenarbeit ist NativeScript 2.0 (<a href=\"http://sdtimes.com/nativescript-2-0-brings-mobile-strategy-options-angularjs-developers/\">News</a>).</p>\n<p>Die Lösung für Angular besteht darin, dass sehr spezielles Markup in HTML definiert wird. Diese Markup kann dann vom DOM-Adapter „Parse5“ geparst werden. Den größten Anteil an der Umsetzung nimmt der „NativeScript Renderer“ ein. Dieser garantiert nicht zuletzt den Austausch zwischen „Proto Views“ und  den nativen UI Komponenten der jeweiligen Platform:</p>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2016-06-angular-for-all-platforms/images/Angular2-with-NativeScript.png\" alt=\"Angular2 with NativeScript\" title=\"Angular2 with NativeScript\"></p>\n<h2 id=\"warum-nativescript\">Warum NativeScript?</h2>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2016-06-angular-for-all-platforms/images/nativescript-loves-angular.png\" alt=\"Login Screen\"></p>\n<h3 id=\"kurzum-es-funktioniert-wunderbar-mit-angular\">Kurzum: es funktioniert wunderbar mit Angular</h3>\n<p>Wenn man erstmal die neue <a href=\"https://angular.io/docs/ts/latest/guide/template-syntax.html\">Template-Syntax</a> von Angular gelernt hat, dann kann man das bestehende Wissen auf eine NativeScript-App übertragen. Hier ist ein einfaches Beispiel, wie ein Button verarbeitet wird. Es fällt auf, dass dies Komponente kein normales HTML beinhaltet:</p>\n<pre><code class=\"language-HTML\">@Component({\n  selector: <span class=\"hljs-string\">&quot;my-app&quot;</span>,\n  template: `<span class=\"language-javascript\">\n  &lt;<span class=\"hljs-title class_\">Page</span>&gt;\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StackLayout</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">&quot;Tap Me&quot;</span> (<span class=\"hljs-attr\">tap</span>)=<span class=\"hljs-string\">&quot;onTap()&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Label</span> [<span class=\"hljs-attr\">text</span>]=<span class=\"hljs-string\">&quot;counter&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Label</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Label</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;counter&gt;10&quot;</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">&quot;WOW!!! you are really good&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StackLayout</span>&gt;</span></span>\n  &lt;/<span class=\"hljs-title class_\">Page</span>&gt;\n  </span>`\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  counter: number = <span class=\"hljs-number\">0</span>;\n  onTap() {\n    this.counter++;\n  }\n}\n</code></pre><h3 id=\"abstraktionsschicht\">Abstraktionsschicht</h3>\n<p>NativeScript hat eine beträchtliche Abstraktionsschicht an Board, welche die Unterschiede zwischen den unterstützen  Zielplattformen (iOS, Android, UWP) ausbügelt. Hierdurch kann man mit einer einzigen Code-Basis alle nennenswerten Geräte bedienen. Besonders wichtig ist eine gescheite UI-Abstraktion, bei der jede <a href=\"http://docs.nativescript.org/ui/ui-views\">UI-Komponente</a> eine eigene native Implementierung besitzen muss. Zum Glück müssen wir nicht diese spezifische Implementierungen selbst entwickeln. Es wurde bereits eine grundlegende Auswahl an Bedienelementen vom NativeScript-Team umsetzt. So können wir folgendes Markup definieren und erhalten eine <em><strong>native Oberfläche</strong></em>, die in allen Betriebsystemen die jeweils zu erwarteten Bedienelemente besitzt:</p>\n<pre><code class=\"language-HTML\">@Component({\n  selector: <span class=\"hljs-string\">&quot;my-app&quot;</span>,\n  template: `\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Page</span>&gt;</span>\n    </span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StackLayout</span>&gt;</span>\n      </span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">&quot;GO&quot;</span> (<span class=\"hljs-attr\">tap</span>)=<span class=\"hljs-string\">&quot;onTap()&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;100&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span></span><span class=\"language-xml\">\n      </span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Label</span> [<span class=\"hljs-attr\">text</span>]=<span class=\"hljs-string\">&quot;selectedIndex&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;50&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;100&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Label</span>&gt;</span></span><span class=\"language-xml\">\n      </span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListPicker</span> [<span class=\"hljs-attr\">selectedIndex</span>]=<span class=\"hljs-string\">&quot;selectedIndex&quot;</span> [<span class=\"hljs-attr\">items</span>]=<span class=\"hljs-string\">&quot;items&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ListPicker</span>&gt;</span></span><span class=\"language-xml\">\n      </span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DatePicker</span> [<span class=\"hljs-attr\">day</span>]=<span class=\"hljs-string\">&quot;day&quot;</span> [<span class=\"hljs-attr\">month</span>]=<span class=\"hljs-string\">&quot;month&quot;</span> [<span class=\"hljs-attr\">year</span>]=<span class=\"hljs-string\">&quot;year&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">DatePicker</span>&gt;</span></span><span class=\"language-xml\">\n      </span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TimePicker</span> [<span class=\"hljs-attr\">hour</span>]=<span class=\"hljs-string\">&quot;hour&quot;</span> [<span class=\"hljs-attr\">minute</span>]=<span class=\"hljs-string\">&quot;minute&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TimePicker</span>&gt;</span></span><span class=\"language-xml\">\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StackLayout</span>&gt;</span></span><span class=\"language-xml\">\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Page</span>&gt;</span></span>\n  `\n})\n</code></pre><p>Weiterhin bietet das NPM-Paket „<strong>T</strong>elerik <strong>N</strong>ative<strong>S</strong>cript Core Modules“ (kurz: <a href=\"https://github.com/NativeScript/NativeScript/tree/master/tns-core-modules\">tns-core-modules</a>) eine reiche Auswahl an Funktionalitäten, die man gemeinhin für die App-Entwicklung benötigt. Möchte man z.B. ein Foto mit der Kamera machen, so muss man lediglich das entsprechende <a href=\"https://docs.nativescript.org/hardware/camera#using-the-camera-module-to-take-a-picture\">Kamera-Modul</a> mit <code>require</code> laden und es aufrufen. Wie die Kamera in den jeweiligen Betriebssystemen aufgerufen werden muss, braucht uns dann nicht mehr zu interessieren.</p>\n<pre><code class=\"language-JavaScript\">import {Image} from <span class=\"hljs-string\">&quot;ui/image&quot;</span><span class=\"hljs-comment\">;</span>\nimport cameraModule <span class=\"hljs-operator\">=</span> require(<span class=\"hljs-string\">&quot;camera&quot;</span>)<span class=\"hljs-comment\">;</span>\n\ncameraModule.takePicture().then(picture <span class=\"hljs-operator\">=</span>&gt; {\n    console.log(<span class=\"hljs-string\">&quot;Result is an image source instance&quot;</span>)<span class=\"hljs-comment\">;</span>\n    var image <span class=\"hljs-operator\">=</span> new Image()<span class=\"hljs-comment\">;</span>\n    image.imageSource <span class=\"hljs-operator\">=</span> picture<span class=\"hljs-comment\">;</span>\n})<span class=\"hljs-comment\">;</span>\n</code></pre><p>Wenn Sie allerding neugierig sind, was unter Android (<a href=\"https://github.com/NativeScript/NativeScript/blob/master/tns-core-modules/camera/camera.android.ts#L9-L111\">Github</a>) oder iOS (<a href=\"https://github.com/NativeScript/NativeScript/blob/master/tns-core-modules/camera/camera.ios.ts#L82-L126\">Github</a>) passiert, wenn die Methode <code>takePicture</code> aufgerufen wird, dann schauen sich am einfach das <a href=\"https://github.com/NativeScript/NativeScript/tree/master/tns-core-modules\">Github-Repository</a> an. Dort sind alle Core-Komponenten gesammelt.</p>\n<h3 id=\"direkter-zugriff-auf-native-apis\">Direkter Zugriff auf Native APIs</h3>\n<p>Natürlich kann keine Abstraktionsschicht alle möglichen Funktionen abdecken. Ebenso möchte man womöglich für bestimmte Aufgaben eine native Fremdbibliothek eines Drittanbieters einbinden. Unter NativeScript stellt dies kein Problem dar. Es ist nämlich stets möglich, direkt aus <strong>JavaScript</strong> heraus Android- oder iOS-APIs anzusprechen. Zum Beispiel wird folgender Quelltext unter Android (und nur unter Android) eine Instanz des Datei-Objekts erzeugen:</p>\n<pre><code class=\"language-JavaScript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">openFile</span><span class=\"hljs-params\">()</span> {\n  <span class=\"hljs-keyword\">var</span> myFile = <span class=\"hljs-keyword\">new</span> java.io.File(<span class=\"hljs-string\">&quot;filePath.txt&quot;</span>);\n  <span class=\"hljs-keyword\">return</span> myFile;\n}\n</code></pre><p>Das Beste an der gezeigten Syntax ist die Tatsache, dass sowohl  Namespaces, als auch Attribute und Typen sowie die gesamten Konventionen bei der Benennung dem Pendant aus der Android- bzw. iOS-Dokumentation entspricht. Dasselbe gilt für Fremdbibliotheken. So lässt sich mit geringem Aufwand ein Code-Fragment aus den Dokumentationen oder dem Netz per Copy-and-Paste zum Laufen bringen. Hinter den Kulissen verwendet NativeScript „Reflection“, um eine Liste von APIs aufzubauen, die auf der aktuellen Plattform zur Verfügung stehen und zum globalen Gültigkeitsbereich hinzugefügt werden. Gibt es eine API auf dem Endgerät, dann kann man diese auch aufrufen!</p>\n<h2 id=\"lust-auf-mehr\">Lust auf mehr?</h2>\n<p><a href=\"http://www.developer-week.de/\"><img src=\"%%MARKDOWN_BASE_URL%%/blog/2016-06-angular-for-all-platforms/images/developer-week.jpg\" alt=\"Banner DWX\"></a></p>\n<p>Auf der DWX-Developer Week 2016 wird es zwei Vorträge zu NativeScript geben.</p>\n<ul>\n<li><a href=\"http://www.developer-week.de/Programm/Veranstaltung/(event)/20557\">Introduction to NativeScript</a>, 20.06.2016 17:00 - 18:00 Uhr, Track: Cross-Plattform<br>In diesem Talk erfahren Sie, wie NativeScript aufgebaut ist, wie es funktioniert und vor allem wie man performante mobile Apps mit dem Framework entwickeln kann.</li>\n<li><a href=\"http://www.developer-week.de/Programm/Veranstaltung/(event)/20683\">Native Mobile Apps mit NativeScript und Angular</a>, 22.06.2016 09:00 - 10:00 Uhr, Track: Mobile Architekturen\nIn diesem schauen wir uns das Zusammenspiel zwischen NativeScript und Angular genauer an. Als besonderes Schmankerl zeigen wir Ihnen, wie man auf Grundlage von Angular Code für mobile Apps und Webanwendungen wiederverwenden kann.</li>\n</ul>\n<p>Sie sollten auch den ausführlichen <a href=\"http://docs.nativescript.org/angular/tutorial/ng-chapter-0\">Getting Started guide</a> durchlesen. Hier erfahren Sie alles Notwendige, um native Apps für iOS und Android auf Basis von Angular2 und NativeScript zu entwickeln.</p>\n<hr>\n<p><a href=\"https://twitter.com/sebawita\"><img src=\"%%MARKDOWN_BASE_URL%%/blog/2016-06-angular-for-all-platforms/images/Sebastian_Witalec_small.png\" alt=\"Sebastian\"></a>\n<a href=\"https://twitter.com/sebawita\">Sebastian Witalec</a>,  Technical Evangelist for Telerik, a Progress company</p>\n<p><a href=\"https://twitter.com/johanneshoppe\"><img src=\"%%MARKDOWN_BASE_URL%%/blog/2016-06-angular-for-all-platforms/images/Johannes_Hoppe_small.png\" alt=\"Joannes\"></a>\n<a href=\"https://twitter.com/johanneshoppe\">Johannes Hoppe</a>, Telerik Developer Expert</p>\n","meta":{"title":"Mobile Apps mit Angular entwickeln","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2016-06-15T00:00:00.000Z","lastModified":"2016-08-25T00:00:00.000Z","keywords":["Angular","NativeScript"],"language":"de","header":{"url":"images/nativescript-loves-angular.png","width":1200,"height":223},"hidden":false,"sticky":false,"darkenHeader":false}}
