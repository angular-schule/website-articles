{"slug":"2021-12-rxjs-turn-signal","html":"<p>Reactive Programming with RxJS is a great way to model event-based systems.\nIt can feel super abstract sometimes. However, we can even apply the principles of Reactive Programming to our everyday world!\nWhenever I sit in a car, I&#39;m impressed by how the electronics work. Wouldn&#39;t it be cool to build all of this stuff with RxJS?\nI want to take you on a car ride into how we can implement a turn indicator with RxJS!</p>\n<div style=\"max-width: 300px; margin: auto\">\n  <img src=\"%%MARKDOWN_BASE_URL%%/blog/2021-12-rxjs-turn-signal/car.gif\" alt=\"Animation of a blinking car\">\n</div>\n\n<h2 id=\"how-the-car-circuit-works\">How the car circuit works</h2>\n<p>First things first, let&#39;s take a look at the original behavior of the circuit in the car.\nModern cars have an incredible amount of buttons, but setting a turn signal is still basically the same. The handle next to the steering wheel is nothing more than an on/off switch which can be locked in the end position.\nThis trigger behaves as follows:</p>\n<ul>\n<li>If you lightly touch the handle it instantly flips back to the resting position. The switch output is <em>ON</em> directly followed by <em>OFF</em>.</li>\n<li>If you push the handle to the end it will be locked in this position (<em>ON</em>). It only comes back to the resting position (<em>OFF</em>) if you pull the handle back again. (It also flips back when we turn the steering wheel in the opposite direction, but this out of scope here.)</li>\n</ul>\n<p>The electronic part of the car does the following now:</p>\n<ul>\n<li>Whenever the trigger is <em>ON</em>, the turn signal starts to alternate between on and off.</li>\n<li>The signal ends ...<ul>\n<li>when the trigger is turned back to <em>OFF</em></li>\n<li>but not before at least 3 on/off cycles have been finished.</li>\n</ul>\n</li>\n</ul>\n<p>That means, if you just softly push the trigger, the turn signal outputs 3 on/off cycles.\nIf you lock the trigger, the signal is repeated until you pull the trigger back.\nWhen you lock the trigger and pull it back immediately, the signal performs 3 cycles as well.</p>\n<h2 id=\"implementation-with-rxjs\">Implementation with RxJS</h2>\n<p>With this overview in mind we can now start to implement things with RxJS step by step.</p>\n<h2 id=\"the-raw-signal\">The raw signal</h2>\n<p>At first, we need to construct the raw turn signal as an alternating sequence of <code>true</code> and <code>false</code>.\nTo create such a periodically emitting Observable, we can use the <code>timer()</code> and <code>interval()</code> creation functions from RxJS.</p>\n<p>Calling <code>interval(500)</code> will create an endless stream of emissions. However, the first element will be emitted after 500 ms.\nWhat we want is to start the signal immediately upon subscription.\nThis is why we choose <code>timer(0, 500)</code> here: It creates an interval as well, but the first emission will come up 0 ms after subscription.</p>\n<p>Both <code>timer()</code> and <code>interval()</code> emit a sequence of numbers starting at <code>0</code>. You can interpret those as the index of the emitted element.\nHow do we convert those increasing numbers to alternating booleans? Using the modulo operator and <code>map()</code>!</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-attribute\">const</span> stepTimeMs = <span class=\"hljs-number\">500</span>;\n<span class=\"hljs-attribute\">const</span> rawSignal$ = timer(<span class=\"hljs-number\">0</span>, stepTimeMs).pipe(map(e =&gt; e % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>));\n</code></pre><p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2021-12-rxjs-turn-signal/marble-map.svg\" alt=\"Marble Diagram map\"></p>\n<h2 id=\"the-trigger\">The trigger</h2>\n<p>Next up, we need to build the trigger handle to control the turn signal.\nThe switch behavior described above can be adapted with mouse clicks – except for the locking position which we ignore in this example.\nIf you simply press down the mouse button, it instantly goes back up. If you keep it pressed it will flip back up when you release it.</p>\n<p>In order to keep this simple and framework-agnostic we use an HTML button here and access it through <code>querySelector()</code>. Of course, those events can also be captured in other ways, e.g. with an Event Binding in Angular.</p>\n<p>With pure JavaScript and RxJS, events can be captured with the <code>fromEvent()</code> creation function from RxJS.\nWe create two streams here: one for the button press (pushing the trigger) and another one when the button is released (pulling the trigger back).</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;trigger&quot;</span>&gt;</span>Trigger<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre><pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> triggerBtn = <span class=\"hljs-built_in\">document</span>.<span class=\"hljs-built_in\">querySelector</span>(<span class=\"hljs-string\">&#x27;#trigger&#x27;</span>);\n\n<span class=\"hljs-keyword\">const</span> press$ = fromEvent(triggerBtn, <span class=\"hljs-string\">&#x27;mousedown&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> release$ = fromEvent(<span class=\"hljs-built_in\">document</span>, <span class=\"hljs-string\">&#x27;mouseup&#x27;</span>);\n</code></pre><p>We decided to capture the release event not on the button but on <code>document</code>.\nThis is an important detail: You can move the mouse away while the button is pressed and the release event might be fired somewhere else – we don&#39;t want to miss this.</p>\n<h2 id=\"first-wiring\">First wiring</h2>\n<p>We can now already start to wire things together.\nWhenever the button is pressed we want to start the signal.\nIn other words, we want to convert each emission from <code>press$</code> into what is emitted by <code>rawSignal$</code>.\nThis way, whenever we press the button, <code>rawSignal$</code> should be subscribed and the emissions from the signal should be the result of our operation.</p>\n<p>That is an excellent use-case for one of the four flattening operators: <code>concatMap</code>, <code>mergeMap</code>, <code>switchMap</code>, <code>exhaustMap</code>.\nWe want to map each emission of <code>press$</code> to the emissions from <code>rawSignal$</code>.</p>\n<pre><code class=\"language-ts\">press$.pipe(\n  concatMap(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> rawSignal$)\n)\n</code></pre><p>We should now talk about which operator is the right one for this case.\nIn terms of mapping to another Observable and merging its submissions into the output stream, they all do the same thing.\nTheir difference, however, lies in how they handle concurrent subscriptions.\nSo what happens if the signal is already running and we press the button again?</p>\n<ul>\n<li><strong><code>concatMap</code></strong> builds a queue. When the first signal is finished, it will proceed with the next one. So if we click the button multiple times in a row, each of those signal &quot;requests&quot; will become a signal, finally. Honestly, this is not what we want!</li>\n<li><strong><code>mergeMap</code></strong> concurrently subscribes to all of the inner Observables. When we press the button multiple times, multiple signals will be running simultaneously and act against each other. Not good!</li>\n<li><strong><code>switchMap</code></strong> will cancel the running subscription when another one appears. So when we press the button while a signal is running, it will be cancelled and the new one will be started. Sounds much better!</li>\n<li><strong><code>exhaustMap</code></strong> is one of the less commonly used operators: As long as an inner subscription is running, all other incoming requests will be ignored. That means, if we press the button while a signal is running, nothing will happen. There is also no queue like with <code>concatMap</code>.</li>\n</ul>\n<p>From this evaluation, we can see that either <code>exhaustMap</code> or <code>switchMap</code> would be a good fit for our use-case.\n<code>exhaustMap</code> is a bit more resilient, though: When the signal is active, is has the highest priority and will be finished before any other signal can be started at all.</p>\n<pre><code class=\"language-ts\">press$.pipe(\n  exhaustMap(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> rawSignal$)\n)\n</code></pre><p>In the following marble diagram you can see that emissions from the source are being ignored as long as the signal is running.</p>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2021-12-rxjs-turn-signal/marble-exhaustmap.svg\" alt=\"Marble Diagram exhaustMap\"></p>\n<h2 id=\"displaying-the-signal\">Displaying the signal</h2>\n<p>Before we continue with our RxJS implementation, let&#39;s display what we&#39;ve achieved until here.\nTo visualize the turn signal we can highlight an element in orange when active.\nWe subscribe to our Observable to process the signal state and add/remove a CSS class accordingly.\nIn the full example below we created a car with CSS. However, you can also use a simple div element:</p>\n<pre><code class=\"language-html\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">id</span>=<span class=\"hljs-string\">&quot;signal&quot;</span>&gt;&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n</code></pre><pre><code class=\"language-css\"><span class=\"hljs-selector-class\">.on</span> {\n  <span class=\"hljs-attribute\">background</span>: orange;\n}\n</code></pre><pre><code class=\"language-ts\">const signalEl = document.querySelector(<span class=\"hljs-string\">&#x27;#signal&#x27;</span>);\n\npress$.pipe(\n  exhaustMap(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> rawSignal$)\n).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">lightOn</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (lightOn) {\n    signalEl.classList.add(<span class=\"hljs-string\">&#x27;on&#x27;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    signalEl.classList.remove(<span class=\"hljs-string\">&#x27;on&#x27;</span>);\n  }\n});\n</code></pre><p>We can now see that – once we press the button – the signal starts to flash.\nBut it never stops! Our <code>rawSignal$</code> is an endless stream so we need to think about how we can terminate it.</p>\n<h2 id=\"terminating-the-signal\">Terminating the signal</h2>\n<p>We have mapped each button press to our alternating signal, but this signal never ended.\nLet&#39;s change this! To terminate a stream we can use the <code>takeUntil()</code> operator.\nIt takes a <em>notifier</em> Observable as an argument. When this notifier emits once, the result stream will be completed.</p>\n<p>Let&#39;s explain this with a simpler example: We have a long-running interval which we combine with <code>takeUntil()</code>.\nAs the notifier we use an Observable that emits after 5200 ms (using <code>timer()</code> with just one argument creates an Observable that fires once and then completes).\nThe resulting Observable will emit the interval events, and will then complete after 5200 ms when the notifier fires.</p>\n<pre><code class=\"language-ts\">const notifier$ = timer(<span class=\"hljs-number\">5200</span>);\n\ntimer(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1000</span>).pipe(\n  takeUntil(notifier$)\n).subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(e));\n</code></pre><p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2021-12-rxjs-turn-signal/marble-takeuntilsimple.svg\" alt=\"Marble Diagram takeUntil\"></p>\n<p>Back to our turn signal, things become a little more challenging.\nThe signalling period must be terminated when at least 3 cycles have passed <em>and</em> the trigger has been released.\nThe order of these events can be different, though:</p>\n<ul>\n<li><strong>Case 1:</strong> We release the trigger <em>before</em> 3 cycles have finished: wait for 3 cycles to finish.</li>\n<li><strong>Case 2:</strong> The trigger is still pressed after 3 cycles are finished: wait for the trigger to be released.</li>\n</ul>\n<h3 id=\"counting-cycles\">Counting cycles</h3>\n<p>The first part of our closing notifier is the cycle count. We want the notifier to emit once after 3 cycles have passed.\nSince we know the step interval time (we&#39;ve used this before to create the interval) and the number of cycles, we can construct this using a <code>timer()</code>.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> cycles = 3;\n<span class=\"hljs-keyword\">const</span> cyclesFinished$ = <span class=\"hljs-keyword\">timer</span>(stepTimeMs * cycles * 2);\n</code></pre><p>The step time has to be multiplied by 2 because a full cycle consists of two steps (on and off).\nFor the trigger release, we have already created the necessary event stream <code>release$</code>, so we have the two parts ready to be combined.</p>\n<h3 id=\"creating-the-notifier\">Creating the notifier</h3>\n<p>As described before, to create our closing notifier we have to wait for</p>\n<ul>\n<li>a trigger release <em>and</em></li>\n<li>3 cycles finished</li>\n</ul>\n<p>The <code>forkJoin()</code> creation functions comes to rescue:\nThis function combines Observables. It subscribes to all of the sources at once. Then, after all the sources have completed, it emits one single event with the final results of all sources.</p>\n<p>To make this possible, it is necessary that all sources eventually complete.\nOur cycle counter is a deterministic timer which will emit once and then complete, so everything&#39;s fine here.\nHowever, the <code>release$</code> stream captures all <code>mouseup</code> events from everywhere and will never complete.\nWhat we are actually interested in is the <em>next</em> emission only, so we combine it with <code>take(1)</code>.\nThat way, we wait for the first emission only and then complete immediately.</p>\n<p>Our notifier can be defined as follows:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> closingNotifier$ = fork<span class=\"hljs-built_in\">Join</span>([\n  release$.pipe(take(<span class=\"hljs-number\">1</span>)),\n  <span class=\"hljs-built_in\">timer</span>(stepTimeMs * cycles * <span class=\"hljs-number\">2</span>),\n]);\n</code></pre><h3 id=\"putting-things-together\">Putting things together</h3>\n<p>Now that we have created the notifier that tells us when the signalling period has to be over, we can put things together.\nWhat we want to terminate is the individual signal stream that the press event is mapped to.\nRight now, we convert each trigger press event to to an endlessly emitting signal event stream.\nThis is the part we have to change: We want the signalling to eventually come to an end.\nIt is therefore important to apply the <code>takeUntil()</code> operator to the inner mapped Observable, not to the outer stream that is derived from <code>press$</code>.</p>\n<pre><code class=\"language-ts\">press$.pipe(\n  exhaustMap(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> rawSignal$.pipe(\n    takeUntil(closingNotifier$)\n  ))\n)\n</code></pre><p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2021-12-rxjs-turn-signal/marble-takeuntil.svg\" alt=\"Marble Diagram takeUntil with closingNotifier\"></p>\n<h2 id=\"switching-off-the-light\">Switching off the light</h2>\n<p>We can now see that the signal comes to an end after at least 3 cycles and when we release the button.\nHowever, there&#39;s an tiny edge case:\nWhen we press the button for longer than 3 cycles and then release it while the signal is active, the light stays on!\nWe have interrupted the signal stream somewhere in the middle and no subsequent emission made the light go off.</p>\n<p>To change this, we have to tell our signal stream to always end with going off.\nSo whenever the inner mapped Observable completes, it should emit <code>false</code>.\nSay hello to the <code>endWith()</code> operator!</p>\n<pre><code class=\"language-ts\">press$.pipe(\n  exhaustMap(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> rawSignal$.pipe(\n      takeUntil(closingNotifier$),\n      endWith(<span class=\"hljs-literal\">false</span>)\n    )\n  )\n)\n</code></pre><p>Try it out: Press the trigger button for a longer time. Then release it while the light is on. It will immediately be switched off.</p>\n<h2 id=\"bonus-making-it-mobile-friendly\">Bonus: Making it mobile-friendly</h2>\n<p>In the beginning, we used <code>mousedown</code> and <code>mouseup</code> events to capture trigger press and release.\nThis works fine in a desktop browser. However, on mobile touch devices we rather have to use <code>touchstart</code> and <code>touchend</code> events instead.</p>\n<p>Since the browser only emits one or the other event, we can combine them and use the first one that is available.\nThis can be achieved with the <code>race()</code> creation function: It listens to multiple Observables at once. When one of them emits, it wins the race and all of the others are unsubscribed.\nIn our case, whoever comes first – <code>mousedown</code> or <code>touchstart</code> – will be used.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> press$ = race(\n  fromEvent(signalEl, <span class=\"hljs-string\">&#x27;mousedown&#x27;</span>),\n  fromEvent(signalEl, <span class=\"hljs-string\">&#x27;touchstart&#x27;</span>)\n);\n<span class=\"hljs-keyword\">const</span> release$ = race(\n  fromEvent(<span class=\"hljs-built_in\">document</span>, <span class=\"hljs-string\">&#x27;mouseup&#x27;</span>),\n  fromEvent(<span class=\"hljs-built_in\">document</span>, <span class=\"hljs-string\">&#x27;touchend&#x27;</span>)\n);\n</code></pre><h2 id=\"wrap-up\">Wrap up</h2>\n<p>With relatively few lines of code we have created a car turn indicator with RxJS!\nEach trigger press is converted to an alternating signal.\nWhile a signal cycle is running, all other presses will be ignored.\nThe signal ends after the trigger is released and at least 3 cycles have been finished.\nRegardless of how the interrupted signal ends, it will always switch off the light when it leaves the room.</p>\n<p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2021-12-rxjs-turn-signal/marble-final.svg\" alt=\"Marble Diagram with exhaustMap and the final result\"></p>\n<p>Here is the full code:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { timer, race, forkJoin, fromEvent, map, take, exhaustMap, takeUntil, endWith } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> stepTimeMs = <span class=\"hljs-number\">500</span>;\n<span class=\"hljs-keyword\">const</span> cycles = <span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-comment\">// the raw and endless signal, alternating true/false</span>\n<span class=\"hljs-keyword\">const</span> rawSignal$ = <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-number\">0</span>, stepTimeMs).<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> e % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>));\n\n<span class=\"hljs-keyword\">const</span> triggerBtn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#trigger&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> signalEl = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#signal&#x27;</span>);\n\n<span class=\"hljs-comment\">// trigger interactions</span>\n<span class=\"hljs-keyword\">const</span> press$ = <span class=\"hljs-title function_\">race</span>(\n  <span class=\"hljs-title function_\">fromEvent</span>(triggerBtn, <span class=\"hljs-string\">&#x27;mousedown&#x27;</span>),\n  <span class=\"hljs-title function_\">fromEvent</span>(triggerBtn, <span class=\"hljs-string\">&#x27;touchstart&#x27;</span>)\n);\n<span class=\"hljs-keyword\">const</span> release$ = <span class=\"hljs-title function_\">race</span>(\n  <span class=\"hljs-comment\">// we&#x27;re listening on document here in case the user</span>\n  <span class=\"hljs-comment\">// moves away from the trigger and releases somewhere else</span>\n  <span class=\"hljs-title function_\">fromEvent</span>(<span class=\"hljs-variable language_\">document</span>, <span class=\"hljs-string\">&#x27;mouseup&#x27;</span>),\n  <span class=\"hljs-title function_\">fromEvent</span>(<span class=\"hljs-variable language_\">document</span>, <span class=\"hljs-string\">&#x27;touchend&#x27;</span>)\n);\n\n<span class=\"hljs-comment\">// determines when to stop the signalling period</span>\n<span class=\"hljs-keyword\">const</span> closingNotifier$ = <span class=\"hljs-title function_\">forkJoin</span>([\n  release$.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">take</span>(<span class=\"hljs-number\">1</span>)),\n  <span class=\"hljs-title function_\">timer</span>(stepTimeMs * cycles * <span class=\"hljs-number\">2</span>),\n]);\n\n<span class=\"hljs-comment\">// it all starts with a trigger press</span>\npress$.<span class=\"hljs-title function_\">pipe</span>(\n  <span class=\"hljs-comment\">// convert each press into a signal</span>\n  <span class=\"hljs-comment\">// while the signal runs, ignore all trigger presses</span>\n  <span class=\"hljs-title function_\">exhaustMap</span>(<span class=\"hljs-function\">() =&gt;</span>\n    rawSignal$.<span class=\"hljs-title function_\">pipe</span>(\n      <span class=\"hljs-comment\">// stop the signal when the notifier emits</span>\n      <span class=\"hljs-title function_\">takeUntil</span>(closingNotifier$),\n      <span class=\"hljs-comment\">// if the signal stops while being ON, switch off the light</span>\n      <span class=\"hljs-title function_\">endWith</span>(<span class=\"hljs-literal\">false</span>)\n    )\n  )\n).<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">lightOn</span>) =&gt;</span> {\n  <span class=\"hljs-comment\">// highlight the DOM element</span>\n  <span class=\"hljs-keyword\">if</span> (lightOn) {\n    signalEl.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;on&#x27;</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    signalEl.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">remove</span>(<span class=\"hljs-string\">&#x27;on&#x27;</span>);\n  }\n});\n</code></pre><p><strong>You can find a full working demo on Stackblitz:</strong></p>\n<iframe style=\"width:100%; height: 30em\" title=\"Stackblitz Demo\" src=\"https://stackblitz.com/edit/rxjs-turn-signal?ctl=1&embed=1&file=index.ts\"></iframe>\n\n<hr>\n<p><strong>Did you enjoy this article? Then please share it in your network! Do you know another interesting circuit? Drop us an email and maybe we will also implement this case with RxJS!</strong></p>\n<hr>\n<p>Special thanks to</p>\n<ul>\n<li>Lisa Möller who created the CSS car in the demo and took the header photo.</li>\n<li>Johannes Hoppe and Danny Koppenhagen for review and feedback.</li>\n</ul>\n<p><small><strong>Header image:</strong> Traffic in Moscow, 2018, by Lisa Möller</small></p>\n","meta":{"title":"RxJS in the real world: Building a car turn indicator","author":"Ferdinand Malcher","mail":"mail@fmalcher.de","published":"2021-12-14T00:00:00.000Z","lastModified":"2021-12-14T00:00:00.000Z","keywords":["RxJS","Reactive Programming","Observable","Car"],"language":"en","header":{"url":"rxjs-turnsignal.jpg","width":2000,"height":1048},"hidden":false,"sticky":false,"darkenHeader":false}}
