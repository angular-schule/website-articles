{"slug":"2024-11-effect-afterrendereffect","html":"<p>Angular 19 has a significant change with the simplification of the <code>effect()</code> API and <a href=\"https://github.com/angular/angular/pull/57549\">the introduction of <code>afterRenderEffect()</code></a>. \nThis change impacts how Angular handles post-render tasks and is especially useful for applications that rely on precise timing for rendering and DOM manipulation. \nIn this article, we&#39;ll explore how these two APIs compare, when to use each, and how to take advantage of phased execution with <code>afterRenderEffect()</code>.</p>\n<h2 id=\"contents\">Contents</h2>\n<ul>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#angular-19-vs-previous-versions-whats-different\">Angular 19 vs. Previous Versions: What&#39;s Different?</a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#core-differences-between-effect-and-afterrendereffect\">Core Differences Between <code>effect()</code> and <code>afterRenderEffect()</code></a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#introducing-effect\">Introducing <code>effect()</code></a><ul>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#example-for-effect-setting-multiple-things-at-once\">Example for <code>effect()</code>: setting multiple things at once</a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#when-to-choose-effect-over-computed\">When to choose <code>effect()</code> over <code>computed()</code></a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#introducing-afterrendereffect\">Introducing <code>afterRenderEffect()</code></a><ul>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#understanding-the-phases\">Understanding the Phases</a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#phases-only-run-again-when-dirty-through-signal-dependencies\">Phases Only Run Again When &quot;Dirty&quot; Through Signal Dependencies</a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#example-of-afterrendereffect-dynamically-resizing-a-textarea\">Example of <code>afterRenderEffect()</code>: Dynamically Resizing a Textarea</a></li>\n</ul>\n</li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#migration-guide-from-angulars-lifecycle-hooks-to-signal-based-reactivity\">Migration Guide: From Angular&#39;s Lifecycle Hooks to Signal-Based Reactivity</a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#reminder-afterrendereffect-shouldnt-be-used-in-line-of-business-code\">Reminder: <code>afterRenderEffect()</code> shouldn&#39;t be used in line-of-business code</a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#best-practices-for-using-effect-and-afterrendereffect\">Best Practices for Using <code>effect()</code> and <code>afterRenderEffect()</code></a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#demo-application\">Demo Application</a></li>\n<li><a href=\"/blog/2024-11-effect-afterrendereffect#conclusion\">Conclusion</a></li>\n</ul>\n<h2 id=\"angular-19-vs-previous-versions-whats-different\">Angular 19 vs. Previous Versions: What&#39;s Different?</h2>\n<p>The <code>effect()</code> API was introduced as part of Angular&#39;s new signal-based reactivity model <a href=\"https://blog.angular.dev/angular-v16-is-here-4d7a28ec680d\">in Angular 16</a>.\nAngular 19 now introduces a significant update to the <code>effect()</code> API, making it easier to manage side effects directly within <code>effect()</code> functions, even when they involve setting signals. </p>\n<p>Before this change, effects had a more restrictive approach: It was discouraged to set signals within <code>effect()</code>, and to allow this behavior, we had to enable the <code>allowSignalWrites</code> flag:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// OLD WAY</span>\neffect(() =&gt; {\n  <span class=\"hljs-keyword\">this</span>.mySignal.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;demo&#x27;</span>);\n}, { allowSignalWrites: <span class=\"hljs-keyword\">true</span> })\n</code></pre><p>Previously, Angular&#39;s documentation advised developers to avoid setting signals in <code>effect()</code>, as it could lead to issues like <code>ExpressionChangedAfterItHasBeenChecked</code> errors, circular updates, or unnecessary change detection cycles.\nDevelopers were encouraged to keep <code>effect()</code> usage limited to specific side effects, such as:</p>\n<ul>\n<li>Logging changes for analytics or debugging purposes,</li>\n<li>Keeping data in sync with local storage (e.g. <code>window.localStorage</code>),</li>\n<li>Implementing custom DOM behaviors not achievable with template syntax or</li>\n<li>Handling third-party UI libraries, such as rendering to a <code>&lt;canvas&gt;</code> element or integrating charting libraries.</li>\n</ul>\n<p>However, developers found that the <code>allowSignalWrites</code> flag was not as effective in encouraging these patterns as initially expected.\nThe flag was planned as an exception, but it was too often used in legitimate cases where setting signals was reasonable or even necessary, such as updating a signal after a series of changes or working with multiple signals.\nIn response, Angular&#39;s new approach now allows setting signals within <code>effect()</code> by default, removing the need for <code>allowSignalWrites</code>.\nThis more flexible design reflects Angular&#39;s commitment to simplifying the development experience.\nSee the <a href=\"https://blog.angular.dev/latest-updates-to-effect-in-angular-f2d2648defcd\">official blog post</a> that confirms this new guidance.</p>\n<p>We interpret this new information in the following way:</p>\n<blockquote>\n<p>üí° <strong>It is now a valid case to use <code>effect()</code> for state updates or side effects that are difficult to achieve with other reactive primitives like <code>computed()</code></strong>.</p>\n</blockquote>\n<p>This change to the paradigm is in line with new features introduced in Angular 19, such as <a href=\"https://angular.schule/blog/2024-11-linked-signal\"><code>linkedSignal()</code></a> and <code>resource()</code>.\nBoth help to maintain cleaner and more declarative state management patterns where possible. \nGood patterns are no longer enforced by the <code>allowSignalWrites</code> flag, but instead by useful high-level signal APIs.</p>\n<p>With this shift, here&#39;s a new general rule of thumb:</p>\n<ul>\n<li><strong>Use <code>effect()</code></strong> for tasks traditionally performed in <code>ngOnInit</code> or <code>ngOnChanges</code>.</li>\n<li><strong>Use <code>afterRenderEffect()</code></strong> for tasks traditionally handled in <code>ngAfterViewInit</code> or <code>ngAfterViewChecked</code>, or when you need to interact directly with rendered DOM elements.</li>\n</ul>\n<p>Let&#39;s dive into the specifics! üöÄ</p>\n<h2 id=\"core-differences-between-effect-and-afterrendereffect\">Core Differences Between <code>effect()</code> and <code>afterRenderEffect()</code></h2>\n<p>Both <code>effect()</code> and <code>afterRenderEffect()</code> are designed to track and respond to changes in signals, but they differ in timing and use cases.</p>\n<ul>\n<li><strong><code>effect()</code></strong> runs as part of the Angular change detection cycle and can now safely modify signals without any additional flags.</li>\n<li><strong><code>afterRenderEffect()</code></strong> is a lower-level API that executes after the DOM has been updated. \nIt&#39;s particularly suited for tasks that require interacting directly with the DOM, such as measuring element sizes or making complex visual updates.</li>\n</ul>\n<p>Here&#39;s a simple comparison to illustrate how these functions operate:</p>\n<pre><code class=\"language-typescript\">counter = signal(<span class=\"hljs-number\">0</span>);\n\neffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">`Current counter value: <span class=\"hljs-subst\">${this.counter()}</span>`</span>);\n});\n\nafterRenderEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;DOM rendering completed for this component&#x27;</span>);\n});\n</code></pre><p>As expected, the console output for <code>afterRenderEffect()</code> is triggered after the output of <code>effect()</code>.</p>\n<h2 id=\"introducing-effect\">Introducing <code>effect()</code></h2>\n<p>In this article, we discuss effects that are created within a component. \nThese are called <strong>component effects</strong> and allow safe reading and writing of component properties and signals. \nIt is also possible to create effects in services. \nIf a service is provided at the root level in the application (also known as a singleton), these effects are called <strong>root effects</strong>.</p>\n<p>The main difference between these types of effects is their timing. \nComponent effects operate as part of Angular&#39;s change detection, allowing them to safely read input signals and manage views that depend on component state. \nRoot effects, however, run as microtasks, independently of the component tree or change detection.</p>\n<p>In this article, we focus solely on <strong>component effects</strong>, which allow to safely read and write signals within components.</p>\n<h3 id=\"example-for-effect-setting-multiple-things-at-once\">Example for <code>effect()</code>: setting multiple things at once</h3>\n<p>In the following example we use <code>effect()</code> to synchronize form fields based on the input signal <code>currentBook</code>.\nThe API for Reactive Forms has not yet been updated to work hand in hand with signals, so we still need to patch the form as we have done in the past.\nHowever, some improvements to the Reactive Forms API have already been promised.\nWe also want to set another signal after we have patched the form. </p>\n<p>Here is our example of a form that can create a new book and edit an existing book:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-book-form&#x27;</span>,\n  imports: [ReactiveFormsModule],\n  template: `\n    @let c = bookForm.controls;\n\n    &lt;form [formGroup]=<span class=\"hljs-string\">&quot;bookForm&quot;</span> (ngSubmit)=<span class=\"hljs-string\">&quot;submitForm()&quot;</span>&gt;\n      &lt;label for=<span class=\"hljs-string\">&quot;isbn&quot;</span>&gt;ISBN&lt;/label&gt;\n      &lt;input id=<span class=\"hljs-string\">&quot;isbn&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;c.isbn&quot;</span> /&gt;\n\n      &lt;label for=<span class=\"hljs-string\">&quot;title&quot;</span>&gt;Title&lt;/label&gt;\n      &lt;input id=<span class=\"hljs-string\">&quot;title&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;c.title&quot;</span> /&gt;\n\n      &lt;label for=<span class=\"hljs-string\">&quot;description&quot;</span>&gt;Description&lt;/label&gt;\n      &lt;textarea id=<span class=\"hljs-string\">&quot;description&quot;</span> [formControl]=<span class=\"hljs-string\">&quot;c.description&quot;</span>&gt;&lt;/textarea&gt;\n\n      @let formLabel = isEditMode() ? <span class=\"hljs-string\">&#x27;Edit Book&#x27;</span> : <span class=\"hljs-string\">&#x27;Create Book&#x27;</span>;\n      &lt;button type=<span class=\"hljs-string\">&quot;submit&quot;</span> [attr.aria-label]=<span class=\"hljs-string\">&quot;formLabel&quot;</span>&gt;\n        {{ formLabel }}\n      &lt;/button&gt;\n\n    &lt;/form&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookFormComponent</span> {\n\n  currentBook = input&lt;Book | undefined&gt;();\n\n  bookForm = new FormGroup({\n    isbn: new FormControl(<span class=\"hljs-comment\">/* ... */</span>),\n    title: new FormControl(<span class=\"hljs-comment\">/* ... */</span>),\n    description: new FormControl(<span class=\"hljs-comment\">/* ... */</span>),\n  });\n  \n  isEditMode = signal(<span class=\"hljs-literal\">false</span>);\n\n  <span class=\"hljs-keyword\">constructor</span>() {\n    effect(() =&gt; {\n      <span class=\"hljs-keyword\">const</span> book = <span class=\"hljs-keyword\">this</span>.currentBook();\n      <span class=\"hljs-keyword\">if</span> (book) {\n        <span class=\"hljs-keyword\">this</span>.bookForm.patchValue(book);\n        <span class=\"hljs-keyword\">this</span>.bookForm.controls.isbn.disable();\n        <span class=\"hljs-keyword\">this</span>.isEditMode.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">true</span>);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>.bookForm.controls.isbn.enable();\n        <span class=\"hljs-keyword\">this</span>.isEditMode.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-literal\">false</span>);\n      }\n    });\n  }\n\n  submitForm() {\n    <span class=\"hljs-comment\">// ...handle form submission logic</span>\n  }\n}\n</code></pre><p>In this example, <code>effect()</code> is ideal for handling the side effect (patching the form) without rerunning unnecessary computations. \nWe are also free to set signals in the effect now.\nTo show that this is now perfectly valid, we updated another signal during that phase.\nWe dediced for a signal called <code>isEditMode</code>, that is updated accordingly.\nIn the past, we would have been using <code>ngOnChanges</code> to patch the form when the input was changed.</p>\n<h3 id=\"when-to-choose-effect-over-computed\">When to choose <code>effect()</code> over <code>computed()</code></h3>\n<p>The previous constraints on <code>effect()</code> have been removed, so it is now more challenging to decide when to use <code>computed()</code> or <code>effect()</code>.\nIn our opinion, it depends on the use case:</p>\n<ul>\n<li><strong>Use <code>computed()</code></strong> for deriving a value based on other signals, especially when you need a pure, read-only reactive value. Inside a computed signal, it is strictly not allowed to set other signals.\nWe covered <code>computed()</code> and <code>linkedSignal()</code> in this article: <strong><a href=\"https://angular.schule/blog/2024-11-linked-signal\">Angular 19: Introducing LinkedSignal for Responsive Local State Management</a></strong></li>\n<li><strong>Use <code>effect()</code></strong> if the operation is more complex, involves setting multiple signals or requires side effects to be performed outside the world of signals, such as synchronising reactive form states or logging events.</li>\n</ul>\n<p>For patching forms, there is currently no better approach than using effects. \nThis approach can also be easily migrated to what would have been done in the past with <code>ngOnChanges</code> ‚Äì which is great.\nHowever, it remains questionable whether a computed signal would have been a better fit for <code>isEditMode</code>.\nThe following is also possible:</p>\n<pre><code class=\"language-ts\">isEditMode = computed(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> !!this.currentBook());\n</code></pre><p>It is not easy to make a decision here, and we suspect that it highly depends on personal taste.\nPerhaps we have to accept that in some situations both options are absolutely valid. üôÇ</p>\n<h2 id=\"introducing-afterrendereffect\">Introducing <code>afterRenderEffect()</code></h2>\n<p>While <code>effect()</code> is intended for general reactive state management and will see daily use, <code>afterRenderEffect()</code> is more specialized and is generally reserved for advanced cases. \nIt&#39;s designed specifically for scenarios requiring precise timing after Angular completes a rendering cycle. \nThis is useful for complex DOM manipulations that cannot be achieved purely with Angular&#39;s reactivity and are often tied to low-level updates,\nlike measuring element dimensions, directly managing animations, or orchestrating third-party libraries.</p>\n<p>The new <code>afterRenderEffect()</code> function allows us to control when specific tasks are executed during the DOM update process.\nThe API itself mirrors the functionality of </p>\n<ul>\n<li><a href=\"https://angular.dev/api/core/afterEveryRender\"><code>afterEveryRender</code></a> <em>(register callbacks to be invoked each time the application finishes rendering, during the specified phases.)</em> and </li>\n<li><a href=\"https://angular.dev/api/core/afterNextRender\"><code>afterNextRender</code></a> <em>(register callbacks to be invoked the next time the application finishes rendering, during the specified phases.)</em>.</li>\n</ul>\n<p>The documentation recommends specifying explicit phases with <code>afterNextRender</code> to avoid significant performance losses. \nThere is a similar recommendation for <code>afterRenderEffect()</code>: There is one signature that is intended for use and another that exists but is not recommended.</p>\n<p>However, there is one big difference between the hook methods and the new <code>afterRenderEffect()</code>:</p>\n<blockquote>\n<p><strong>üí° Values are propagated from phase to phase as signals instead of as plain values.</strong> </p>\n</blockquote>\n<p>As a result, later phases may not need to execute if the values returned by earlier phases do not change ‚Äì and if there is no other dependency established (we will talk about this soon).\nBefore we start, here are some important facts to know about the effects created by <code>afterRenderEffect()</code>:</p>\n<ul>\n<li><strong>Post-Render Execution:</strong> These effects run when it&#39;s safe to make changes to the DOM. (<a href=\"https://docs.google.com/presentation/d/1puZmyZ-dgnt6_b0nOBaDMpyf_FmQld1h8yAmWxjA6gk/edit?usp=sharing\">source: keynote slides from ng-poland 2024</a>)</li>\n<li><strong>Phased Execution:</strong> These effects can be registered for specific phases of the render cycle. \nThe Angular team recommends following these phases for optimal performance.</li>\n<li><strong>Signal Integration:</strong> These effects work seamlessly with Angular&#39;s signal reactivity system, and signals can be set during the phases.</li>\n<li><strong>Selective Execution:</strong> These effects run at least once but only rerun when marked &quot;dirty&quot; due to signal dependencies. If no signal changes, the effect won&#39;t trigger again.</li>\n<li><strong>No SSR:</strong> These effects execute only in browser environments, not on the server.</li>\n</ul>\n<h3 id=\"understanding-the-phases\">Understanding the Phases</h3>\n<p>Phased execution helps to avoid unnecessary layout recalculations.\nWe can register effects for each phase by specifying a callback function:</p>\n<pre><code class=\"language-ts\">afterRenderEffect({\n\n  <span class=\"hljs-comment\">// Read DOM properties before writes.</span>\n  earlyRead: <span class=\"hljs-function\">(<span class=\"hljs-params\">onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> E,\n\n  <span class=\"hljs-comment\">// Execute DOM write operations.</span>\n  write: <span class=\"hljs-function\">(<span class=\"hljs-params\">signal1: firstAvailableSignal&lt;[E]&gt;, onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> W,\n\n  <span class=\"hljs-comment\">// Allows for combined reads and writes but should be used sparingly!</span>\n  mixedReadWrite: <span class=\"hljs-function\">(<span class=\"hljs-params\">signal2: firstAvailableSignal&lt;[W, E]&gt;, onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> M,\n\n  <span class=\"hljs-comment\">// Execute DOM reads after writes are completed.</span>\n  read: <span class=\"hljs-function\">(<span class=\"hljs-params\">signal3: firstAvailableSignal&lt;[M, W, E]&gt;, onCleanup: EffectCleanupRegisterFn</span>) =&gt;</span> <span class=\"hljs-keyword\">void</span>\n}): AfterRenderRef;\n</code></pre><p>This is a simplified version of the <a href=\"https://github.com/angular/angular/blob/f3d931627523843281efb6f4207008ebbbbbb668/packages/core/src/render3/reactivity/after_render_effect.ts#L331\">real <code>afterRenderEffect()</code> signature</a>.\nThe first callback receives no parameters.\nEach subsequent phase callback will receive the return value of the previous phase <strong>as a signal</strong>.\nSo, if the <code>earlyRead</code> effect returns a value of type <code>E</code>, and the next registered effect is <code>write</code>, then <code>write</code> will receive a signal of <code>E</code>.\nHowever, if the next registered effect is <code>mixedReadWrite</code>, this effect will receive a signal of <code>E</code>, and so on.\nThe <code>read</code> effect has no return value.\nThe passing of values between phases can be used to coordinate work across multiple phases.</p>\n<p>Effects run in the following phase order, only when dirty through signal dependencies:</p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Rule</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. <code>earlyRead</code></td>\n<td>Use this phase to <strong>read</strong> from the DOM before a subsequent write callback. Prefer the <code>read</code> phase if reading can wait until after the <code>write</code> phase. <strong>Never</strong> write to the DOM in this phase.</td>\n</tr>\n<tr>\n<td>2. <code>write</code></td>\n<td>Use this phase to <strong>write</strong> to the DOM. <strong>Never</strong> read from the DOM in this phase.</td>\n</tr>\n<tr>\n<td>3. <code>mixedReadWrite</code></td>\n<td>Use this phase to read from and write to the DOM simultaneously. <strong>Do not</strong> use this phase if it is possible to divide the work among the other phases instead.</td>\n</tr>\n<tr>\n<td>4. <code>read</code></td>\n<td>Use this phase to <strong>read</strong> from the DOM. <strong>Never</strong> write to the DOM in this phase.</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://next.angular.dev/api/core/afterRenderEffect\">According to the docs</a>, you should prefer using the <code>read</code> and <code>write</code> phases over the <code>earlyRead</code> and <code>mixedReadWrite</code> phases when possible, to avoid performance degradation.\nAngular is unable to verify or enforce that phases are used correctly and instead relies on each developer to follow the documented guidelines.</p>\n<p>As mentioned before, there is also a second signature of <code>afterRenderEffect()</code> that accepts a single callback. \nThis function registers an effect to run after rendering is complete, specifically during the <code>mixedReadWrite</code> phase.\nHowever, the Angular documentation recommends specifying an explicit phase for the effect whenever possible to avoid potential performance issues.\nTherefore, we won&#39;t cover this signature in our article, as its usage is not recommended.</p>\n<h3 id=\"phases-only-run-again-when-dirty-through-signal-dependencies\">Phases Only Run Again When &quot;Dirty&quot; Through Signal Dependencies</h3>\n<p>When <code>afterRenderEffect()</code> is initially called, all registered effects execute once in sequence.\nHowever, for any effect to run again, it must be marked as &quot;dirty&quot; due to a change in signal dependencies. \nThis dependency-based system helps Angular optimize performance by preventing redundant executions.</p>\n<p>For an effect to be marked &quot;dirty&quot; and eligible to rerun, it must establish a dependency on a signal that changes. \nIf the effect does not track any signals, or if the tracked signals remain unchanged, the effect won&#39;t be marked as dirty, and its code will not re-execute.</p>\n<p>There are two main ways to establish dependencies in <code>afterRenderEffect()</code>:</p>\n<ol>\n<li><p><strong>Tracking the Value of a Previous Phase&#39;s Output</strong>: \n  Each effect can return a value to be passed as input to the next effect (except <code>earlyRead</code>, which has no previous effect). \n  This value is wrapped in a signal, and if we then read that signal in the following effect, we create a dependency. \n  It&#39;s important to understand that we must actually execute the signal&#39;s getter function because simply passing the signal around is insufficient to establish a dependency.</p>\n</li>\n<li><p><strong>Directly Tracking Component Signals</strong>: \n  We can also create dependencies by accessing other signals directly within the effect. \n  In the upcoming example, we read a signal from the component within the <code>earlyRead</code> effect to create a dependency and ensure the effect executes multiple times.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>üí° Angular ensures that effects only re-execute when their tracked signals change, marking the effect itself as &quot;dirty.&quot;\n  Without these signal dependencies, each effect will run only once!</strong></p>\n</blockquote>\n<h3 id=\"example-of-afterrendereffect-dynamically-resizing-a-textarea\">Example of <code>afterRenderEffect()</code>: Dynamically Resizing a Textarea</h3>\n<p>Let&#39;s take a closer look at <code>afterRenderEffect()</code> through a practical example.</p>\n<p>In this example, we demonstrate how <code>afterRenderEffect()</code> can be used to dynamically adjust the height of a <code>&lt;textarea&gt;</code> based on both user and programmatic changes.\nThe textarea is designed to be resized by dragging the bottom-right corner, but we also want it to automatically adjust its height periodically.\nTo achieve this, we read the current height from the DOM and update it based on a central signal called <code>extraHeight</code>.</p>\n<p>This example was inspired by the article <a href=\"https://medium.com/@amosisaila/angular-19-afterrendereffect-5cf8e6482256\">&quot;Angular 19: afterRenderEffect&quot;</a> by Amos Lucian Isaila Onofrei, which we modified for a better separation between reads and writes. (The original example reads from the DOM in the <code>write</code> effect, which is explicitly not recommended according to the Angular docs.)</p>\n<p>Our example will demonstrate how to use multiple phases (<code>earlyRead</code>, <code>write</code>, and <code>read</code>) in <code>afterRenderEffect()</code> to handle DOM manipulation efficiently, while respecting Angular&#39;s guidelines for separating reads and writes:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, viewChild, <span class=\"hljs-title class_\">ElementRef</span>, signal, afterRenderEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@angular/core&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-resizable&#x27;</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;textarea #myElement style=&quot;border: 1px solid black; height: 100px; resize: vertical;&quot;&gt;\n    Resizable Element\n  &lt;/textarea&gt;`</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ResizableComponent</span> {\n\n  myElement = viewChild.<span class=\"hljs-property\">required</span>&lt;<span class=\"hljs-title class_\">ElementRef</span>&gt;(<span class=\"hljs-string\">&#x27;myElement&#x27;</span>);\n  extraHeight = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n\n    <span class=\"hljs-keyword\">const</span> effect = <span class=\"hljs-title function_\">afterRenderEffect</span>({\n\n      <span class=\"hljs-comment\">// earlyRead: Captures the current height of the textarea from the DOM.</span>\n      <span class=\"hljs-attr\">earlyRead</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">onCleanup</span>) =&gt;</span> {\n\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">`earlyRead executes`</span>);\n\n        <span class=\"hljs-comment\">// Make `extraHeight` a dependency of `earlyRead`</span>\n        <span class=\"hljs-comment\">// Now this code it will run again whenever `extraHeight` changes</span>\n        <span class=\"hljs-comment\">// Hint: remove this statement, and `earlyRead` will execute only once!</span>\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;earlyRead: extra height:&#x27;</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">extraHeight</span>());\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">currentHeight</span>: <span class=\"hljs-built_in\">number</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">myElement</span>()?.<span class=\"hljs-property\">nativeElement</span>.<span class=\"hljs-property\">offsetHeight</span>;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;earlyRead: offset height:&#x27;</span>, currentHeight);\n\n        <span class=\"hljs-comment\">// Pass the height to the next effect</span>\n        <span class=\"hljs-keyword\">return</span> currentHeight;\n      },\n\n      <span class=\"hljs-comment\">// write: Sets the new height by adding `extraHeight` to the captured DOM height.</span>\n      <span class=\"hljs-attr\">write</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">currentHeight, onCleanup</span>) =&gt;</span> {\n\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">`write executes`</span>);\n\n        <span class=\"hljs-comment\">// Make `extraHeight` a dependency of `write`</span>\n        <span class=\"hljs-comment\">// Hint: change this code to `const newHeight = currentHeight();`, </span>\n        <span class=\"hljs-comment\">// so that we have no dependency to a signal that is changed, and `write` will be executed only once</span>\n        <span class=\"hljs-comment\">// Hint 2: if `currentHeight` changes in `earlyRead`, `write` will re-run, too. </span>\n        <span class=\"hljs-comment\">// resize the textarea manually to achieve this</span>\n        <span class=\"hljs-keyword\">const</span> newHeight = <span class=\"hljs-title function_\">currentHeight</span>() + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">extraHeight</span>();\n\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">myElement</span>().<span class=\"hljs-property\">nativeElement</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">height</span> = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${newHeight}</span>px`</span>;\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;write: written height:&#x27;</span>, newHeight);\n\n        <span class=\"hljs-title function_\">onCleanup</span>(<span class=\"hljs-function\">() =&gt;</span> {\n          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;write: cleanup is called&#x27;</span>, newHeight);\n        });\n\n        <span class=\"hljs-comment\">// Pass the height to the next effect</span>\n        <span class=\"hljs-comment\">// Hint: pass the same value to `read`, e.g. `return 100`, to see how `read` is skipped</span>\n        <span class=\"hljs-keyword\">return</span> newHeight;\n      },\n\n      <span class=\"hljs-comment\">// The read effect logs the updated height</span>\n      <span class=\"hljs-attr\">read</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">newHeight, onCleanup</span>) =&gt;</span> {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">&#x27;read executes&#x27;</span>);\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;read: new height:&#x27;</span>, <span class=\"hljs-title function_\">newHeight</span>());\n      }\n    });\n\n    <span class=\"hljs-comment\">// Trigger a new run every 4 seconds by setting the signal `extraHeight`</span>\n    <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">&#x27;---- new round ----&#x27;</span>);\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">extraHeight</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> ++x)\n    }, <span class=\"hljs-number\">4_000</span>);\n\n    <span class=\"hljs-comment\">// Try this, if the signal value stays the same, nothing will happen</span>\n    <span class=\"hljs-comment\">// setInterval(() =&gt; this.extraHeight.update(x =&gt; x), 4_000);</span>\n\n    <span class=\"hljs-comment\">// cleanup callbacks are also executed when we destroy the hook</span>\n    <span class=\"hljs-comment\">// setTimeout(() =&gt; effect.destroy(), 20_000);</span>\n  }\n}\n</code></pre><p>In our setup, an interval updates the <code>extraHeight</code> signal every 4 seconds.\nBy updating <code>extraHeight</code>, we create a &quot;dirty&quot; state that restarts the <code>afterRenderEffect()</code> phases, which checks and adjusts the height of the <code>&lt;textarea&gt;</code> as needed:</p>\n<p><strong>Explanation of the Phases</strong></p>\n<p>In this example, an interval updates <code>extraHeight</code> every 4 seconds, creating a new round of execution across the phases. \nHere&#39;s a breakdown of each effect:</p>\n<ol>\n<li><p><strong><code>earlyRead</code> Phase</strong>: \n  The effect that runs in the <code>earlyRead</code> phase captures the current height of the <code>textarea</code> by reading the <code>offsetHeight</code> directly from the DOM. \n  This read operation from the DOM is necessary because the textarea can also be resized manually by the user, so its size must be checked before any adjustment.\n  The result, <code>currentHeight</code>, is passed to the next effect. \n  In this effect, we use the <code>extraHeight</code> as our tracked dependency to ensure that the code will run multiple times.\n  We encourage you to remove this statement: <code>console.log(&#39;earlyRead: extra height:&#39;, this.extraHeight());</code>.\n  If you do this, you will see that the <code>earlyRead</code> effect will only execute once and that any manual change to the textarea will be ignored in the next run.</p>\n</li>\n<li><p><strong><code>write</code> Phase</strong>: \n  The effect that runs in the <code>write</code> phase adds the <code>extraHeight</code> value to the captured <code>currentHeight</code> and updates height style property of the <code>&lt;textarea&gt;</code>.\n  This DOM write operation directly adjusts the element&#39;s height in pixels.\n  An <code>onCleanup</code> function is provided to handle any required cleanup or resources before the next write operation.\n  In this example no cleanup is required, but we wanted to mention the fact that long-running tasks (such as a timeout) should be cleaned up.\n  The cleanup will be called before entering the same phase again, or if the effect itself is destroyed via the <code>AfterRenderRef</code>.\n  The <code>write</code> effect then passes the new height, <code>newHeight</code>, to the <code>read</code> effect.\n  Hint: Pass the same value to <code>read</code> (e.g. <code>return 100</code>) and you will see that the follow-up phase won&#39;t be executed.\n  Setting the same number twice won&#39;t be considered a change, so the <code>write</code> effect won&#39;t mark the <code>read</code> effect as dirty.</p>\n</li>\n<li><p><strong><code>read</code> Phase</strong>: \n  The effect that runs in the <code>read</code> phase logs the <code>newHeight</code>. \n  We could also read from the DOM in that phase and store the result to a new signal.\n  But in this example this work is not necessary, because the <code>earlyRead</code> is already doing that job.</p>\n</li>\n</ol>\n<blockquote>\n<p>We encourage you to scroll down to check out our Demo Application. \n  Feel free to follow the hints in the comments to experiment with the specifics of each phase.</p>\n</blockquote>\n<h2 id=\"migration-guide-from-angulars-lifecycle-hooks-to-signal-based-reactivity\">Migration Guide: From Angular&#39;s Lifecycle Hooks to Signal-Based Reactivity</h2>\n<p>In April 2023, the Angular team outlined their vision of signal-based components in <a href=\"https://github.com/angular/angular/discussions/49682\">RFC #49682</a>.\nThe long-term goal is to phase out traditional lifecycle hooks, though the RFC discusses retaining <code>ngOnInit</code> and <code>ngOnDestroy</code>. (Now, we also have replacements for these.)\nThe document proposed the introduction of <code>afterRenderEffect()</code> as part of a roadmap, and with Angular 19, the final vision of signal-based components is starting to take shape.</p>\n<p>The addition of <code>effect()</code> and <code>afterRenderEffect()</code> showcases how Angular is moving in this direction. \nThese effects are more intuitive for managing component state changes and post-render interactions, thus making the old lifecycle hooks redundant.\nFor instance, <code>afterRenderEffect()</code> is designed to handle tasks traditionally managed by <code>ngAfterViewInit</code> and <code>ngAfterViewChecked</code>.</p>\n<p>Migrating from Angular lifecycle hooks to <code>effect()</code> and <code>afterRenderEffect()</code> is straightforward:</p>\n<ul>\n<li><strong><code>ngOnInit</code> / <code>ngOnChanges</code></strong> ‚Üí <code>effect()</code>: Handles signal-based logic and other state.</li>\n<li><strong><code>ngAfterViewInit</code> / <code>ngAfterViewChecked</code></strong> ‚Üí <code>afterRenderEffect()</code>: Manages DOM manipulations post-render.</li>\n</ul>\n<p>Or to put it another way, here&#39;s a direct mapping:</p>\n<table>\n<thead>\n<tr>\n<th>Lifecycle Hook</th>\n<th>Replacement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ngOnInit</code></td>\n<td><code>effect()</code></td>\n</tr>\n<tr>\n<td><code>ngOnChanges</code></td>\n<td><code>effect()</code></td>\n</tr>\n<tr>\n<td><code>ngAfterViewInit</code></td>\n<td><code>afterRenderEffect()</code></td>\n</tr>\n<tr>\n<td><code>ngAfterViewChecked</code></td>\n<td><code>afterRenderEffect()</code></td>\n</tr>\n</tbody></table>\n<p><strong>Hint:</strong> If you&#39;re transitioning away from classic lifecycle hooks, consider using <a href=\"https://angular.dev/api/core/DestroyRef\"><code>DestroyRef</code></a>.\nIt allows you to set callbacks for cleanup or destruction tasks, so that you no longer need <code>ngOnDestroy</code> in your codebase. </p>\n<h2 id=\"reminder-afterrendereffect-shouldnt-be-used-in-line-of-business-code\">Reminder: <code>afterRenderEffect()</code> shouldn&#39;t be used in line-of-business code</h2>\n<p>If you rarely needed <code>ngAfterViewInit</code> or <code>ngAfterContentChecked</code> in the past, <code>afterRenderEffect()</code> will likely be equally uncommon in your codebase. \nIt&#39;s aimed at addressing rare tasks and won&#39;t be used as frequently as foundational features like \n<a href=\"https://angular.dev/api/core/signal\"><code>signal()</code></a>, \n<a href=\"https://angular.dev/api/core/computed\"><code>computed()</code></a>, \n<code>effect()</code>, <code>linkedSignal()</code>, or <code>resource()</code>.</p>\n<p>In this context, think of <code>afterRenderEffect()</code> as similar in importance to <code>ngAfterViewInit</code>.\nIt&#39;s an advanced lifecycle tool rather than a daily necessity. \nUse <code>afterRenderEffect()</code> only when you need precise control over DOM operations, low-level APIs, or third-party libraries that require specific timing and coordination across rendering phases.\nIf you&#39;re not building your own component library (and there are already many component libraries available), <code>afterRenderEffect()</code> should be rarely seen.</p>\n<p>In everyday application code, <code>effect()</code> and other signal-based APIs will cover most reactive needs without the added complexity that <code>afterRenderEffect()</code> brings. \nIn short, reach for <code>afterRenderEffect()</code> only when standard approaches don&#39;t meet your specialized requirements.</p>\n<h2 id=\"best-practices-for-using-effect-and-afterrendereffect\">Best Practices for Using <code>effect()</code> and <code>afterRenderEffect()</code></h2>\n<p>To make the most of these new APIs, here are a few best practices:</p>\n<ol>\n<li><strong>Use <code>computed()</code> for simple dependencies:</strong> Reserve <code>effect()</code> for more complex or state-dependent operations.</li>\n<li><strong>Choose phases carefully in <code>afterRenderEffect()</code>:</strong> Stick to the specific phases and avoid <code>mixedReadWrite</code> when possible.</li>\n<li><strong>Use <code>onCleanup()</code> to manage resources:</strong> Always use <code>onCleanup()</code> within effects for any resource that needs disposal, especially with animations or intervals.</li>\n<li><strong>Direct DOM Manipulations only when necessary:</strong> Remember, Angular&#39;s reactive approach minimizes the need for manual DOM manipulations. \n  Use <code>afterRenderEffect()</code> only when Angular&#39;s templating isn&#39;t enough.</li>\n</ol>\n<h2 id=\"demo-application\">Demo Application</h2>\n<p>To make it easier to see the effects in action, we&#39;ve created a demo application that showcases all the examples discussed in this article.\nThe first link leads to the source code on GitHub, where you can download it.\nThe second link opens a deployed version of the application for you to try out.\nLast but not least, the third link provides an interactive demo on StackBlitz, where you can edit the source code and see the results in real time.</p>\n<blockquote>\n<p><strong><a href=\"https://github.com/angular-schule/demo-effect-and-afterRenderEffect\">1Ô∏è‚É£ Source on GitHub: demo-effect-and-afterRenderEffect</a></strong><br>\n<strong><a href=\"https://angular-schule.github.io/demo-effect-and-afterRenderEffect/\">2Ô∏è‚É£ Deployed application</a></strong><br>\n<strong><a href=\"https://stackblitz.com/github/angular-schule/demo-effect-and-afterRenderEffect\">3Ô∏è‚É£ StackBlitz Demo</a></strong></p>\n</blockquote>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Both APIs open up new, elegant ways of state and DOM management in Angular: reactive, precise and clear. \nThose who familiarise themselves with <code>effect()</code> and <code>afterRenderEffect()</code> at an early stage will benefit today from the architecture of tomorrow.\nTake the opportunity to try out the new interfaces in your application!\nThe functions have been considered <strong>stable</strong> since Angular 20.</p>\n<hr>\n\n<p><strong>Thanks to Ferdinand Malcher for <em>intensive</em> review and feedback!</strong></p>\n<p><small><strong>Cover image:</strong> Composed with Dall-E and Adobe Firefly</small></p>\n","meta":{"title":"Reactive Angular: Mastering effect and afterRenderEffect","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2024-11-14T00:00:00.000Z","lastModified":"2025-06-18T00:00:00.000Z","keywords":["Angular","JavaScript","Signals","Reactive Programming","Effect","afterRenderEffect","Angular 19","Angular 20"],"language":"en","header":{"url":"effect.jpg","width":2000,"height":1089},"sticky":false,"hidden":false,"darkenHeader":false}}
