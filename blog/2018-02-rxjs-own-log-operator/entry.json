{"slug":"2018-02-rxjs-own-log-operator","html":"<p><strong>In this article we will cover how to write our own custom operators for RxJS pipelines.</strong>\n<strong>We will build a simple logging operator and learn how we can debug observable sequences.</strong></p>\n<hr>\n\n<p>When working with Angular we come into contact with <a href=\"http://reactivex.io/rxjs/\">RxJS</a> almost every day:\nusing reactive forms, doing routing, <a href=\"https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html\">taming snakes</a> or using <a href=\"https://github.com/ngrx/platform/blob/master/docs/effects/README.md\">NgRx effects</a>.\nThinking reactively makes you revisit your common patterns, due to its declarative way of writing code is conceptually different from the imperative style we&#39;ve been doing for years.</p>\n<blockquote>\n<p>If you are new to RxJS you will find a great introduction here:\n<a href=\"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754\">AndrÃ© Staltz: &quot;The introduction to Reactive Programming you&#39;ve been missing&quot;</a>. \nIf you are familiar with the German language, you might want to take a look at our <a href=\"/buch\">book about Angular (and RxJS)</a>.</p>\n</blockquote>\n<h2 id=\"building-a-log-operator\">Building a <code>log()</code> operator</h2>\n<p>When working with observable sequences it&#39;s quite helpful to sneak into the data stream to see what&#39;s happening in there. Doing so, we usually end up writing lines like these over and over again: </p>\n<pre><code class=\"language-typescript\">myObservable$.pipe(\n  tap(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(e)),\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">thing</span> =&gt;</span> thing.id),\n  tap(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;end&#x27;</span>, e))\n)\n</code></pre><p>Actually, this is what I write a few times a day and I have always been too lazy to create an editor snippet for it.</p>\n<p>We&#39;re using the <code>tap</code> operator here. This operator doesn&#39;t change the emitted values but enables us to create side effects such as logging.</p>\n<p>Now that <a href=\"https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md\">pipeable operators</a> have been introduced to RxJS it&#39;s quite easy to build some custom operators.\nIn this article we&#39;ll build a simple <code>log()</code> operator that dramatically simplifies the above code for us:</p>\n<pre><code class=\"language-typescript\">myObservable$.pipe(\n  <span class=\"hljs-built_in\">log</span>(),\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">thing</span> =&gt;</span> thing.id),\n  <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;end&#x27;</span>)\n)\n</code></pre><p>We won&#39;t just get a cool new helper for debugging but we&#39;ll also see, how easy it is to set up some own RxJS operators.</p>\n<h2 id=\"what-are-rxjs-operators\">What are RxJS operators?</h2>\n<p>RxJS operators are used to model the data stream emitted from an observable source.\nWe can chain operators together and put them in a pipeline for our stream.\nThat makes every value run through the whole operator stack.</p>\n<p>Operators are applied using the <code>Observable.pipe()</code> method which takes all the operators as arguments:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-built_in\">map</span>, <span class=\"hljs-built_in\">filter</span> } from <span class=\"hljs-string\">&#x27;rxjs/operators&#x27;</span>;\n\nsource$.pipe(\n  <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> value + <span class=\"hljs-number\">1</span>),\n  <span class=\"hljs-built_in\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> value &gt; <span class=\"hljs-number\">10</span>)\n)\n</code></pre><p>The return value of this expression is a new Observable with the mapped and filtered data stream.\nThere is a whole bunch of built-in RxJS operators which we can import from <code>rxjs/operators</code>.\n<code>map</code> and <code>filter</code> are among the most well-known of them.</p>\n<p>While the whole operator story looks difficult at first sight, there is not much magic in it:\nAn operator is just a simple function that</p>\n<ul>\n<li>takes an Observable as argument and</li>\n<li>returns an Observable (with the altered data stream).</li>\n</ul>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-keyword\">source</span>$: Observable<span class=\"hljs-symbol\">&lt;T&gt;</span>): Observable<span class=\"hljs-symbol\">&lt;U&gt;</span>\n</code></pre><p>We can set up such a function in three different ways:</p>\n<ul>\n<li>create and emit the Observable manually</li>\n<li>use existing operators and pipe the source data through them</li>\n<li>wrap an existing operator into a function closure</li>\n</ul>\n<p>Let&#39;s take a closer look at those three ways.</p>\n<h2 id=\"1-create-and-emit-the-observable-manually\">1) Create and emit the Observable manually</h2>\n<p>The most straight-forward way to create an Observable is using its constructor method <code>new Observable()</code>.\nWe need to set a callback function as argument that is automatically invoked every time a new subscriber is being registered.\nThe callback function takes a so-called <em>Observer</em> as argument which is a reference to the subscriber.\nThe observer gives us three methods which we can use to send data to the subscriber:</p>\n<ul>\n<li><code>next</code>: for a regular value in the stream</li>\n<li><code>error</code>: when errors occur</li>\n<li><code>complete</code>: when the stream has ended</li>\n</ul>\n<p>Using this knowledge of how to create observables we can now go a step further and set up our first own operator. Remember: An operator is a function, that takes and returns an Observable.\nHere we go:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source$</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Observable(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// ...</span>\n    observer.next(<span class=\"hljs-string\">&#x27;next value&#x27;</span>)\n  });\n};\n</code></pre><p>In order to be able to configure our operator with a custom logging message we wrap it into another function that takes that message as argument:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">message</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source$</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Observable(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// ...</span>\n      observer.next(<span class=\"hljs-string\">&#x27;next value&#x27;</span>)\n    });\n  };\n);\n</code></pre><p>Together with some TypeScript types our operator skeleton finally looks like this:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { OperatorFunction } from <span class=\"hljs-string\">&#x27;rxjs/interfaces&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>&lt;<span class=\"hljs-title function_\">T</span>&gt;(<span class=\"hljs-params\">message?: string</span>): <span class=\"hljs-title function_\">OperatorFunction</span>&lt;<span class=\"hljs-title function_\">T</span>, <span class=\"hljs-title function_\">T</span>&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source$: Observable&lt;T&gt;</span>): <span class=\"hljs-title function_\">Observable</span>&lt;<span class=\"hljs-title function_\">T</span>&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Observable&lt;T&gt;(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> {\n      <span class=\"hljs-comment\">// ...</span>\n      observer.next(<span class=\"hljs-string\">&#x27;next value&#x27;</span>)\n    });\n  };\n);\n</code></pre><p>I recommend using the type <code>OperatorFunction&lt;T, U&gt;</code> for our function, where <code>T</code> is the input type and <code>U</code> is the output type of the operator.\nSince we won&#39;t actually alter the data stream we&#39;re fine with <code>OperatorFunction&lt;T, T&gt;</code> here.</p>\n<p>What we want to do inside our <code>log()</code> operator is basically two things:\nWe want to access the source values and</p>\n<ul>\n<li><code>console.log()</code> them</li>\n<li>leave them unchanged and pass them through to the observer</li>\n</ul>\n<p>To access the values emitted from the <code>source$</code> observable we can simply subscribe to it.\nThe <code>subscribe()</code> method takes â€“ no surprise â€“ an observer as an argument, i.e. an object with <code>next</code>, <code>error</code> and <code>complete</code> methods.\nWe could actually just take our original observer and pass it into our <code>subscribe</code> method like this:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Observable&lt;T&gt;(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> {  \n  <span class=\"hljs-keyword\">return</span> source$.subscribe(observer);\n});\n</code></pre><p>However, this will just forward all the source values to the observer without doing a <code>console.log()</code>.\nInstead, we create a wrapper around our observer with an &quot;enhanced&quot; <code>next()</code> method. First we add the <code>console.log()</code> call before emitting the value to our observer.\nThen, for the error and complete case we can just use the methods provided by the original observer.</p>\n<pre><code class=\"language-typescript\">export <span class=\"hljs-keyword\">function</span> <span class=\"hljs-keyword\">log</span>&lt;T&gt;(message?: string): OperatorFunction&lt;T, T&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(source$: Observable&lt;T&gt;): Observable&lt;T&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">new</span> Observable&lt;T&gt;(observer =&gt; {  \n      const <span class=\"hljs-keyword\">wrapper</span> = {\n        next: <span class=\"hljs-keyword\">value</span> =&gt; {\n          console.log(message, <span class=\"hljs-keyword\">value</span>);\n          observer.next(<span class=\"hljs-keyword\">value</span>);\n        },\n        error: observer.error,\n        complete: observer.complete\n      }\n      <span class=\"hljs-keyword\">return</span> source$.subscribe(<span class=\"hljs-keyword\">wrapper</span>);\n    });\n  }\n}\n</code></pre><p><img src=\"%%MARKDOWN_BASE_URL%%/blog/2018-02-rxjs-own-log-operator/observer-wrapper.png\" alt=\"Illustration of the Observer Wrapper from the previous code snippet\"></p>\n<p>If you take a look into the <a href=\"https://github.com/ReactiveX/rxjs/blob/cfbfaac36c847a1d09434a78ac1737c4a3149c5c/src/internal/operators/map.ts#L39-L46\">RxJS source code</a> you will see: that&#39;s exactly the approach they go for all the built-in operators.</p>\n<p>However, for beginners this way is anything but intuitive. For a simple use case like our <code>log()</code> operator this approach might also be a bit too heavy. Apart from that, creating an observable with its constructor is quite focused on the actual implementation. This is a bit error-prone: If we miss out anything here, it can lead to errors.</p>\n<p>Hence, we&#39;ll take a look at a much simpler approach in the next section.</p>\n<h2 id=\"2-use-existing-operators\">2) Use existing operators</h2>\n<p>Let&#39;s cast our minds back to what we wanted to do. Our goal was to hide this line in a custom operator:</p>\n<pre><code class=\"language-typescript\">tap(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, e))\n</code></pre><p>Each operator is already designed to return a new Observable.\nSo why not just use it? Instead of manually creating an Observable with <code>new Observable()</code> we can just return the source stream that has been piped through the existing <code>tap</code> operator:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>&lt;<span class=\"hljs-title function_\">T</span>&gt;(<span class=\"hljs-params\">message?: string</span>): <span class=\"hljs-title function_\">OperatorFunction</span>&lt;<span class=\"hljs-title function_\">T</span>, <span class=\"hljs-title function_\">T</span>&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">source$: Observable&lt;T&gt;</span>): <span class=\"hljs-title function_\">Observable</span>&lt;<span class=\"hljs-title function_\">T</span>&gt; {\n    <span class=\"hljs-keyword\">return</span> source$.pipe(\n      tap(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(message, e))\n    );\n  }\n}\n</code></pre><p>This looks much cleaner and easier to read and understand. Plus, we can clearly recognize our original line in that.</p>\n<h2 id=\"3-wrap-existing-operator-into-closure\">3) Wrap existing operator into closure</h2>\n<p>All the built-in operators already return functions that can be used in the observable pipeline.\nWhat we can now do is, use the existing operator &quot;as is&quot; and return it from our function.\nThus, our <code>function log()</code> returns a specific variant of the original <code>tap()</code> operator.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>&lt;<span class=\"hljs-title function_\">T</span>&gt;(<span class=\"hljs-params\">message?: string</span>): <span class=\"hljs-title function_\">OperatorFunction</span>&lt;<span class=\"hljs-title function_\">T</span>, <span class=\"hljs-title function_\">T</span>&gt; {\n  <span class=\"hljs-keyword\">return</span> tap(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(message, e));\n}\n</code></pre><p>We converted the complex example from above to a one-liner. Great!</p>\n<h2 id=\"which-way-is-the-best\">Which way is the best?</h2>\n<p>The answer to this question really depends on our use case.\nThe general rule is: <strong>as short as necessary, but as readable as possible.</strong></p>\n<p>If you want to create custom combinations of existing operators, it&#39;s always a good idea to just use them and return the piped observable from your function (as seen in #2). When this is just about wrapping <em>one</em> existing operator, #3 is a bit simpler and easier to read.\nIf you want to do more complex stuff than just using the existing operators, you should consider going for approach #1.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Building your own custom operators for your RxJS pipes is very easy. An operator is just a function that takes and returns observables. The function signature is always of type <code>OperatorFunction&lt;T, U&gt;</code>. As long as you stay with this signature you can do whatever you want on the inside: create your own new observable or use existing operators.</p>\n<p>Our <code>log()</code> operator is a great means to debug reactive streams with less typing.\nJust put it into your pipeline and you&#39;ll see the output in the browser console.</p>\n<h2 id=\"demo-see-it-in-action\">Demo: See it in action</h2>\n<p>You can see the <code>log()</code> operator in action in our Stackblitz example:</p>\n<p><strong><a href=\"https://stackblitz.com/edit/rxjs-log-operator?file=app%2Fapp.component.ts\">ðŸ‘‰ Demo on Stackblitz</a></strong></p>\n<h2 id=\"extra-unit-tests\">Extra: Unit tests</h2>\n<p>Our code is still missing an important part: tests!\nHere are some simple unit tests for our <code>log()</code> operator.\nThe last spec is built with marbles. Read more about this hot approach <a href=\"https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\">in the docs</a>!</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Subject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs/Subject&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { log } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./log.operator&#x27;</span>;\n\n<span class=\"hljs-keyword\">import</span> { cold, hot } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;jasmine-marbles&#x27;</span>;\n\ndescribe(<span class=\"hljs-string\">&#x27;log operator&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  let <span class=\"hljs-name\">subject$</span>: Subject&lt;<span class=\"hljs-built_in\">string</span>&gt;;\n\n  beforeEach(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    spyOn(console, <span class=\"hljs-string\">&#x27;log&#x27;</span>);\n    subject$ = new Subject&lt;<span class=\"hljs-built_in\">string</span>&gt;();\n  });\n\n  it(<span class=\"hljs-string\">&#x27;should call console.log with custom message for each emitted value&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    subject$.pipe(log(<span class=\"hljs-string\">&#x27;message&#x27;</span>))\n      .subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {});\n\n    subject$.<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);\n    expect(console.log).toHaveBeenCalledWith(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>);\n\n    subject$.<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);\n    subject$.<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>);\n\n    expect(console.log).toHaveBeenCalledTimes(<span class=\"hljs-number\">3</span>);\n  });\n\n  it(<span class=\"hljs-string\">&#x27;should leave message blank if none given&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    subject$.pipe(log())\n      .subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {});\n\n    subject$.<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);\n    expect(console.log).toHaveBeenCalledWith(undefined, <span class=\"hljs-string\">&#x27;a&#x27;</span>);\n  });\n\n  it(<span class=\"hljs-string\">&#x27;should leave emitted values unchanged&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    let result;\n    subject$.pipe(log())\n      .subscribe(e =&gt; result = e);\n\n    subject$.<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);\n    expect(result).toEqual(<span class=\"hljs-string\">&#x27;a&#x27;</span>);\n\n    subject$.<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);\n    expect(result).toEqual(<span class=\"hljs-string\">&#x27;b&#x27;</span>);\n  });\n\n  it(<span class=\"hljs-string\">&#x27;should leave emitted values unchanged (marble test)&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    const source$ = hot(<span class=\"hljs-string\">&#x27;-a-a-bc&#x27;</span>, { <span class=\"hljs-name\">a</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-name\">b</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-name\">c</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span> })\n    const piped$ = source$.pipe(log());\n    const expected$ = cold(<span class=\"hljs-string\">&#x27;-a-a-bc&#x27;</span>, { <span class=\"hljs-name\">a</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-name\">b</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-name\">c</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span> });\n\n    expect(piped$).toBeObservable(expected$);\n  });\n});\n</code></pre><hr>\n\n<p><small>Header image based on picture by <a href=\"https://de.freeimages.com/photo/birds-meeting-1309186\">FreeImages.com/Petr Kovar</a></small></p>\n","meta":{"title":"Build your own RxJS logging operator","author":"Ferdinand Malcher","mail":"mail@fmalcher.de","published":"2018-02-19T00:00:00.000Z","lastModified":"2018-04-20T00:00:00.000Z","keywords":["RxJS","Reactive Programming","Observable","Angular"],"language":"en","header":{"url":"birds-meeting-1309186.jpg","width":1200,"height":498},"hidden":false,"sticky":false,"darkenHeader":false}}
