{"slug":"2018-03-pure-immutable-operations","html":"<h2 id=\"without-any-framework\">Without any framework</h2>\n<p><strong>In this article, we will take a look at some common &quot;immutable&quot; operations. You will see how modern JavaScript enables us to easily work with immutable data structures in a super clean way without the need of an additional library â€“ using the spread operator and <code>Object.assign()</code>.</strong></p>\n<hr>\n\n<p>If you work with a framework like <a href=\"https://github.com/angular-redux/store\"><code>@angular-redux/store</code></a> or <a href=\"https://github.com/ngrx/platform\">@ngrx</a> then you should try to not alter existing state. Otherwise your redux-driven application will have strange bugs in the end. Immutable objects are also very handy, when you optimise you angular application with <code>ChangeDetectionStrategy.OnPush</code>. In my recent angular applications I tread all my data objects like immutable objects. The great news: it doesn&#39;t matter if those objects are really immutable, as long as we don&#39;t alter them after creation. </p>\n<p>In general, you can decide between two different approaches:</p>\n<ol>\n<li>Use an existing framework like <a href=\"https://facebook.github.io/immutable-js/\">Immutable.js</a> or <a href=\"https://github.com/rtfeldman/seamless-immutable\">seamless-immutable</a>. Those libraries create objects that can&#39;t be changed after creation.</li>\n<li>Use some pure JavaScript patterns that allow us to always create new objects instead of touching existing ones. This is not real immutability, but works fine if we follow the rules. We will concentrate on this approach.</li>\n</ol>\n<p>In the beginning, an existing framework gives you guidance and makes it pretty much harder to mess up the state.\nHowever, using pure ECMAScript functions can be fun, too!\nThere is no extra layer of abstraction and soon you will like those repeating patterns.\nWith a bit of practice your code is very easy to read and to test.\nSounds great?\nLet&#39;s start!</p>\n<p>By the way, we will use TypeScript in order to have interfaces,\na bit of type checking and those nice access modifiers for the constructor we&#39;ll be using later.</p>\n<h2 id=\"1-manipulating-objects-with-the-spread-operator\">1. Manipulating objects with the spread operator</h2>\n<p>Imagine, you have a state like this:</p>\n<pre><code class=\"language-ts\">export <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">State</span> {\n  prop1: <span class=\"hljs-built_in\">string</span>;\n  prop2: <span class=\"hljs-built_in\">string</span>;\n  prop3: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre><p>You want to change one or more properties.\nThe most obvious way to create a new object is this:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">state</span> = {\n  prop1: &#x27;test1&#x27;,\n  prop2: &#x27;test2&#x27;,\n  prop3: &#x27;test3&#x27;\n}\n\n<span class=\"hljs-keyword\">const</span> newState = {\n  prop1: <span class=\"hljs-keyword\">state</span>.prop1,\n  prop2: <span class=\"hljs-keyword\">state</span>.prop2,\n  prop3: &#x27;CHANGED!&#x27;\n}\n\nconsole.<span class=\"hljs-keyword\">log</span>(newState); // {prop1: <span class=\"hljs-string\">&quot;test1&quot;</span>, prop2: <span class=\"hljs-string\">&quot;test2&quot;</span>, prop3: <span class=\"hljs-string\">&quot;CHANGED!&quot;</span>}\n</code></pre><p>This is the same as:</p>\n<pre><code class=\"language-ts\">// ...\n\n<span class=\"hljs-keyword\">const</span> prop1 = <span class=\"hljs-keyword\">state</span>.prop1;\n<span class=\"hljs-keyword\">const</span> prop2 = <span class=\"hljs-keyword\">state</span>.prop1;\n\n<span class=\"hljs-keyword\">const</span> newState = {\n  prop1,\n  prop2,\n  prop3: &#x27;CHANGED!&#x27;\n}\n\nconsole.<span class=\"hljs-keyword\">log</span>(newState); // {prop1: <span class=\"hljs-string\">&quot;test1&quot;</span>, prop2: <span class=\"hljs-string\">&quot;test2&quot;</span>, prop3: <span class=\"hljs-string\">&quot;CHANGED!&quot;</span>}\n</code></pre><p>However, we can also change one or more properties by using the Object Spread Operator (<code>...</code>):</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">state</span> = {\n  prop1: &#x27;test1&#x27;,\n  prop2: &#x27;test2&#x27;,\n  prop3: &#x27;test3&#x27;\n}\n\n<span class=\"hljs-keyword\">const</span> newState = {\n  ...<span class=\"hljs-keyword\">state</span>,\n  prop3: &#x27;CHANGED!&#x27;\n}\n\nconsole.<span class=\"hljs-keyword\">log</span>(newState); // {prop1: <span class=\"hljs-string\">&quot;test1&quot;</span>, prop2: <span class=\"hljs-string\">&quot;test2&quot;</span>, prop3: <span class=\"hljs-string\">&quot;CHANGED!&quot;</span>}\n</code></pre><p>This is easy to understand and super clean!\nAlso the code is not going to break when more properties are added in the future. The ngrx example-app uses this pattern in <a href=\"https://github.com/ngrx/platform/blob/d1fbd35c667a80ea58b82bc28b1fd68bbdb0e659/example-app/app/books/reducers/books.ts#L78\">various places</a>.</p>\n<h1 id=\"2-manipulating-objects-with-objectassign\">2. Manipulating objects with <code>Object.assign()</code></h1>\n<p>Sometimes you want to reuse a bunch of properties from various places.\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\">Object.assign()</a> can be useful here: </p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> initialState = {\n  prop1: &#x27;start1&#x27;,\n  prop2: &#x27;start2&#x27;,\n  prop3: &#x27;start3&#x27;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">state</span> = {\n  prop1: &#x27;test1&#x27;,\n  prop2: &#x27;test2&#x27;,\n  prop3: &#x27;test3&#x27;\n}\n\n<span class=\"hljs-keyword\">const</span> newState = Object.assign(\n  {},\n  initialState,\n  {\n     prop2: <span class=\"hljs-keyword\">state</span>.prop2\n  },\n  {\n     prop3: &#x27;CHANGED!&#x27;\n  }\n);\n\nconsole.<span class=\"hljs-keyword\">log</span>(newState); // {prop1: <span class=\"hljs-string\">&quot;start1&quot;</span>, prop2: <span class=\"hljs-string\">&quot;test2&quot;</span>, prop3: <span class=\"hljs-string\">&quot;CHANGED!&quot;</span>}\n</code></pre><p>The order of arguments is important.\nThe first object is the one whose properties are going to be assigned by <code>Object.assign()</code>.\nThat first object is being mutated, so that&#39;s why we have to use a new empty object here.\nAll other arguments are sources to copy properties from. They are not being mutated.\nIf the same properties occur multiple times, the last one defined wins.</p>\n<h1 id=\"3---10-manipulating-arrays\">3. - 10. Manipulating arrays</h1>\n<p>Recently we found a pretty cool snippet on <a href=\"https://twitter.com/lukejacksonn/status/928244319760220160\">Twitter</a>.\nIt shows a collection of immutable array operations using ECMAScript 2015 syntax:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// immutable-array.js</span>\n\nclone = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> [...x];\n<span class=\"hljs-built_in\">push</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">y</span> =&gt;</span> x =&gt; [...x, y];\n<span class=\"hljs-built_in\">pop</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>);\nunshift = <span class=\"hljs-function\"><span class=\"hljs-params\">y</span> =&gt;</span> x =&gt; [y, ...x];\nshift = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-built_in\">sort</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">f</span> =&gt;</span> x =&gt; [...x].<span class=\"hljs-built_in\">sort</span>(f);\ndelete = <span class=\"hljs-function\"><span class=\"hljs-params\">i</span> =&gt;</span> x =&gt; [...x.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">0</span>, i), ...x.<span class=\"hljs-built_in\">slice</span>(i + <span class=\"hljs-number\">1</span>)];\n<span class=\"hljs-built_in\">splice</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">s, c, ...y</span>) =&gt;</span> x =&gt; [...x.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">0</span>, s), ...y, ...x.<span class=\"hljs-built_in\">slice</span>(s + c)];\n</code></pre><p>All those operations return a new array instead of manipulating the existing one â€“ which is the core concept of immutability.\nHonestly, the code is a bit tricky to read and understand.\nI decided to refactor it a bit and to verify everything with unit tests. <em>(hint: the above code is proven to be flawless)</em></p>\n<pre><code class=\"language-ts\">// immutable-array.ts\n\n/**\n * Immutable<span class=\"hljs-built_in\"> array </span>manipulations\n * These functions don&#x27;t mutate the original<span class=\"hljs-built_in\"> array </span>but<span class=\"hljs-built_in\"> return </span>a<span class=\"hljs-built_in\"> new </span>one instead\n *\n * inspired by https://twitter.com/lukejacksonn/status/928244319760220160\n */\nexport class ImmutableArray {\n\n <span class=\"hljs-keyword\"> constructor</span>(private arr: any[]) { }\n\n  /**\n   * Create a shallow copy of the<span class=\"hljs-built_in\"> array\n</span>   */\n  clone = () =&gt; [...this.arr];\n\n  /**\n   * Add one element to the end of the<span class=\"hljs-built_in\"> array\n</span>   */\n  push = newElement =&gt; [...this.arr, newElement];\n\n  /**\n   * Remove the last element from the<span class=\"hljs-built_in\"> array\n</span>   */\n  pop = () =&gt; this.arr.slice(0, -1);\n\n  /**\n   * Add one elements to the front of the<span class=\"hljs-built_in\"> array\n</span>   */\n  unshift = (newElement) =&gt; [newElement, ...this.arr];\n\n  /**\n   * Remove the first element from the<span class=\"hljs-built_in\"> array\n</span>   */\n  shift = () =&gt; this.arr.slice(1);\n\n  /**\n   * Sort the elements of an<span class=\"hljs-built_in\"> array\n</span>   */\n  sort = compareFn =&gt; this.clone().sort(compareFn);\n\n  /**\n   * Remove an element by index position\n   */\n  delete = index =&gt; [...this.arr.slice(0, index), ...this.arr.slice(index + 1)];\n\n  /**\n   * Remove existing elements<span class=\"hljs-built_in\"> and/or </span>adds<span class=\"hljs-built_in\"> new </span>elements\n   *\n   * @param start Index at which to start changing the<span class=\"hljs-built_in\"> array\n</span>   * @param deleteCount An integer indicating the number of old<span class=\"hljs-built_in\"> array </span>elements to remove\n   * @param elements The elements to<span class=\"hljs-built_in\"> add </span>to the array, beginning at the start index.\n   *                 If you don&#x27;t specify any elements, splice() will only remove elements from the array.\n   */\n  splice = (start, deleteCount, ...elements) =&gt; [\n<span class=\"hljs-keyword\">    .</span>..this.arr.slice(0, start),\n<span class=\"hljs-keyword\">    .</span>..elements,\n<span class=\"hljs-keyword\">    .</span>..this.arr.slice(start + deleteCount)\n  ]\n}\n</code></pre><p>As promised, here is a set of <strong>unit tests</strong> that demonstrate the usage of each method:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-comment\">// immutable-array.spec.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ImmutableArray</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./immutable-array&#x27;</span>;\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&#x27;ImmutableArray&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n\n  <span class=\"hljs-keyword\">let</span> abc;\n  <span class=\"hljs-title function_\">beforeEach</span>(<span class=\"hljs-function\">() =&gt;</span> abc = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>]);\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;clone() should create a shallow copy of the array&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">clone</span>();\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;push() should add one element to the end of the array&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-string\">&#x27;D&#x27;</span>);\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>, <span class=\"hljs-string\">&#x27;D&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;pop() should remove the last element from the array&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">pop</span>();\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;unshift() should add one element to the front of the array&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">unshift</span>(<span class=\"hljs-string\">&#x27;D&#x27;</span>);\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;D&#x27;</span>, <span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;shift() should remove the first element from the array&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">shift</span>();\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;sort() should sort the elements of an array&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> b.<span class=\"hljs-title function_\">localeCompare</span>(a));\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;C&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;A&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;delete() should remove an element by index position&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;splice() should remove 0 elements from index 2, and insert &quot;Z&quot;&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;Z&#x27;</span>);\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;Z&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>]);\n  });\n\n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">&#x27;splice() should remove 2 elements from index 1&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ImmutableArray</span>(abc).<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-title function_\">expect</span>(result).<span class=\"hljs-title function_\">toEqual</span>([<span class=\"hljs-string\">&#x27;A&#x27;</span>]);\n  });\n});\n</code></pre><p>Look closely and you&#39;ll realise that the <code>sort()</code> method is just a little abstraction of the original <code>Array.sort()</code> method.\nThis is because <code>Array.sort()</code> will mutate the given array, which is what we want to avoid.\nIn practice, nobody wants to reimplement the original implementation.\nThus, the simplest way of getting a new sorted array is to make a shallow copy first.</p>\n<h1 id=\"warning\">Warning</h1>\n<p>Please keep in mind, that we just created shallow copies everywhere. This is absolutely fine for most situations and is a very efficient way to do &quot;immutability&quot;. But keep in mind, that things get complicated with nested objects. They are copied over and their reference won&#39;t change. This can confuse the OnPush Change Detection and then the view does not reflect the model anymore.</p>\n<p>In those cases I create deep copies with lodash.\nThe installation is pretty easy:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-built_in\">npm</span> i lodash\n</code></pre><p>and the usage is convenient, too:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { cloneDeep } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;lodash&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> nestedObject = {\n  <span class=\"hljs-attr\">nested</span>: {\n     <span class=\"hljs-comment\">/* ... */</span>\n  }\n}\n<span class=\"hljs-keyword\">const</span> deepCopy = <span class=\"hljs-title function_\">cloneDeep</span>(nestedObject);\n</code></pre><h1 id=\"conclusion\">Conclusion</h1>\n<p>In my opinion, immutable operations are a very powerful tool to handle data. The code gets easy to understand and test, even if we don&#39;t use redux at all.</p>\n<p>Ever wondered about code like this?</p>\n<pre><code class=\"language-ts\">let <span class=\"hljs-keyword\">state</span> =  { /* ... */ };\nsomeFancyService.doStuff(<span class=\"hljs-keyword\">state</span>);\n</code></pre><p>Will it change the state? Usually we don&#39;t know. But if we always treat objects as if they would be immutable, then the answer is clear: No, this code should have no side effects, since we never alter existing objects. To alter existing objects, we have to create new ones:</p>\n<pre><code class=\"language-ts\">let <span class=\"hljs-keyword\">state</span> =  { /* ... */ };\n<span class=\"hljs-keyword\">state</span> = someFancyService.doStuff(<span class=\"hljs-keyword\">state</span>);\n</code></pre><p>Beautiful, isn&#39;t it? ðŸ˜Š</p>\n<hr>\n\n<p><small>Header image by <a href=\"https://www.freeimages.com/photo/glass-cube-and-sphere-1423317\">FreeImages.com/ephe drin</a></small></p>\n","meta":{"title":"10 pure immutable operations you should know","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2018-03-21T00:00:00.000Z","keywords":["Immutable","Array","TypeScript"],"language":"en","header":{"url":"glass-cube-and-sphere-1423317.jpg","width":1500,"height":1120},"hidden":false,"sticky":false,"darkenHeader":false}}
