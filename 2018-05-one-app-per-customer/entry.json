{"slug":"2018-05-one-app-per-customer","html":"<p><strong>In this article, I will discuss some ideas how to produce individual Angular apps.\nHow do we get one app per customer if we have 100+ customers?</strong></p>\n<hr>\n\n<p>Recently, I was asked during a training how to produce customer specific Angular apps.\nMy first answer was: &quot;That&#39;s easy: <code>NgModules</code>!&quot;. But how exactly? 🤔</p>\n<h2 id=\"explanation\">Explanation</h2>\n<p>I asked a little bit more and got the following explanation from the attendee:</p>\n<ul>\n<li>There is nice a REST API backend with <a href=\"https://swagger.io/\">Swagger</a> in place. No work here. Hooray!</li>\n<li>There is a (technically outdated) web application to provide the UI.</li>\n<li>Everything should be re-implemented with Angular, of course.</li>\n<li>There are more than, let&#39;s say, 100 customers.</li>\n<li>Every customer expects a slightly different application with an individual set of features</li>\n</ul>\n<p>One of the current unique selling points are the specific apps.\nEvery customer can purchase a different set of features for different fields of applications.\nThis is, for example, the main feature X along with customer management, debt collection and reports.\nBigger customers might also want a full HR solution, and so on. You get the point.</p>\n<!--\nThis should be easy to achieve, no matter which technical solution is chosen.\nBut it gets a bit more challenging, because some forms are very specific for each customer.\nFor example, the \"order acceptance form\" might have specific controls based on the customer's individual demands for an order.\n\nUntil now the company combined Silverlight and MEF. The technology is outdated,\nbut it had some great strengths:\nIt is possible to create a specific app just by adjusting a configuration file and throwing the required libraries (DLL) into the right folder.\nIf a library is missing, the feature is not shown.\nA more specific screen overrides the standard screen (.NET reflection involved as far as I know) – and it works flawlessly. \n-->\n\n<h2 id=\"requirements\">Requirements</h2>\n<p>The future product/solution should be…</p>\n<ol>\n<li>fast, and not bloated with unused code because of conditional statements</li>\n<li>maintainable, a dedicated build for each customer should be avoided if possible</li>\n</ol>\n<h2 id=\"ideas\">Ideas</h2>\n<p>How could we follow this approach? Let&#39;s collect some ideas:</p>\n<h3 id=\"1-one-big-monolith\">1. One big monolith</h3>\n<p>The simplest approach. One single software project must be maintained. \nWe could use feature toggles (for example <a href=\"https://github.com/willmendesneto/ngx-feature-toggle\">ngx-feature-toggle</a>) to enable/disable specific parts of the application:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">feature-toggle</span> [<span class=\"hljs-attr\">featureName</span>]=<span class=\"hljs-string\">&quot;&#x27;reports&#x27;&quot;</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>condition is true and reports are shown here.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">feature-toggle</span>&gt;</span>\n</code></pre>\n<p>We could also use <code>*ngIf</code> directly, but we would need to add some own boilerplate code around.</p>\n<p><strong>PROS:</strong></p>\n<ul>\n<li>dead simple</li>\n<li>one workspace* to maintain</li>\n<li>one build to maintain</li>\n</ul>\n<p><strong>CONS:</strong></p>\n<ul>\n<li>spaghetti code to maintain</li>\n<li>unused code everywhere (bigger bundle sizes, possible interference everywhere)</li>\n<li>hard/impossible to deliver different versions to different customers (one update for one customer effects all other customers, too)</li>\n<li>just no</li>\n</ul>\n<p><em><code>*</code> The term &quot;workspace&quot; refers to one Angular CLI project in one physical folder.\nI don&#39;t want to confuse this with the word &quot;project&quot; in the context of the new multi application/library support (see below).</em></p>\n<h3 id=\"2-one-fat-project-multiple-small-appsextracting-everything-to-npm-packages\">2. One fat project, multiple small apps<br>(Extracting everything to NPM packages)</h3>\n<p>I&#39;m a big fan of Angular modules that are compiled and delivered via NPM.\nNPM packages have versions and can demand dependencies.\nThe great thing: they can be hosted privately\non <a href=\"https://docs.npmjs.com/private-modules/intro\">NPM</a> or a local mirror like\n<a href=\"https://www.myget.org/\">myget</a>,\n<a href=\"https://docs.microsoft.com/en-us/vsts/package/?view=vsts\">TFS</a> (on-premise or in the cloud),\n<a href=\"https://www.sonatype.com/nexus-repository-oss\">Nexus</a>,\n<a href=\"https://github.com/verdaccio/verdaccio\">verdaccio</a> (a fork of good-old sinopia) and many more!</p>\n<p>Before Angular CLI 6 was released I was used to <a href=\"https://github.com/dherges/ng-packagr\"><code>ng-packagr</code></a>.\nIt took me some time to configure an existing product to work as described in the demo <a href=\"https://github.com/dherges/ng-packaged\"><code>ng-packaged</code></a>.\nBut it the end, the work has paid off (e.g. <a href=\"https://github.com/angular-schule/homepage-tools\">here</a>).\nWhat you get is an NPM package with an Angular library in the <a href=\"https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/edit\">Angular Package Format</a> which is relatively easy to setup but also highly configurable.</p>\n<p>With version 6 of the Angular CLI we finally got &quot;official&quot; support for multiple projects in one folder – which is great!\nTake a look at the new workspace file (<code>angular.json</code>) for that.\nA project can either be an application or a library (see <a href=\"https://github.com/angular/angular-cli/wiki/angular-workspace\">here</a>).\nThe library support actually works on top of <code>ng-packagr</code>.</p>\n<p>You can create a library in an existing workspace by running the following command:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> <span class=\"hljs-keyword\">library</span> my-lib\n</code></pre>\n<p>You should now have a library inside <code>projects/my-lib</code>.\nIt contains a component and a service inside an <code>NgModule</code>.\nRead more about library creation <a href=\"https://github.com/angular/angular-cli/wiki/stories-create-library\">in the Angular CLI wiki</a>.</p>\n<p>We could create one (or more) projects that  contain the ultimate, full-blown app.\nEvery feature would be organized in one <code>NgNodule</code> and would be delivered as one NPM package.\nConsequently, we would need 100 smaller workspaces that compose those NPM packages.\nWe would have one big app and each customer has their own Angular CLI solution.</p>\n<p><strong>PROS:</strong></p>\n<ul>\n<li>easy to setup since there is direct support via Angular CLI now</li>\n<li>every single workspace is highly customizable </li>\n<li>the dedicated apps only contain the code they need, this should lead to small bundle sizes</li>\n<li><strong>USP:</strong> we can utilize semver <strong>versioning</strong> to deliver features/patches only to selected applications (and therefore selected customers, too)</li>\n</ul>\n<p><strong>CONS:</strong></p>\n<ul>\n<li>multiple workspaces to maintain (in the worst case this is 100+1 workspaces)</li>\n<li>multiple builds to maintain</li>\n<li>possible version conflicts in complex scenarios</li>\n<li>historically, Angular CLI and <code>npm link</code> were never real friends (see <a href=\"https://github.com/angular/angular-cli/issues/3854#issuecomment-274344771\">here</a>, or <a href=\"https://github.com/angular/angular-cli/issues/6195\">here</a>)</li>\n</ul>\n<h3 id=\"3-monorepo-one-fat-application-with-multi-application-supportno-npm-packages-involved\">3. Monorepo: One fat application with multi application support<br>(No NPM packages involved)</h3>\n<p>This idea is pretty similar to #2. However, this time we combine multiple apps in one big repo via <code>angular.json</code>.\nAngular CLI now supports multiple individual applications within one workspace,\neach with separate configurations and defaults.\nTo create another app within an existing workspace you can use the following command:</p>\n<pre><code class=\"language-bash\">ng <span class=\"hljs-keyword\">generate</span> application my-other-app\n</code></pre>\n<p>The new application will be generated inside <code>projects/my-other-app</code>.\nWe can now build each application by passing the project name with the build command:</p>\n<pre><code class=\"language-bash\">ng build <span class=\"hljs-keyword\">my</span>-other-app\n</code></pre>\n<p>Approach #2 was based on the idea of multiple libraries.\nNow we have multiple apps which derive from the big fat application.\nWe reduce complexity, since we don&#39;t need to publish a big amount of NPM packages around.\nThe first application could be the &quot;big fat application&quot; that contains all feature modules and shared modules to have the full picture.\nAll other applications could only use the required NgModules – and not more.</p>\n<p><strong>PROS:</strong></p>\n<ul>\n<li>easy to setup, since there is direct support via Angular CLI</li>\n<li>small bundle sizes, too</li>\n<li>one workspace to maintain</li>\n<li>one build to maintain (if we build multiple apps in one big build)</li>\n<li>no versioning (this can be a good point, everything is in sync with everything else)</li>\n</ul>\n<p><strong>CONS:</strong></p>\n<ul>\n<li>the build will have a very long runtime if we choose to build all apps</li>\n<li>no versioning: we can not utilize semver versioning to deliver features/patches only to selected applications</li>\n</ul>\n<h2 id=\"hands-on\">Hands on!</h2>\n<p>I see pretty few disadvantages for the last approach, so I definitely recommend #3.\nIf this doesn&#39;t scale, we can still mix #2 and #3 by extracting some parts into separate NPM packages.</p>\n<h4 id=\"diy-monorepo\">DIY Monorepo</h4>\n<p>Let&#39;s try this out using the Angular CLI (v6.0.3 at the time of writing).</p>\n<pre><code class=\"language-bash\">npm install -g @angular/cli\nng <span class=\"hljs-keyword\">new</span> one-app-per-customer --routing\ncd one-app-per-customer\nng <span class=\"hljs-keyword\">generate</span> application company1 --routing --prefix=company1\nng <span class=\"hljs-keyword\">generate</span> application company2 --routing --prefix=company2\nng <span class=\"hljs-keyword\">generate</span> <span class=\"hljs-keyword\">library</span> shared-lib --prefix=shared-lib\n</code></pre>\n<p>Feel free to tweak the folder structure a bit by adjusting <code>angular.json</code>.\nFor example, Nrwl Nx (see below) creates a folder called <code>/apps</code> and another one called <code>/libs</code> in the root of the workspace.\nThis is for sure cleaner than the default folder structure of the Angular CLI.\nBut lets keep it as it is, for now.\nWe can now run each application with:</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">ng</span> serve -o\nng serve company1 -o\nng serve company2 -o\n</code></pre>\n<p>That was easy!\nLet&#39;s add a new component to the library:</p>\n<pre><code class=\"language-bash\">cd projects/shared-lib/<span class=\"hljs-attribute\">src</span>/lib\nng <span class=\"hljs-selector-tag\">g</span> component awesome-<span class=\"hljs-selector-tag\">button</span> <span class=\"hljs-attr\">--flat</span> <span class=\"hljs-attr\">--export</span>\n</code></pre>\n<p>This will create the new component at the right place and also tweaks the libraries module so that the component can be imported from other places. </p>\n<p>It&#39;s a good idea to adjust the public API surface of shared-lib and add the following line to <code>public_api.ts</code>:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-built_in\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./lib/awesome-button.component&#x27;</span>;\n</code></pre>\n<p>In our case this step is not strictly required, we can use the component within our templates anyway.\nHowever, it will be useful to have access to that type, e.g. if you want to use the <a href=\"https://angular.io/api/common/NgComponentOutlet\">NgComponentOutlet</a> later on.</p>\n<p><strong>It&#39;s important to note that your app can never use your library before it is built.</strong>\nSo we have to call the following command every time we did a change in the lib:</p>\n<pre><code class=\"language-bash\">ng build <span class=\"hljs-keyword\">shared</span>-<span class=\"hljs-keyword\">lib</span>\n</code></pre>\n<p>Running <code>ng build</code> every time you change a file is bothersome and takes time.\nIn the future the Angular CLI team wants to add watch support to building libraries so it is faster to see changes.\nPlease refer to <a href=\"https://github.com/angular/angular-cli/blob/267532d1f26b9a52b80f46e3f16b4afe6497fc00/docs/documentation/stories/create-library.md\">this documentation</a> for a full explanation of the current limitation.\nHowever, I don&#39;t think that we have to wait a long time for a suitable solution.</p>\n<p>Take a look at the topmost <code>tsconfig.json</code> and its <code>paths</code> property:</p>\n<pre><code class=\"language-ts\">{\n  [...]\n\n    <span class=\"hljs-string\">&quot;paths&quot;</span>: {\n      <span class=\"hljs-string\">&quot;shared-lib&quot;</span>: [\n        <span class=\"hljs-string\">&quot;dist/shared-lib&quot;</span>\n      ]\n    }\n\n  [...]\n}\n</code></pre>\n<p>This allows us to import the <code>AwesomeButtonComponent</code> via its module like this:</p>\n<pre><code class=\"language-ts\">/<span class=\"hljs-regexp\">/ one-app-per-customer/projects</span><span class=\"hljs-regexp\">/company1/src</span><span class=\"hljs-regexp\">/app/app</span>.<span class=\"hljs-keyword\">module</span>.ts\n\nimport { <span class=\"hljs-title class_\">SharedLibModule</span> } from <span class=\"hljs-string\">&#x27;shared-lib&#x27;</span>;\n<span class=\"hljs-regexp\">//</span> [...]\n\n<span class=\"hljs-variable\">@NgModule</span>({\n  <span class=\"hljs-symbol\">declarations:</span> [\n    <span class=\"hljs-title class_\">AppComponent</span>\n  ],\n  <span class=\"hljs-symbol\">imports:</span> [\n    <span class=\"hljs-title class_\">BrowserModule</span>,\n    <span class=\"hljs-title class_\">SharedLibModule</span>\n  ],\n  <span class=\"hljs-symbol\">bootstrap:</span> [<span class=\"hljs-title class_\">AppComponent</span>]\n})\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppModule</span> { }\n</code></pre>\n<p><img src=\"https://angular-schule.github.io/website-articles/2018-05-one-app-per-customer/screenshot_awesome.png\" alt=\"Screenshot\"></p>\n<p>Awesome! 😉</p>\n<h4 id=\"nrwl-nx\">Nrwl Nx</h4>\n<p>Another way to start is <a href=\"https://github.com/nrwl/nx-examples\">Nrwl Nx</a>:</p>\n<pre><code class=\"language-bash\">npm install -g @angular/cli @nrwl/schematics \ncreate-nx-workspace one-app-per-customer\ncd one-app-per-customer\nng <span class=\"hljs-keyword\">generate</span> app big-fat-app --routing\nng <span class=\"hljs-keyword\">generate</span> app company1 --routing\nng <span class=\"hljs-keyword\">generate</span> app company2 --routing\nng <span class=\"hljs-keyword\">generate</span> <span class=\"hljs-keyword\">library</span> shared-lib\n</code></pre>\n<p>All commands are explained <a href=\"https://github.com/nrwl/nx-examples\">here</a>.\nThis gives you the quickest possible out-of-the-box solution available.\nThe folder structure is beautiful by default and we have a ton of blueprints (schematics) available.\nIt looks almost the same, but the <code>ng generate</code> commands will produce different output, since under the hood another schematic is used.\nFor example, the <code>--prefix</code> option will be ignored as the tool follows another convention. Also the router configuration will be inline and so on.\nYou may like this different flavor.</p>\n<p>However, we have to keep in mind that <code>@nrwl/schematics</code> adds yet another dependency and a layer of abstraction into the solution.\nPersonally, I&#39;d stick to the DYI approach. \nWe can achieve almost the same with pure Angular CLI – and still get inspiration by using the best ideas from Nx.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>In this article we discussed different approaches towards structuring a workspace to handle multiple applications that share code.\nI personally like the &quot;monorepo&quot; approach.\nWe also created a first prototype via the Angular CLI, which was easy to setup – thanks to the new support for multiple applications.\nYou can find the full example here:</p>\n<ul>\n<li><strong><a href=\"https://github.com/angular-schule/demo-one-app-per-customer\">https://github.com/angular-schule/demo-one-app-per-customer</a></strong></li>\n</ul>\n<h2 id=\"thanks\">Thanks</h2>\n<p>Many thanks to <strong><a href=\"http://www.softwarearchitekt.at/\">Manfred Steyer</a></strong> and <strong><a href=\"https://juristr.com/\">Juri Strumpflohner</a></strong> for taking a look at this article before publishing.\nI really appreciate your feedback! 👍</p>\n<p>And a big thank-you goes to <strong>Ferdinand</strong> for reviewing all my texts! 😉</p>\n<hr>\n\n<p><small>Header image based on picture by <a href=\"https://www.freeimages.com/photo/buttons-1414105\">FreeImages.com/Zsuzsa N.K.</a></small></p>\n","meta":{"title":"One app per customer","author":"Johannes Hoppe","mail":"johannes.hoppe@haushoppe-its.de","published":"2018-05-21T00:00:00.000Z","keywords":["Angular","NgModule","Modules"],"language":"en","thumbnail":"https://angular-schule.github.io/website-articles/2018-05-one-app-per-customer/100-apps.png"}}
