{"slug":"2024-11-linked-signal","html":"<p>In Angular 19, there‚Äôs a <a href=\"https://github.com/angular/angular/commit/8311f00faaf282d1a5b1ddca29247a2fba94a692\">new experimental feature</a> called a <strong>Linked Signal</strong> that makes it easier to keep track of local state that depends on other signals. It lets us create a writable signal that can automatically reset based on changes in other signals. \nThis makes it particularly useful for situations where local state needs to stay in sync with dynamic data. \nHere‚Äôs a look at what the Linked Signal is, how it works, and some common use cases.</p>\n<h2 id=\"contents\">Contents</h2>\n<ul>\n<li><a href=\"/blog/2024-11-linked-signal#what-is-a-linked-signal\">What is a Linked Signal?</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#basic-usage-of-linked-signal\">Basic Usage of Linked Signal</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#advanced-scenarios-for-linked-signals\">Advanced Scenarios for Linked Signals</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#linked-signal-vs-other-signals\">Linked Signal vs. Other Signals</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#best-practices-for-using-linked-signal\">Best Practices for Using Linked Signal</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#demo-application\">Demo Application</a></li>\n<li><a href=\"/blog/2024-11-linked-signal#conclusion\">Conclusion</a></li>\n</ul>\n<blockquote>\n<p><strong>üá©üá™ This article is available in German language here: <a href=\"https://angular-buch.com/blog/2024-11-linked-signal\">Neu in Angular 19: LinkedSignal f√ºr reaktive Zustandsverwaltung</a></strong></p>\n</blockquote>\n<h2 id=\"what-is-a-linked-signal\">What is a Linked Signal?</h2>\n<p>A Linked Signal is an experimental feature that Angular 19 introduces to help you manage state that automatically syncs with other signals. \nIn simple terms, we receive a writable signal that resets itself when the value of its source signal changes.\nA Linked Signal can be created by using the <a href=\"https://next.angular.dev/api/core/linkedSignal\"><code>linkedSignal()</code> factory function</a>.</p>\n<p>A Linked Signal has the following characteristics:</p>\n<ul>\n<li><strong>Writable and Reactive</strong>: Like a <a href=\"https://angular.dev/guide/signals#writable-signals\"><code>signal</code></a>, we can update the value of a Linked Signal manually, but it also responds to changes in its source.</li>\n<li><strong>A Combination of Signal and Computed</strong>: It‚Äôs like <a href=\"https://angular.dev/guide/signals#computed-signals\"><code>computed</code></a> because it derives its value from other signals, but it stays writable, allowing us to override it when needed.</li>\n</ul>\n<p>By combining these characteristics, Linked Signals provide a flexible way to manage state that adapts to changes in related signals but can also be directly controlled when required.\nTo understand the flexibility, consider the following example which compares Computed and Linked Signals:</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">import</span> { computed, linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-keyword\">const</span> timestampMs = signal(Date.now());\n\n<span class=\"hljs-comment\">// computed(): Signal (not writable)</span>\n<span class=\"hljs-keyword\">const</span> timestampSeconds = computed(() =&gt; timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSeconds.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ‚ùå compilation error</span>\n\n<span class=\"hljs-comment\">// linkedSignal(): WritableSignal</span>\n<span class=\"hljs-keyword\">const</span> timestampSecondsLinked = linkedSignal(() =&gt; timestampMs() / <span class=\"hljs-number\">1000</span>);\ntimestampSecondsLinked.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// ‚úÖ works</span>\n</code></pre>\n<p>The signature and usage of <code>computed()</code> and <code>linkedSignal()</code> look very similar: Both accept a computation function which updates the result value of the signal when any of the bound signals (here: <code>timestampMs</code>) changes.\nThe difference lies in their return types: While <code>computed()</code> returns a read-only <code>Signal</code>, the new <code>linkedSignal()</code> function creates a <code>WritableSignal</code>.</p>\n<p>That means, we can override the value using <code>set()</code> and <code>update()</code> whenever required.\nA signal created with <code>computed()</code> does not allow modifying the value manually.</p>\n<p>In this first example, we used the <strong>shorthand syntax</strong> for the Linked Signal.\nIt is also possible to separate the computation into a second function.\nThe value of the source is automatically passed into the computation function.</p>\n<pre><code class=\"language-ts\"><span class=\"hljs-keyword\">const</span> timestampMs = <span class=\"hljs-keyword\">signal</span><span class=\"hljs-string\"></span>(<span class=\"hljs-built_in\">Date</span>.now());\n\n<span class=\"hljs-keyword\">const</span> timestampSecondsLinked = linkedSignal({\n  <span class=\"hljs-attribute\">source</span>: timestampMs,\n  <span class=\"hljs-attribute\">computation</span>: ms =&gt; ms / <span class=\"hljs-number\">1000</span>\n});\n</code></pre>\n<p>Whether or not to use the the more elaborate options object with <code>source</code> and <code>computation</code> over the simpler shorthand syntax depends on use-case and taste.\nBoth examples for <code>timestampSecondsLinked</code> above have the exact same behaviour.\nIn more complex cases, a separate computation function might make the code more readable.</p>\n<h2 id=\"basic-usage-of-linked-signal\">Basic Usage of Linked Signal</h2>\n<p>To see how it works, let‚Äôs take a look at a complete example. \nOur component has a list of books in the <code>books</code> signal.\nThen we‚Äôre using a Linked Signal to keep track of the <em>first book</em> in the list.\nWe decided to use the full notation with an options object. The separate computation makes it more readable, compared to a one-line function that combines source and computation.</p>\n<p>Whenever the list of books changes (e.g. through the <code>changeBookList()</code> method), the <code>firstBook</code> signal will automatically recalculate its value to the first book in the updated list.\nUp to here, all of this could have been achieved with a Computed Signal.\nHowever, the Linked Signal makes it possible to manually override the value in the <code>overrideFirstBook()</code> method.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, linkedSignal, signal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-book-list&#x27;</span>,\n  template: `\n    &lt;p&gt;First book in list: {{ firstBook() }}&lt;/p&gt;\n    &lt;button (click)=<span class=\"hljs-string\">&quot;changeBookList()&quot;</span>&gt;Change Book List&lt;/button&gt;`\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookListComponent</span> {\n  books = signal([<span class=\"hljs-string\">&#x27;Angular&#x27;</span>, <span class=\"hljs-string\">&#x27;React&#x27;</span>, <span class=\"hljs-string\">&#x27;Vue&#x27;</span>]);\n\n  firstBook = linkedSignal({\n    source: <span class=\"hljs-keyword\">this</span>.books,\n    computation: books =&gt; books[<span class=\"hljs-number\">0</span>]\n  });\n\n  <span class=\"hljs-comment\">// this also works (shorthand notation)</span>\n  <span class=\"hljs-comment\">// firstBook = linkedSignal(() =&gt; this.books()[0]);</span>\n\n  overrideFirstBook() {\n    <span class=\"hljs-comment\">// Manually updating `firstBook`, which now returns &#x27;jQuery&#x27;</span>\n    <span class=\"hljs-keyword\">this</span>.firstBook.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">&#x27;jQuery&#x27;</span>);\n  }\n\n  changeBookList() {\n    <span class=\"hljs-comment\">// Changing `books` causes `firstBook` to reset, now returning &#x27;Next.js&#x27;</span>\n    <span class=\"hljs-keyword\">this</span>.books.<span class=\"hljs-keyword\">set</span>([<span class=\"hljs-string\">&#x27;Next.js&#x27;</span>, <span class=\"hljs-string\">&#x27;Svelte&#x27;</span>, <span class=\"hljs-string\">&#x27;Nuxt&#x27;</span>]);\n  }\n}\n</code></pre>\n<p>In this example:</p>\n<ul>\n<li>The Linked Signal <code>firstBook</code> initially points to the first book in the list of <code>books</code>.</li>\n<li>We can override the value manually at any time, as shown with the &quot;jQuery&quot; book.</li>\n<li>When <code>books</code> changes, <code>firstBook</code> recalculates to reflect the first item in the updated list.</li>\n</ul>\n<p>The signal always holds the latest value ‚Äì either set manually through <code>set()</code>/<code>update()</code> or calculated by the computation function when the source changes.</p>\n<h3 id=\"use-case-with-input-signals\">Use Case with Input Signals</h3>\n<p>A common use for a Linked Signal is a component that resets based on an input signal. \nFor example, a shopping cart component might want to reset the quantity field when the selected product changes. \nWhile we could achieve the same result with <code>computed</code>, we also want to be able to set the quantity based on the user&#39;s input.</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, input, linkedSignal } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-shopping-cart&#x27;</span>,\n  template: `<span class=\"language-javascript\">\n    &lt;p&gt;<span class=\"hljs-title class_\">Book</span>: {{ <span class=\"hljs-title function_\">selectedBook</span>().<span class=\"hljs-property\">title</span> }}&lt;/p&gt;\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> [(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;amount&quot;</span>&gt;</span></span></span>`,\n  imports: [FormsModule]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ShoppingCartComponent</span> {\n  selectedBook = input.required&lt;Book&gt;();\n  amount = linkedSignal({\n    source: this.selectedBook,\n    computation: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-number\">1</span> // Resets to <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">when</span> selectedBook changes\n  });\n}\n</code></pre>\n<p>In this case, whenever <code>selectedBook</code> changes, the value of <code>amount</code> resets to 1.\nThe <code>&lt;input&gt;</code> field in the template reflects this change and resets to 1 as well.\nThis pattern is useful in forms where we want fields to reset to a default state when certain inputs change.</p>\n<p>For this use-case, the full notation with <code>source</code> and <code>computation</code> is the most straight-forward way: We are not interested in the actual value of <code>selectedBook</code>. Instead, we just want to reset the value to <code>1</code> whenever <code>selectedBook</code> changes. This is why we separated <code>source</code> and <code>computation</code>.</p>\n<h2 id=\"advanced-scenarios-for-linked-signals\">Advanced Scenarios for Linked Signals</h2>\n<h3 id=\"nested-state-management\">Nested State Management</h3>\n<p>Suppose you have nested data such as book properties (<code>title</code> and <code>rating</code>), and we want these fields to reset when a different <code>book</code> is selected. \nHere‚Äôs how we could manage this with a Linked Signal:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, computed, input, linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-book&#x27;</span>,\n  template: `\n    &lt;p&gt;Title: {{ title() }}&lt;/p&gt;\n    &lt;p&gt;Rating: {{ rating() }}&lt;/p&gt;\n\n    &lt;button (click)=<span class=\"hljs-string\">&quot;doRateUp()&quot;</span>&gt;Rate up&lt;/button&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BookComponent</span>  {\n  book = input.required&lt;Book&gt;();\n  ratingChange = output&lt;{ isbn: string, newRating: number }&gt;();\n\n  title = computed(() =&gt; <span class=\"hljs-keyword\">this</span>.book().title);\n  rating = linkedSignal(() =&gt; <span class=\"hljs-keyword\">this</span>.book().rating);\n\n  <span class=\"hljs-comment\">// this also works (full notation)</span>\n  <span class=\"hljs-comment\">/*rating = linkedSignal({\n    source: this.book,\n    computation: book =&gt; book.rating,\n  });*/</span>\n\n  doRateUp() {\n    <span class=\"hljs-keyword\">const</span> newRating = <span class=\"hljs-keyword\">this</span>.rating() + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">this</span>.rating.<span class=\"hljs-keyword\">set</span>(newRating);\n\n    <span class=\"hljs-keyword\">this</span>.ratingChange.emit({ \n      isbn: <span class=\"hljs-keyword\">this</span>.book().isbn,\n      newRating\n    });\n  }\n}\n</code></pre>\n<p>Our properties <code>title</code> and <code>rating</code> are derived from the <code>book</code> source.\nBoth <code>title</code> and <code>rating</code> recalculate their values when <code>book</code> changes, helping to keep data synchronized in cases where the structure of state is hierarchical or dependent on specific identifiers.\nWhile the Linked Signal makes sure that the data resets when necessary, we can still update our local state directly.\nIn this example we update <code>rating</code> locally and communicate the change back to the parent component.\nSince we don‚Äôt need to modify the <code>title</code> within the component, a Computed Signal fulfils this task.</p>\n<p>We used the shorthand notation for the Linked Signal because the computation is very simple.\nAlso, compared to <code>computed()</code>, both lines look very similar.\nHowever, depending on your taste, the full notation is also possible.</p>\n<h3 id=\"synchronizing-server-data-for-client-side-edits\">Synchronizing Server-Data for Client-Side Edits</h3>\n<p>A Linked Signal is also helpful when working with server data that needs to be edited locally.\nIf we‚Äôre fetching data from an API but need to allow changes on the client side, we can use <code>linkedSignal()</code> to keep local edits in sync with the original server data.\nHere is an example that uses data from our HTTP API, fetched through a simple <code>HttpClient</code> wrapper called <code>BookStoreService</code>:</p>\n<pre><code class=\"language-typescript\"><span class=\"hljs-keyword\">import</span> { Component, inject, linkedSignal } from <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { BookStoreService } from <span class=\"hljs-string\">&#x27;./book-store.service&#x27;</span>;\n\n<span class=\"hljs-meta\">@Component({\n  selector: <span class=\"hljs-string\">&#x27;app-dashboard&#x27;</span>,\n  template: `\n    @for (b of books(); track b.isbn) {\n      &lt;app-book\n        (ratingChange)=<span class=\"hljs-string\">&quot;handleRatingChange(<span class=\"hljs-variable\">$event</span>.isbn, <span class=\"hljs-variable\">$event</span>.newRating)&quot;</span>\n        [book]=<span class=\"hljs-string\">&quot;b&quot;</span>\n      /&gt;\n    } \n\n    &lt;button (click)=<span class=\"hljs-string\">&quot;changeOrder()&quot;</span>&gt;Change order (locally)&lt;/button&gt;\n  `,\n})</span>\nexport <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DashboardComponent</span> {\n  <span class=\"hljs-keyword\">private</span> bookStore = inject(BookStoreService);\n\n  books = linkedSignal(\n    toSignal(<span class=\"hljs-keyword\">this</span>.bookStore.getAllBooks(), { initialValue: [] })\n  );\n\n  changeOrder() {\n    <span class=\"hljs-keyword\">this</span>.books.update(books =&gt; books.toReversed());\n  }\n\n  handleRatingChange(isbn: string, newRating: number) {\n    <span class=\"hljs-keyword\">this</span>.books.update(books =&gt;\n      books.map(b =&gt; {\n        <span class=\"hljs-comment\">// if this is the book we want to update, set the new rating</span>\n        <span class=\"hljs-keyword\">if</span> (b.isbn === isbn) {\n          <span class=\"hljs-keyword\">return</span> { ...b, rating: newRating };\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-comment\">// leave all other books in the list unchanged</span>\n          <span class=\"hljs-keyword\">return</span> b;\n        }\n      })\n    );\n  }\n}\n</code></pre>\n<p>In this example, <code>books</code> holds the server data.\nTypically, we would use <code>toSignal()</code> to convert the RxJS Observable to a signal. \nHowever, with <code>toSignal()</code> alone, we wouldn‚Äôt be able to edit the fetched data directly (except by emitting a new item from the Observable). </p>\n<p>Using a Linked Signal, we can still modify the data locally, and any major reset (such as a reload) can restore it to the original source if needed.</p>\n<p>We used the shorthand notation for <code>linkedSignal()</code> and passed in the signal from <code>toSignal()</code> directly. This is because we only want to convert the source into a Linked Signal. There is no need for an additional computation.</p>\n<p>We then change the order of the book list whenever the method <code>changeOrder()</code> is called.\nWe‚Äôre also handling the <code>ratingChange</code> event from the previous example.\nThe corresponding <code>handleRatingChange()</code> method accepts the identifier <code>isbn</code> and the new rating, and replaces the outdated book entity with an updated copy.\nTo complete the flow, it would also be possible to modify the book data and send the updated state back to the server.</p>\n<blockquote>\n<p>‚ÑπÔ∏è <strong>Did you know?</strong> Angular introduced the new experimental <strong>Resource API</strong> in version 19. It allows you to load data asynchronously while keeping the result signal writable.\nWe presented the Resource API in a separate blog post (in German üá©üá™): <strong><a href=\"https://angular-buch.com/blog/2024-10-resource-api\">Die neue Resource API von Angular</a></strong></p>\n</blockquote>\n<h2 id=\"linked-signal-vs-other-signals\">Linked Signal vs. Other Signals</h2>\n<p>Here‚Äôs a quick comparison with other types of signals in Angular:</p>\n<ul>\n<li><strong><code>signal()</code></strong>: Creates a basic writable signal that maintains its value independently of other signals. It has a start value, and the value can be overridden with <code>set()</code> and <code>update()</code>.</li>\n<li><strong><code>computed()</code></strong>: Creates a read-only signal derived from other signals, recalculating automatically but without allowing manual changes.</li>\n<li><strong><code>linkedSignal()</code></strong>: Combines the reactivity of <code>computed()</code> with the mutability of <code>signal()</code>, allowing the value to be updated manually while remaining linked to a source signal.</li>\n</ul>\n<p>We recommend to only use <code>linkedSignal()</code> for state that should reset based on specific dependencies. Please continue to use <code>computed()</code> for derived data that doesn‚Äôt need to be overridden.</p>\n<h2 id=\"best-practices-for-using-linked-signal\">Best Practices for Using Linked Signal</h2>\n<p>Here are some tips for using Linked Signals effectively:</p>\n<ul>\n<li><strong>Keep Computation Functions Simple</strong>: Avoid complex calculations in the <code>computation</code> function to prevent cyclic dependencies and make your code easier to understand. \nIf a computation leads to a cyclic read of itself, Angular will stop execution with the following error: <a href=\"https://github.com/angular/angular/blob/7d0ba0cac85220cbbe4044667a51e5b95512f5d6/packages/core/primitives/signals/src/computed.ts#L114\">&quot;Detected cycle in computations.&quot;</a></li>\n<li><strong>Use for Resetting Patterns</strong>: <code>linkedSignal()</code> is ideal for cases where you need to reset a state based on a particular signal, like clearing a form field when a new item is selected. \nIf you don&#39;t need reset functionality, consider using <code>computed()</code> instead.</li>\n<li><strong>Consider Effects for Multiple Updates</strong>: If you need multiple signals to react to a single change, using <code>effect()</code> might be clearer and more efficient than creating multiple signals with <code>linkedSignal()</code>.</li>\n</ul>\n<h2 id=\"demo-application\">Demo Application</h2>\n<p>To make it easier to see Linked Signals in action, we‚Äôve created a demo application on GitHub that showcases all the examples discussed in this article.\nThe first link leads to the source code on GitHub, where you can download it.\nThe second link opens a deployed version of the application for you to try out.\nLast but not least, the third link provides an interactive demo on StackBlitz, where you can edit the source code and see the results in real time.</p>\n<blockquote>\n<p><strong><a href=\"https://github.com/angular-schule/demo-linked-signal\">1Ô∏è‚É£ Source on GitHub: demo-linked-signal</a></strong><br><strong><a href=\"https://angular-schule.github.io/demo-linked-signal/\">2Ô∏è‚É£ Deployed application</a></strong><br><strong><a href=\"https://stackblitz.com/github/angular-schule/demo-linked-signal?file=src%2Fapp%2Fbooks%2Fdashboard%2Fdashboard.component.ts\">3Ô∏è‚É£ StackBlitz Demo</a></strong>  </p>\n</blockquote>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>The Linked Signal feature in Angular 19 provides a practical solution for managing state that needs to stay in sync with other signals. \nIt fills the gap between <code>signal()</code> and <code>computed()</code>, offering a new way to handle complex reactive frontends where state synchronization is essential. \nTry out <code>linkedSignal()</code> in your Angular project to see how it can simplify your state management. \n** ‚ö†Ô∏è Please keep in mind that this API is still experimental and could drastically change based on feedback from the community.**</p>\n<hr>\n\n<p><small>Thanks to Danny Koppenhagen for review and feedback!</small></p>\n<p><small><strong>Cover image:</strong> Generated with Adobe Firefly</small></p>\n","meta":{"title":"Angular 19: Introducing LinkedSignal for Responsive Local State Management","author":"Johannes Hoppe and Ferdinand Malcher","mail":"team@angular.schule","published":"2024-11-04T00:00:00.000Z","lastModified":"2024-11-04T00:00:00.000Z","keywords":["Angular","JavaScript","Signals","Reactive Programming","Linked Signal","Angular 19","Computed Signals"],"language":"en","thumbnail":"https://angular-schule.github.io/website-articles/2024-11-linked-signal/linkedsignal.jpg","sticky":false}}